<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Blog of ChiFun</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(/assets/blog.png)">
        </div>
    </section>
    <section class='menu'>
        <div>Blog of ChiFun</div>
        
            <div>Road is walked by me</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>  
          
            <a href="/about/" class="Btn">
              <li>About</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
            
                <a target="_blank" rel="noopener" href="https://github.com/Magician-Snow">
                    <img src="/assets/github.svg" />
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2022/12/11/%E7%94%9F%E6%97%A5-%E4%B8%AA%E4%BA%BA%E6%8F%90%E5%8D%87%E8%AE%A1%E5%88%922023/">生日-个人提升计划2023</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2022-12-11T09:06:20.000Z" itemprop="datePublished">
    2022-12-11
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E6%9D%82%E8%AE%B0/">杂记</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h4 id="Personal-Development-Plan-2023"><a href="#Personal-Development-Plan-2023" class="headerlink" title="Personal Development Plan-2023"></a>Personal Development Plan-2023</h4><ol>
<li><p>少打农</p>
</li>
<li><p>恢复睡眠，提升卫生习惯</p>
</li>
<li><p>改掉话痨</p>
</li>
<li><p>使用“了”和“吧”优先级下调</p>
</li>
<li><p>约束日常消费</p>
</li>
<li><p>明年这时有能力帮助一些山区学生</p>
</li>
<li><p>牢记20大会议精神，始终坚持两个维护</p>
</li>
<li><p>不要和烂尾大帝学烂尾</p>
</li>
<li><p>下行承压，控制情绪</p>
</li>
</ol>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2022/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8405/">数据结构05</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2022-12-03T07:22:01.000Z" itemprop="datePublished">
    2022-12-03
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列(queue)"></a>队列(queue)</h2><h4 id="1-队列的概念"><a href="#1-队列的概念" class="headerlink" title="1. 队列的概念"></a>1. 队列的概念</h4><p>​    一种可以实现“先进先出”的存储结构，不能在中间插入，只能在一端入，另一端出，入的那端不能出，出的那端不能入</p>
<h4 id="2-队列的分类"><a href="#2-队列的分类" class="headerlink" title="2.队列的分类"></a>2.队列的分类</h4><ul>
<li><p>链式队列    –用链表实现</p>
</li>
<li><p>数组队列    –用动态数组实现、</p>
<p>​    使用数组来实现队列通常都必须是循环队列</p>
</li>
</ul>
<p>​    规定：在队首(front)删除元素，在队尾(rear)加入元素，定义两个变量：front指向队首的第一个元素，rear指向队尾元素的下一个元素</p>
<p>​    图示如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/z8QyZR"><img src="https://s1.ax1x.com/2022/11/23/z8QyZR.png" alt="z8QyZR.png"></a></p>
<p>​    注意：错开设置是为了方便对队列进行操作，就像链表pHead指向第一个元素的前一个不存储数据的头结点，pTail指向最后一个结点一样</p>
<h4 id="3-循环队列"><a href="#3-循环队列" class="headerlink" title="3. 循环队列"></a>3. 循环队列</h4><p><strong>(1). 使用数组来实现队列为什么必须为循环队列</strong></p>
<p>​     当插入元素或者删除元素时，front和rear都是向后移动，此时前面的数组空间都无法使用即被浪费了，所以需要使用循环队列来减少空间浪费</p>
<p>​    当front或rear指向最后一个元素，且还要再往后移时，此时需要将其指向第一个元素，这样的设计就是一个循环队列</p>
<p><strong>(2).循环队列需要几个参数来确定，以及参数的含义</strong></p>
<p>​    需要两个参数来确定：front、rear</p>
<p>​    这两个参数不同场合有不同的含义</p>
<ol>
<li><p>队列初始化</p>
<p>front和rear的值都是0</p>
</li>
<li><p>队列非空</p>
<p>front代表队列的第一个元素</p>
<p>rear代表队列的最后一个有效元素的下一个元素</p>
</li>
<li><p>队列空</p>
<p>front和rear的值相等，但不一定就是为0</p>
</li>
</ol>
<p><strong>(3).循环队列入队的伪算法</strong></p>
<ol>
<li><p>将值存入rear所指向的位置</p>
</li>
<li><p>rear = (rear + 1)%数组的长度</p>
</li>
</ol>
<p><strong>(4).循环队列出队的伪算法</strong></p>
<p>​    front = (front + 1)%数组长度</p>
<p><strong>(5).循环队列判断队列为空的伪算法</strong></p>
<p>​    如果front与rear的值相等，则该队列就一定为空</p>
<p><strong>(6).循环队列判断队列为满的伪算法</strong></p>
<p>​    <strong>两种方法：</strong></p>
<p>​    1. 设定一个len变量来记录数组中有效数据的长度，当达到数组长度时，则拒绝继续添加</p>
<p>​    <strong>2. 设定：数组中有n个元素，若已经放了n-1个元素，那么数组就已经满了(一般使用第二种方法)</strong></p>
<p>​    <strong>第二种方法的判断条件</strong></p>
<p>​    如果<code>front == (rear + 1)%数组长度</code>，则队列已满</p>
<h4 id="4-算法"><a href="#4-算法" class="headerlink" title="4. 算法"></a>4. 算法</h4><ol>
<li><p>队列的定义以及初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体定义队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *pBase;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125;QUEUE,*PQUEUE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PQUEUE pQ)</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PQUEUE pQ)</span></span>&#123;  <span class="comment">//函数体</span></span><br><span class="line">    pQ-&gt;pBase = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">6</span>);</span><br><span class="line">    pQ-&gt;front = <span class="number">0</span>;</span><br><span class="line">    pQ-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>队满的判断，以及队列的入队操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为满</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">full_queue</span><span class="params">(PQUEUE pQ)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">full_queue</span><span class="params">(PQUEUE pQ)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pQ-&gt;front == ((pQ-&gt;rear+<span class="number">1</span>)%<span class="number">6</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队操作</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">en_queue</span><span class="params">(PQUEUE pQ,<span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">en_queue</span><span class="params">(PQUEUE pQ,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(full_queue(pQ))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pQ-&gt;pBase[pQ-&gt;rear] = val;</span><br><span class="line">    pQ-&gt;rear = (pQ-&gt;rear+<span class="number">1</span>)%<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>队列的遍历操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse_queue</span><span class="params">(PQUEUE pQ)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse_queue</span><span class="params">(PQUEUE pQ)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = pQ-&gt;front;</span><br><span class="line">    <span class="keyword">while</span>(i!=pQ-&gt;rear)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,pQ-&gt;pBase[i]);</span><br><span class="line">        i = (i+<span class="number">1</span>)%<span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>队列判断为空以及出队操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty_queue</span><span class="params">(PQUEUE pQ)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty_queue</span><span class="params">(PQUEUE pQ)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pQ-&gt;front==pQ-&gt;rear)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">out_queue</span><span class="params">(PQUEUE pQ,<span class="keyword">int</span> * val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">out_queue</span><span class="params">(PQUEUE pQ,<span class="keyword">int</span> * val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(empty_queue(pQ))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *val = pQ-&gt;pBase[pQ-&gt;front];</span><br><span class="line">    pQ-&gt;front = (pQ-&gt;front+<span class="number">1</span>)%<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>mian函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QUEUE Q;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    init(&amp;Q);</span><br><span class="line">    <span class="keyword">if</span>(en_queue(&amp;Q,<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;true\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">    en_queue(&amp;Q,<span class="number">2</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">3</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">4</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">5</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">6</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">7</span>);</span><br><span class="line">    traverse_queue(&amp;Q);</span><br><span class="line">    <span class="keyword">if</span>(out_queue(&amp;Q,&amp;num))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nok,the num is %d&quot;</span>,num);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    traverse_queue(&amp;Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="5-队列的具体应用"><a href="#5-队列的具体应用" class="headerlink" title="5. 队列的具体应用"></a>5. 队列的具体应用</h4><p>​    所有和时间有关的操作都有队列的影子</p>
<p>​    比如：像操作系统里有等待队列，线程有阻塞队列</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2022/11/21/MySQL%E5%A4%8D%E4%B9%A003/">MySQL复习03</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2022-11-21T00:46:50.000Z" itemprop="datePublished">
    2022-11-21
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/MySQL/">MySQL</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h4 id="1-多表关系"><a href="#1-多表关系" class="headerlink" title="1. 多表关系"></a>1. 多表关系</h4><p>​    在数据库表结构设计时，一般各个表结构之间存在着各种联系，基本上分为三种：</p>
<ul>
<li>一对多(多对一)</li>
<li>多对多</li>
<li>一对一</li>
</ul>
<p>​    <strong>一对多(多对一)</strong></p>
<p>​    案例：部门与员工的关系</p>
<p>​    关系：一个部门对应多个员工，一个员工对应一个部门</p>
<p>​    实现：在多的一方建立外键。指向一的一方的主键</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/zVAki4"><img src="https://s1.ax1x.com/2022/11/15/zVAki4.png" alt="zVAki4.png"></a></p>
<p>​    <strong>多对多</strong></p>
<p>​    案例：学生与课程的关系</p>
<p>​    关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择</p>
<p>​    实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/zVAEW9"><img src="https://s1.ax1x.com/2022/11/15/zVAEW9.png" alt="zVAEW9.png"></a></p>
<p>​    <strong>一对一</strong></p>
<p>​    案例：用户与用户详情的关系</p>
<p>​    关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详细字段放在另一张表中，以提升操作效率</p>
<p>​    实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/zVEvD0"><img src="https://s1.ax1x.com/2022/11/15/zVEvD0.png" alt="zVEvD0.png"></a></p>
<h4 id="2-多表查询概述"><a href="#2-多表查询概述" class="headerlink" title="2. 多表查询概述"></a>2. 多表查询概述</h4><p>​    指从多张表中查询数据</p>
<pre><code> 笛卡尔积</code></pre>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp,dept;</span><br></pre></td></tr></table></figure>

<p>​    笛卡尔积：两个集合，A集合和B集合的所有组合情况(在多表查询时，需要消除无效的笛卡尔积)</p>
<p>​    通过where语句可以消除无效的笛卡尔积，但不满足where的数据也会被消除掉</p>
<p>​    多表查询的分类</p>
<ul>
<li>连接查询<ul>
<li>内连接：相当于查询A、B交集部分数据</li>
<li>外连接：<ul>
<li>左外连接：查询左表所有数据，以及两张表交集部分数据</li>
<li>右外连接：查询右表所有数据，以及两张表交集部分数据</li>
</ul>
</li>
<li>自连接：当前表与自身的连接查询，自连接必须使用表别名</li>
</ul>
</li>
<li>子查询</li>
</ul>
<h4 id="3-内连接"><a href="#3-内连接" class="headerlink" title="3. 内连接"></a>3. 内连接</h4><p>​    内连接查询的是两张表的交集部分</p>
<p>​    内连接查询语法</p>
<ul>
<li><p>隐式内连接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>,表<span class="number">2</span> <span class="keyword">WHERE</span> 条件...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示内连接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> [<span class="keyword">INNER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件... <span class="keyword">WHERE</span> 筛选条件;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<p>​    范例：内连接的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表结构：emp,dept</span></span><br><span class="line"><span class="comment">-- 连接条件：emp.dept_id = dept.id</span></span><br><span class="line"><span class="comment">-- 查询每一个员工的姓名，以及关联的部门的名称(隐式内连接实现)</span></span><br><span class="line"><span class="keyword">SELECT</span> emp.name,dept.name <span class="keyword">FROM</span> emp,dept <span class="keyword">WHERE</span> emp.dept_id = dept_id;</span><br><span class="line">//如果表名太长可以起别名，但起别名之后WHERE后面的使用字段必须要用别名来引用，不可以用表原名引用</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询每一个员工的姓名。及关联的部门的名称(显示内连接实现)</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name, d.name <span class="keyword">FROM</span> emp e <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept d <span class="keyword">on</span> e.dept_id = d.id;</span><br><span class="line">//INNER关键字是可以省略的</span><br></pre></td></tr></table></figure>

<p>​    注意：隐式和显式只是语法不同，查询结果是相同的</p>
<h4 id="4-外连接"><a href="#4-外连接" class="headerlink" title="4. 外连接"></a>4. 外连接</h4><p>​    外连接查询语法</p>
<ul>
<li><p>左外连接：查询左表(表1)所有数据，以及两张表交集部分数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>右外连接：查询右表(表2)所有数据，以及两张表交集部分数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件...;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>​    范例：外连接的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表结构：emp,dept</span></span><br><span class="line"><span class="comment">-- 连接条件：emp.dept_id = dept.id</span></span><br><span class="line"><span class="comment">-- 1.查询emp表的所有数据，和对应的部门信息(左外连接)</span></span><br><span class="line"><span class="keyword">SELECT</span> e.*,d.name <span class="keyword">FROM</span> emp e <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> dept d <span class="keyword">ON</span> e.dept_id = d.id;</span><br><span class="line">//OUTER关键字可以省略</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.查询dept表的所有数据，和对应的员工信息(右外连接)</span></span><br><span class="line"><span class="keyword">SELECT</span> d.*,e.name <span class="keyword">FROM</span> emp e <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> dept d <span class="keyword">ON</span> e.dept_id = d.id;</span><br></pre></td></tr></table></figure>

<p>​    注意：一般开发中左外连接用的多，因为右外连接可以转化为左外连接</p>
<h4 id="4-自连接"><a href="#4-自连接" class="headerlink" title="4. 自连接"></a>4. 自连接</h4><p>​    自连接查询语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A 别名A <span class="keyword">JOIN</span> 表A 别名B <span class="keyword">ON</span> 条件...;</span><br></pre></td></tr></table></figure>

<p>​    自连接可以是内连接也可以是外连接</p>
<p>​    范例：自连接的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表结构：emp</span></span><br><span class="line"><span class="comment">-- 1.查询员工及其所属领导的名字</span></span><br><span class="line"><span class="keyword">SELECT</span> a.name,b.name <span class="keyword">FROM</span> emp a, emp b <span class="keyword">WHERE</span> a.managerid = b.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.查询所有员工及其领导的名字，如果员工没有领导，也需要查询出来</span></span><br><span class="line"><span class="keyword">SELECT</span> a.name <span class="string">&#x27;员工&#x27;</span>, b.name <span class="string">&#x27;领导&#x27;</span> <span class="keyword">FROM</span> emp a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> emp b <span class="keyword">ON</span> a.managerid = b.id;</span><br></pre></td></tr></table></figure>



<h4 id="5-联合查询"><a href="#5-联合查询" class="headerlink" title="5. 联合查询"></a>5. 联合查询</h4><p>​    联合查询是将多次查询的结果合并起来，形成一个新的查询结果集</p>
<p>​    联合查询的语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A...</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表B...;</span><br></pre></td></tr></table></figure>

<p>​    对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致</p>
<p>​    范例：联合查询的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.将薪资低于5000的员工和年龄大于50岁的员工全部查询出来</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> salary &lt; <span class="number">5000</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age &lt; <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<p>​    联合查询将这两次查询的结果合并在一起显示</p>
<p>​    <strong>注意：<code>UNION ALL</code>会将查到的全部数据直接合并在一起，<code>UNION</code>会对合并之后的数据去重</strong></p>
<h4 id="6-子查询概念"><a href="#6-子查询概念" class="headerlink" title="6. 子查询概念"></a>6. 子查询概念</h4><p>​    SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询</p>
<p>​    子查询的语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> <span class="keyword">column</span> = (<span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> t2);</span><br></pre></td></tr></table></figure>

<p>​    注意：子查询外部的语句可以是INSERT、UPDATE、DELETE、SELECT的任意一个</p>
<p>​    根据子查询结果的不同，将子查询分类为：</p>
<ul>
<li>标量子查询(子查询结果为单个值)</li>
<li>列子查询(子查询结果为一列)</li>
<li>行子查询(子查询结果为一行)</li>
<li>表子查询(子查询结果为多行多列)</li>
</ul>
<p>​    根据子查询的位置，将子查询分类为：</p>
<ul>
<li>WHERE之后</li>
<li>FROM之后</li>
<li>SELECT之后</li>
</ul>
<h4 id="7-标量子查询"><a href="#7-标量子查询" class="headerlink" title="7. 标量子查询"></a>7. 标量子查询</h4><p>​    子查询返回的结果是单个值(数字、字符串、日期等)，最简单的形式，这种子查询称为标量子查询</p>
<p>​    常见的操作符：<code>=</code>、<code>&lt;&gt;</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code></p>
<p>​    范例：标量子查询的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.查询“销售部”的所有员工信息</span></span><br><span class="line"><span class="comment">-- a.查询“销售部”部门ID</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">&#x27;销售部&#x27;</span>;</span><br><span class="line"><span class="comment">-- b.根据销售部部门ID，查询员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id = <span class="number">2</span>;</span><br><span class="line"><span class="comment">--通过子查询将a与b写为一条语句</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id = (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">&#x27;销售部&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="8-列子查询"><a href="#8-列子查询" class="headerlink" title="8. 列子查询"></a>8. 列子查询</h4><p>​    子查询返回的结果是一列(即多行)，这种子查询称为列子查询</p>
<p>​    常用操作符：IN、NOT IN、ANY、SOME、ALL</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IN</td>
<td align="center">在指定的集合范围之内，多选一</td>
</tr>
<tr>
<td align="center">NOT IN</td>
<td align="center">不在指定的集合范围之内</td>
</tr>
<tr>
<td align="center">ANY</td>
<td align="center">子查询返回列表中，有任意一个满足即可</td>
</tr>
<tr>
<td align="center">SOME</td>
<td align="center">与ANY等同，使用SOME的地方都可以使用ANY</td>
</tr>
<tr>
<td align="center">ALL</td>
<td align="center">子查询返回列表的所有值都必须满足</td>
</tr>
</tbody></table>
<p>​    范例：列子查询的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.查询“销售部”和“市场部”的所有员工信息</span></span><br><span class="line"><span class="comment">-- a.查询“销售部”和“市场部”的部门ID</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&#x27;销售部&#x27;</span> <span class="keyword">or</span> <span class="keyword">name</span> = <span class="string">&#x27;市场部&#x27;</span>;</span><br><span class="line"><span class="comment">-- b.根据部门ID查询员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id <span class="keyword">IN</span>(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">-- 将a,b写为一条语句</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id <span class="keyword">IN</span>(<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&#x27;销售部&#x27;</span> <span class="keyword">or</span> <span class="keyword">name</span> = <span class="string">&#x27;市场部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.查询比财务部所有人工资都高的员工信息</span></span><br><span class="line"><span class="comment">-- a.查询财务部所有人员的工资</span></span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id = (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> <span class="keyword">name</span> =<span class="string">&#x27;财务部&#x27;</span>);</span><br><span class="line"><span class="comment">-- b.比财务部所有人工资都高的员工信息,与a结合</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> salary &gt; <span class="keyword">ALL</span>(<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id = (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> <span class="keyword">name</span> =<span class="string">&#x27;财务部&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.查询比研发部任意一个人工资高的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> salary &gt; <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id = (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> <span class="keyword">name</span> =<span class="string">&#x27;研发部&#x27;</span>));</span><br></pre></td></tr></table></figure>



<h4 id="9-行子查询"><a href="#9-行子查询" class="headerlink" title="9. 行子查询"></a>9. 行子查询</h4><p>​    子查询返回的结果是一行(即多列)，这种子查询称为行子查询</p>
<p>​    常用的操作符：=、&lt;&gt;、IN、NOT IN</p>
<p>​    范例：行子查询的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.查询与“张三”的薪资及直属领导相同的员工信息</span></span><br><span class="line"><span class="comment">-- a.张无忌的薪资及直属领导</span></span><br><span class="line"><span class="keyword">SELECT</span> salary,managerid <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">&#x27;张无忌&#x27;</span>;</span><br><span class="line"><span class="comment">-- b.查询与“张无忌”的薪资及直属领导相同的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> (salary,managerid) = (<span class="number">1000</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">-- 将a,b写为一条语句</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> (salary,managerid) = (<span class="keyword">SELECT</span> salary,managerid <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">&#x27;张无忌&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="10-表子查询"><a href="#10-表子查询" class="headerlink" title="10. 表子查询"></a>10. 表子查询</h4><p>​    子查询返回的结果是多行多列，这种子查询称为表子查询，一般放在FROM之后，把查询结果作为一张临时表在和其他表联合查询，也会放在WHERE后面使用IN来完成查找</p>
<p>​    常用操作符：IN</p>
<p>​    范例：表子查询的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.查询与“张三”，“李四”的职位和薪资相同的员工信息</span></span><br><span class="line"><span class="comment">-- a.查询“张三”，“李四”的职位和薪资</span></span><br><span class="line"><span class="keyword">SELECT</span> job,salary <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">&#x27;张三&#x27;</span> <span class="keyword">or</span> <span class="keyword">name</span> = <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="comment">-- b.查询与“张三”，“李四”的职位和薪资相同的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> (job,salary) <span class="keyword">IN</span> (<span class="keyword">SELECT</span> job,salary <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">&#x27;张三&#x27;</span> <span class="keyword">or</span> <span class="keyword">name</span> = <span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.查询入职日期是“2006-01-01”之后的员工信息，及其部门信息</span></span><br><span class="line"><span class="comment">-- a.入职日期是“2006-01-01”之后的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> entrydate&gt;<span class="string">&#x27;2006-01-01&#x27;</span>;</span><br><span class="line"><span class="comment">-- b.查询这部分员工对应的部门信息，因为如果部门为空也要查询出来，所以要用到左外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> e.*,d.* <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> entrydate&gt;<span class="string">&#x27;2006-01-01&#x27;</span>) e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept d <span class="keyword">ON</span> e.dept_id=d.id;</span><br></pre></td></tr></table></figure>


      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2022/11/21/MySQL%E5%A4%8D%E4%B9%A002/">MySQL复习02</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2022-11-21T00:45:24.000Z" itemprop="datePublished">
    2022-11-21
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/MySQL/">MySQL</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="函数与约束"><a href="#函数与约束" class="headerlink" title="函数与约束"></a>函数与约束</h2><h4 id="1-字符串函数"><a href="#1-字符串函数" class="headerlink" title="1. 字符串函数"></a>1. 字符串函数</h4><p>​    MySQL中内置了很多字符串函数，常见的如下表：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">concat(S1,S2,…,Sn)</td>
<td align="center">字符串拼接，将(S1,S2,…,Sn)拼接为一个字符串</td>
</tr>
<tr>
<td align="center">lower(str)</td>
<td align="center">将字符串str全部转为小写</td>
</tr>
<tr>
<td align="center">upper(str)</td>
<td align="center">将字符串str全部转为大写</td>
</tr>
<tr>
<td align="center">lpad(str,n,pad)</td>
<td align="center">左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td align="center">rpad(str,n,pad)</td>
<td align="center">右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td align="center">trim(str)</td>
<td align="center">去掉字符串头部和尾部空格</td>
</tr>
<tr>
<td align="center">substring(str,start,len)</td>
<td align="center">返回从字符串str从start位置起的len长度的字符串，<strong>索引值是从1开始</strong></td>
</tr>
</tbody></table>
<p>​    <strong>注意：str可以传类型是字符串的列名</strong></p>
<p>​    范例：字符串函数的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- concat</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">concat</span>(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--lower</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">lower</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--upper</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">upper</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--lpad</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">lpad</span>(<span class="string">&#x27;01&#x27;</span>,<span class="number">5</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--rpad</span></span><br><span class="line"><span class="keyword">SELECT</span> rpad(<span class="string">&#x27;01&#x27;</span>,<span class="number">5</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--trim</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">trim</span>(<span class="string">&#x27; hello world &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--substring</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">substring</span>(<span class="string">&#x27;12345&#x27;</span>,<span class="number">1</span>,<span class="number">3</span>); //索引值从1开始</span><br></pre></td></tr></table></figure>



<h4 id="2-数值函数"><a href="#2-数值函数" class="headerlink" title="2. 数值函数"></a>2. 数值函数</h4><p>​    常见的数值函数如下表：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ceil(x)</td>
<td align="center">向上取整</td>
</tr>
<tr>
<td align="center">floor(x)</td>
<td align="center">向下取整</td>
</tr>
<tr>
<td align="center">mod(x,y)</td>
<td align="center">返回x/y的模</td>
</tr>
<tr>
<td align="center">rand()</td>
<td align="center">返回0~1内的随机数</td>
</tr>
<tr>
<td align="center">round(x,y)</td>
<td align="center">得参数x的整体进行四舍五入的值，保留y位小数</td>
</tr>
</tbody></table>
<p>​    范例：数值函数的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ceil</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ceil</span>(<span class="number">1.1</span>);  //结果2</span><br><span class="line"></span><br><span class="line"><span class="comment">-- floor</span></span><br><span class="line">SELSECT floor(1.1) //结果1</span><br><span class="line"></span><br><span class="line"><span class="comment">-- mod</span></span><br><span class="line">SELSET mod(3,4);  //3除4的余数，结果3</span><br><span class="line"></span><br><span class="line"><span class="comment">--rand</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">rand</span>(); //0~1随机数</span><br><span class="line"></span><br><span class="line"><span class="comment">--round</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">round</span>(<span class="number">2.345</span>,<span class="number">2</span>); //结果2.35</span><br></pre></td></tr></table></figure>

<p>​    注意：生成的数字可以作为字符串参与上面字符串函数中</p>
<h4 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3. 日期函数"></a>3. 日期函数</h4><p>​    常见日期函数如下：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">curdate()</td>
<td align="center">返回当前日期</td>
</tr>
<tr>
<td align="center">curtime()</td>
<td align="center">返回当前时间</td>
</tr>
<tr>
<td align="center">now()</td>
<td align="center">返回当前日期和时间，<strong>即返回的是date类型</strong></td>
</tr>
<tr>
<td align="center">year(date)</td>
<td align="center">获取指定date的年份</td>
</tr>
<tr>
<td align="center">month(date)</td>
<td align="center">获取指定date的月份</td>
</tr>
<tr>
<td align="center">day(date)</td>
<td align="center">获取指定date的日期</td>
</tr>
<tr>
<td align="center">date_add(date,interval expr type)</td>
<td align="center">在指定日期下增加一个时间间隔，返回该时间值</td>
</tr>
<tr>
<td align="center">datediff(date1,date2)</td>
<td align="center">返回起始时间date1和结束时间date2之间的天数，结果为date1-date2</td>
</tr>
</tbody></table>
<p>​    范例：日期函数的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- curdate</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">curdate</span>();  //结果2022-11-14</span><br><span class="line"></span><br><span class="line"><span class="comment">-- curtime</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">curtime</span>();  //结果9:29:15</span><br><span class="line"></span><br><span class="line"><span class="comment">-- now</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">now</span>();  //结果2022-11-14 9:29:54</span><br><span class="line"></span><br><span class="line"><span class="comment">-- year</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>(<span class="keyword">now</span>()); //结果2022</span><br><span class="line"></span><br><span class="line"><span class="comment">-- month</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">month</span>(<span class="keyword">now</span>());  //结果11</span><br><span class="line"></span><br><span class="line"><span class="comment">-- day</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">day</span>(<span class="keyword">now</span>());  //结果14</span><br><span class="line"></span><br><span class="line"><span class="comment">--date_add</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">date_add</span>(<span class="keyword">now</span>(),<span class="built_in">INTERVAL</span> <span class="number">10</span> <span class="keyword">DAY</span>);  //结果2022-11-24 10:05:31</span><br><span class="line"></span><br><span class="line"><span class="comment">-- datediff</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">datediff</span>(<span class="string">&#x27;2022-12-01&#x27;</span>,<span class="string">&#x27;2022-11-1&#x27;</span>); 结果30，注意如果前小后大则值为负数</span><br></pre></td></tr></table></figure>



<h4 id="4-流程函数"><a href="#4-流程函数" class="headerlink" title="4. 流程函数"></a>4. 流程函数</h4><p>​    流程函数在SQL语句中实现条件筛选，从而提高语句的效率</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">if(value,t,f)</td>
<td align="center">如果value为true，则返回true否则返回f</td>
</tr>
<tr>
<td align="center">ifnull(value1,value2)</td>
<td align="center">判定第一个参数是否为空，即如果value1不为空，返回value1，否则返回value2</td>
</tr>
<tr>
<td align="center">case [表中字段] when [val] then [res1]…else [default] end</td>
<td align="center">如果val1与表中数据判断为true返回res1,…(可以写多个判断的)否则返回default默认值</td>
</tr>
<tr>
<td align="center">case when [表中字段]比较运算 then [res1]…else [default] end</td>
<td align="center">如果不是具体的而是范围，使用该语法</td>
</tr>
</tbody></table>
<p>​    范例：流程控制函数的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- if</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">if</span>(<span class="literal">true</span>,<span class="string">&#x27;ok&#x27;</span>,<span class="string">&#x27;error&#x27;</span>);  //结果ok</span><br><span class="line"></span><br><span class="line"><span class="comment">--ifnull</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ifnull</span>(<span class="literal">null</span>,<span class="string">&#x27;error&#x27;</span>);  //结果error</span><br><span class="line"></span><br><span class="line"><span class="comment">-- case when then else end</span></span><br><span class="line"><span class="comment">-- 需求：查询员工表emp中员工姓名和工作地址(北京/上海---&gt;一线城市，其他---&gt;二线城市)</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="keyword">name</span>,</span><br><span class="line">	(<span class="keyword">case</span> workaddress <span class="keyword">when</span> <span class="string">&#x27;北京&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;一线城市&#x27;</span> <span class="keyword">when</span> <span class="string">&#x27;上海&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;一线城市&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;二线城市&#x27;</span> <span class="keyword">end</span>) <span class="keyword">AS</span> <span class="string">&#x27;工作地址&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure>



<h4 id="5-约束"><a href="#5-约束" class="headerlink" title="5. 约束"></a>5. 约束</h4><p>​    约束是作用于表中字段上的规则，用于限制存储在表中的数据</p>
<p>​    约束的目的是保证数据库中数据的正确、有效性和完整性</p>
<p>​    约束的分类</p>
<table>
<thead>
<tr>
<th align="center">约束</th>
<th align="center">描述</th>
<th align="center">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="center">非空约束</td>
<td align="center">限制该字段的数据不能为null</td>
<td align="center">NOT NULL</td>
</tr>
<tr>
<td align="center">唯一约束</td>
<td align="center">保证该字段的所有数据都是唯一、不重复的</td>
<td align="center">UNIQUE</td>
</tr>
<tr>
<td align="center">主键约束</td>
<td align="center">主键是一行数据的唯一标识，要求非空且唯一</td>
<td align="center">PRIMARY KEY</td>
</tr>
<tr>
<td align="center">默认约束</td>
<td align="center">保存数据时，如果未指定该字段的值，则采用默认值</td>
<td align="center">DEFAULT</td>
</tr>
<tr>
<td align="center">检查约束</td>
<td align="center">保证字段值满足某一条件</td>
<td align="center">CHECK</td>
</tr>
<tr>
<td align="center">外键约束</td>
<td align="center">用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td>
<td align="center">FOREIGN KEY</td>
</tr>
</tbody></table>
<p>​    注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束</p>
<p>​    范例：约束的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>;</span><br><span class="line">	name VARCHAR(20) NOT NULL UNIQUE;</span><br><span class="line">	age INT <span class="keyword">CHECK</span>(age&gt;<span class="number">0</span> &amp;&amp; age&lt;=<span class="number">120</span>);</span><br><span class="line">	statues CHAR(1) DEFAULT &#x27;1&#x27;;</span><br><span class="line">)<span class="keyword">COMMENT</span> <span class="string">&#x27;用户表&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="6-外键约束"><a href="#6-外键约束" class="headerlink" title="6.外键约束"></a>6.外键约束</h4><p>​    概念：用来让两张表的数据之间建立连接，保证数据的一致性和完整性</p>
<p>​    一般把设立外键的表叫做子表，而让该外键为主键的表叫主表</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/zEiZ1x"><img src="https://s1.ax1x.com/2022/11/15/zEiZ1x.png" alt="zEiZ1x.png"></a></p>
<p>​    设置外键后，当要删除主表的数据时，要判定该数据在子表中是否存在关联关系，如果存在则拒绝删除操作</p>
<p>​    外键约束的语法：</p>
<ul>
<li><p>添加外键</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//建表时直接创建</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">	字段名 数据类型</span><br><span class="line">	...</span><br><span class="line">	[<span class="keyword">CONSTRAINT</span>] [外键名称] <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(外键字段名) REFRENCES 主表(主表列名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//表建立后修改外键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(外键字段名) <span class="keyword">REFERENCES</span> 主表名(主表列名);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除外键</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> 外键名称;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>​    范例：外键的操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//增加外键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_emp_dept_id <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (dept_id) <span class="keyword">REFERENCES</span> dept(<span class="keyword">id</span>);</span><br><span class="line"></span><br><span class="line">//删除外键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> fk_emp_dept_id;</span><br></pre></td></tr></table></figure>



<p>​    外键约束：删除和更新行为</p>
<table>
<thead>
<tr>
<th align="center">行为</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NO ACTION</td>
<td align="center">当主表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新，<strong>外键约束的默认行为</strong></td>
</tr>
<tr>
<td align="center">RESTRICT</td>
<td align="center">与NO ACTION一致</td>
</tr>
<tr>
<td align="center">CASCADE(级联)</td>
<td align="center">当在主表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在从表中的记录</td>
</tr>
<tr>
<td align="center">SET NULL</td>
<td align="center">当在主表中删除对应记录时，首先检查该记录是否对应外键，如果有则设置从表中该外键值为null(此时需要设计时外键允许取null)</td>
</tr>
<tr>
<td align="center">SET DEFAULT</td>
<td align="center">主表有变更时，子表将外键列设置成一个默认的值(Innodb不支持)</td>
</tr>
</tbody></table>
<p>​    语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(外键字段名) <span class="keyword">REFERENCES</span> 主表名(主表列名) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br></pre></td></tr></table></figure>

<p>​    <code>ON UPDATE</code>：表示更新时怎么操作</p>
<p>​    <code>ON DELETE</code>：表示删除时怎么操作</p>
<p>​    前面一段与外键设置时语法相同</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2022/11/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8404/">数据结构04</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2022-11-21T00:41:29.000Z" itemprop="datePublished">
    2022-11-21
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h4 id="1-栈的定义"><a href="#1-栈的定义" class="headerlink" title="1. 栈的定义"></a>1. 栈的定义</h4><p>​    一种可以实现“先进后出”的存储结构<br>​    栈类似于箱子</p>
<h4 id="2-栈的分类"><a href="#2-栈的分类" class="headerlink" title="2. 栈的分类"></a>2. 栈的分类</h4><p>​    栈可以分为静态栈和动态栈</p>
<p>​    静态栈：通过数组实现</p>
<p>​    动态栈：通过链表实现</p>
<p>​    动态栈使用的更多</p>
<h4 id="3-栈可以实现的操作"><a href="#3-栈可以实现的操作" class="headerlink" title="3. 栈可以实现的操作"></a>3. 栈可以实现的操作</h4><p>​    1. 入栈(压栈)</p>
<p>​    2. 出栈</p>
<h4 id="4-动态栈的伪算法"><a href="#4-动态栈的伪算法" class="headerlink" title="4. 动态栈的伪算法"></a>4. 动态栈的伪算法</h4><ol>
<li><p>动态栈的实现</p>
<p>动态栈通过链表来实现，栈中的每一个元素通过一个结点来表示，要实现栈还需要声明一个栈顶和栈底，初始化栈时，会将栈顶和栈底指向同一个空的头结点，要向栈存入数据，则先新生成一个结点，再**将该新结点的指针域指向栈顶指向的结点(考虑到出栈时要删除，所以新指向旧)**，最后将栈顶移动到新结点上</p>
</li>
</ol>
<ol start="2">
<li>注意：动态栈属于链表栈，不存在满的问题</li>
</ol>
<ol start="3">
<li><p>压栈操作图示</p>
<p><img src="https://s1.ax1x.com/2022/11/10/z9SQFe.png" alt="z9SQFe.png"></p>
</li>
</ol>
<ol start="4">
<li><p>栈的遍历</p>
<p>栈的遍历由于栈是先进后出，所以需要通过栈顶确定指针p，通过指针p来自上向下进行操作，只要p指向的元素不是栈底，则可以对栈一直输出</p>
</li>
</ol>
<ol start="5">
<li><p>判断栈是否为空</p>
<p>当栈顶和栈底相等，则栈为空</p>
</li>
</ol>
<ol start="6">
<li><p>出栈</p>
<p>当栈中元素为空时，则出栈失败；不为空则将一指针p指向栈顶指向的元素，栈顶元素指向该元素的下一个元素，此时释放掉p指针指向的结点就行</p>
</li>
</ol>
<ol start="7">
<li><p>栈的清空</p>
<p>将栈内有效元素全部清空，只保留框架，实现需要定义指针p和q，p指向栈顶元素，q为NULL，如果p没有指向栈底，则q指向p的下一个元素，当将p指向元素释放后p在移动到q上，只要p指向的不是栈底则一直循环执行该算法，循环结束后应将栈顶指向栈底</p>
</li>
</ol>
<h4 id="5-动态栈的算法"><a href="#5-动态栈的算法" class="headerlink" title="5. 动态栈的算法"></a>5. 动态栈的算法</h4><ol>
<li><p>算法-栈的定义、栈的初始化、压栈、遍历栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义栈中的每一个结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span></span><br><span class="line">&#125;NODE,*PNODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">    PNODE pTop;</span><br><span class="line">    PNODE pBottom;</span><br><span class="line">&#125;STACK,*PSTACK;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PSTACK pSt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(PSTACK pSt,<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STACK st;    <span class="comment">//定义栈</span></span><br><span class="line">    init(&amp;st);   <span class="comment">//栈的初始化</span></span><br><span class="line">    push(&amp;st,<span class="number">1</span>); <span class="comment">//压栈</span></span><br><span class="line">    push(&amp;st,<span class="number">2</span>);</span><br><span class="line">    write_stack(&amp;st); <span class="comment">//遍历栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PSTACK pSt)</span></span>&#123;</span><br><span class="line">    pSt-&gt;pTop = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pSt-&gt;pTop)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pSt-&gt;pBottom = pSt-&gt;pTop;</span><br><span class="line">    <span class="comment">//指针域置为空</span></span><br><span class="line">    pSt-&gt;pTop-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(PSTACK pSt,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    PNODE p = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    p-&gt;data = num;</span><br><span class="line">    p-&gt;pNext = pSt-&gt;pTop;</span><br><span class="line">    pSt-&gt;pTop =p;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_stack</span><span class="params">(PSTACK pSt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    PNODE p = pSt-&gt;pTop;</span><br><span class="line">    <span class="keyword">while</span>(pSt-&gt;pBottom!=p)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">        p=p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>算法-栈是否为空的判断、出栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt; //bool类型需要声明的头文件</span></span></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">(PSTACK pST)</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">(PSTACK pSt)</span></span>&#123;  <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">if</span>(pSt-&gt;pTop==pSt-&gt;pBottom)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈，并返回出栈的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(PSTACK pSt,<span class="keyword">int</span> * val)</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(PSTACK pSt,<span class="keyword">int</span> * val)</span></span>&#123;  <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">if</span>(empty(pSt))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PNODE p = pSt-&gt;pTop;</span><br><span class="line">    pSt-&gt;pTop = pSt-&gt;pTop-&gt;pNext;</span><br><span class="line">    *val = p-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法-栈的清空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(PSTACK pSt)</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(PSTACK pSt)</span></span>&#123;  <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">if</span>(empty(pSt))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PNODE p = pSt-&gt;pTop;</span><br><span class="line">    PNODE q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=pSt-&gt;pBottom)&#123;</span><br><span class="line">        q = p-&gt;pNext;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    pSt-&gt;pTop = pSt-&gt;pBottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h4 id="6-栈的应用"><a href="#6-栈的应用" class="headerlink" title="6. 栈的应用"></a>6. 栈的应用</h4><p>​    1. 函数调用<br>​    2. 中断<br>​    3. 表达式求值<br>​    4. 内存分配<br>​    5. 缓冲处理<br>​    6. 走迷宫</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2022/10/31/MySQL%E5%A4%8D%E4%B9%A001/">MySQL复习01</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2022-10-31T14:47:15.000Z" itemprop="datePublished">
    2022-10-31
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/MySQL/">MySQL</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h3 id="MySQL概述"><a href="#MySQL概述" class="headerlink" title="MySQL概述"></a>MySQL概述</h3><h4 id="1-数据库相关概念"><a href="#1-数据库相关概念" class="headerlink" title="1. 数据库相关概念"></a>1. 数据库相关概念</h4><ol>
<li>数据库(DB)：存储数据的仓库，数据是有组织的进行存储</li>
<li>数据库管理系统(DBMS)：操纵和管理数据库的大型软件，类似像MySQL就是</li>
<li><strong>SQL：操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准</strong></li>
</ol>
<h4 id="2-主流关系型数据库管理系统"><a href="#2-主流关系型数据库管理系统" class="headerlink" title="2. 主流关系型数据库管理系统"></a>2. 主流关系型数据库管理系统</h4><p>​    Oracle(收费、大型)、MySQL(免费、中小型)、SQLServer(收费、中型)</p>
<h4 id="3-关系型数据库"><a href="#3-关系型数据库" class="headerlink" title="3. 关系型数据库"></a>3. 关系型数据库</h4><p>​    建立在关系模型基础上，由多张相互连接的二维表组成的数据库</p>
<p>​    <strong>用表结构存储数据的叫关系型数据库</strong></p>
<p>特点：</p>
<p>​    1. 使用表存储数据，格式统一，便于维护<br>​    2. 使用SQL语言操作，标准统一，使用方便</p>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><h4 id="1-SQL简介"><a href="#1-SQL简介" class="headerlink" title="1. SQL简介"></a>1. SQL简介</h4><p><strong>SQL通用语法</strong></p>
<ol>
<li>SQL语句可以单行书写或多行书写，以分号结尾</li>
<li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写</li>
<li>注释：<ul>
<li>单行注释：<code>--</code>注释内容或<code>#</code>注释内容(MySQL特有)</li>
<li>多行注释：<code>/*</code>注释内容<code>*/</code></li>
</ul>
</li>
</ol>
<p>​    <strong>SQL分类</strong></p>
<table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">全称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DDL</td>
<td align="center">Data Definition Language</td>
<td align="center">数据定义语言，用来定义数据库对象(数据库，表，字段)</td>
</tr>
<tr>
<td align="center">DML</td>
<td align="center">Data Manipulation Language</td>
<td align="center">数据操作语言，用来对数据库表中的数据进行增删改</td>
</tr>
<tr>
<td align="center">DQL</td>
<td align="center">Data Query Language</td>
<td align="center">数据查询语言，用来查询数据库中表的记录</td>
</tr>
<tr>
<td align="center">DCL</td>
<td align="center">Data Control Language</td>
<td align="center">数据控制语言，用来创建数据库用户、控制数据库的访问权限</td>
</tr>
</tbody></table>
<h4 id="2-DDL"><a href="#2-DDL" class="headerlink" title="2. DDL"></a>2. DDL</h4><p>​    <strong>DDL-数据库操作(命令行)</strong></p>
<ol>
<li><p>查询所有数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> [<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>] 数据库名 [defailt <span class="keyword">charset</span> 字符集] [<span class="keyword">collate</span> 排序规则];</span><br></pre></td></tr></table></figure>

<p>注意：一般不推荐设置字符集为<code>utf8</code>，因为其只占三个字节，而有些特殊字符是占四个字节的，所以推荐使用utf8mb4，它是支持四个字节的</p>
</li>
<li><p>删除数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> [<span class="keyword">if</span> <span class="keyword">exists</span>] 数据库名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入/切换数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> 数据库名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询当前数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>();</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>​    <strong>DDL-表操作(命令行)</strong></p>
<ol>
<li><p>查询当前数据库所有表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//前提是要先进入到数据库</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询表结构(表的字段设置，类型等信息)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询指定表的建表语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表的创建</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">	字段<span class="number">1</span> 字段<span class="number">1</span>类型 [<span class="keyword">comment</span> <span class="string">&#x27;注释&#x27;</span>],</span><br><span class="line">	字段<span class="number">2</span> 字段<span class="number">2</span>类型 [<span class="keyword">comment</span> <span class="string">&#x27;注释&#x27;</span>],</span><br><span class="line">	...</span><br><span class="line">	字段n 字段n类型 [<span class="keyword">comment</span> <span class="string">&#x27;注释&#x27;</span>]</span><br><span class="line">) [<span class="keyword">comment</span> <span class="string">&#x27;表注释&#x27;</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>向表结构中添加字段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 字段名 类型(长度) [<span class="keyword">COMMENT</span> 注释] [约束]；</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表中某字段的数据类型</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">MODIFY</span> 字段名 新的数据类型(长度);</span><br></pre></td></tr></table></figure>
</li>
<li><p>同时修改字段名和字段类型</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">CHANGE</span> 旧字段名 新字段名 类型(长度)  [<span class="keyword">COMMENT</span> 注释] [约束];</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除字段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 字段名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">RENAME</span> <span class="keyword">TO</span> 新表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] 表名;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>​    <strong>DDL-数据类型</strong></p>
<p>​    MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型</p>
<p>​    <strong>数值类型</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SMALLINT</td>
<td align="center">2 bytes</td>
<td align="center">大整数值</td>
</tr>
<tr>
<td align="center">INT</td>
<td align="center">4 bytes</td>
<td align="center">大整数值</td>
</tr>
<tr>
<td align="center">FLOAT</td>
<td align="center">4 bytes</td>
<td align="center">单精度浮点数值</td>
</tr>
<tr>
<td align="center">DOUBLE</td>
<td align="center">8 bytes</td>
<td align="center">双精度浮点数值</td>
</tr>
<tr>
<td align="center">DECIMAL</td>
<td align="center">使用时需要指定精度(总长)和标度(小数尾数)</td>
<td align="center">小数值</td>
</tr>
</tbody></table>
<ol>
<li><p>可以设置类型是否为无符号</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">age INT UNSIGNED</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以指定设置的范围</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">score double(4,1) //长度为4，小数部分为1</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>​    <strong>字符串类型</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CHAR</td>
<td align="center">0~255 bytes</td>
<td align="center">定长字符串</td>
</tr>
<tr>
<td align="center">VARCHAR</td>
<td align="center">0~65535 bytes</td>
<td align="center">变长字符串</td>
</tr>
</tbody></table>
<p>​    定长与变长的区别：</p>
<ul>
<li>CHAR：存入数据不管多大占用的空间都是那么多，其性能上要好</li>
<li>VARCHAR：根据你存储的内容去计算需要占用的空间</li>
</ul>
<p>​    <strong>日期类型</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">范围</th>
<th align="center">格式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DATE</td>
<td align="center">1000-01-01至9999-12-31</td>
<td align="center">YYYY-MM-DD</td>
<td align="center">日期值</td>
</tr>
<tr>
<td align="center">TIME</td>
<td align="center">-838:59:59至838:59:59</td>
<td align="center">HH:MM:SS</td>
<td align="center">时间值</td>
</tr>
<tr>
<td align="center">DATETIME</td>
<td align="center">1000-01-01 00:00:00至9999-12-31 23:59:59</td>
<td align="center">YYYY-MM-DD HH:MM:SS</td>
<td align="center">混合日期和时间值</td>
</tr>
</tbody></table>
<h4 id="3-DML"><a href="#3-DML" class="headerlink" title="3. DML"></a>3. DML</h4><p>​    <strong>DML-增加数据</strong></p>
<ol>
<li><p>给指定字段添加数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(字段名<span class="number">1</span>,字段名<span class="number">2</span>,...) <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>给全部字段添加数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,...); //注意：值应当与字段一一对应</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>​    <strong>注意：插入字符串和日期型数据应当包含在引号中</strong>，如果要添加多条数据，数据之间用<code>,</code>分隔</p>
<p>​    <strong>DML-修改和删除数据</strong></p>
<ol>
<li><p>修改数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段名<span class="number">1</span>=值<span class="number">1</span>,字段名<span class="number">2</span>=值<span class="number">2</span>,...[<span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure>

<p>注意：如果没有写<code>WHERE</code>条件，则会修改整张表的所有数据，<code>SET</code>后面为一条记录的多个字段</p>
</li>
<li><p>删除数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure>

<p>注意：DELETE语句删除的是整条记录，而不是某一字段的值，且如果没有写<code>WHERE</code>条件，则会删除整张表的所有数据</p>
</li>
</ol>
<h4 id="4-DQL"><a href="#4-DQL" class="headerlink" title="4. DQL"></a>4. DQL</h4><p>​    在日常的项目中查询的频次要远高于增删改的频次</p>
<p>​    DQL语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//编写顺序</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	字段列表</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	表名列表</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	条件列表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	分组字段列表</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">	分组后条件列表</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	排序字段列表</span><br><span class="line"><span class="keyword">LIMIT</span></span><br><span class="line">	分页参数</span><br></pre></td></tr></table></figure>



<p>​    <strong>DQL-基本查询</strong></p>
<ol>
<li><p>查询字段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查询某些字段</span><br><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>,字段<span class="number">2</span>, ... <span class="keyword">FROM</span> 表名;</span><br><span class="line">//查询所有字段</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置别名</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>[<span class="keyword">AS</span> <span class="string">&#x27;别名1&#x27;</span>],字段<span class="number">2</span>[<span class="keyword">AS</span> <span class="string">&#x27;别名2&#x27;</span>] ... <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>

<p>注意：设置别名时，<code>AS</code>是可以省略的，<strong>设置别名后查询到的列会显示别名</strong></p>
<ol start="3">
<li>对查询到的结果去除重复记录</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段列表 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>​    <strong>DQL-条件查询</strong></p>
<ol>
<li><p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件列表</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>条件</li>
</ol>
<table>
<thead>
<tr>
<th align="center">比较运算符(单个条件比较)</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&gt;=、&gt; 、&lt;、&lt;=、=</td>
<td align="center">大于等于、大于、小于、小于等于、等于</td>
</tr>
<tr>
<td align="center">&lt;&gt;、!=</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">BETWEEN…AND</td>
<td align="center">在某个范围之内，between后面跟的是小值，and后面是大值</td>
</tr>
<tr>
<td align="center">IN(…)</td>
<td align="center">列表中满足某1项就可以查询到该条记录</td>
</tr>
<tr>
<td align="center">LIKE ‘占位符’</td>
<td align="center">模糊匹配(_匹配单个字符，%匹配任意个字符)</td>
</tr>
<tr>
<td align="center">IS (NOT) NULL</td>
<td align="center">某字段(不)为空</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">逻辑运算符(用于将多个条件组装起来)</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AND 或 &amp;&amp;</td>
<td align="center">并且(多个条件同时成立)</td>
</tr>
<tr>
<td align="center">OR 或 ||</td>
<td align="center">或者(多个条件任意一个成立)</td>
</tr>
<tr>
<td align="center">NOT 或 !</td>
<td align="center">非(不是)</td>
</tr>
</tbody></table>
</li>
</ol>
<p>​    <strong>DQL补充-聚合函数(在分组查询中使用)</strong></p>
<ol>
<li><p>聚合函数的概念：将一列数据作为一个整体进行纵向计算</p>
</li>
<li><p>常见聚合函数</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">count</td>
<td align="center">统计数量</td>
</tr>
<tr>
<td align="center">max</td>
<td align="center">最大值</td>
</tr>
<tr>
<td align="center">min</td>
<td align="center">最小值</td>
</tr>
<tr>
<td align="center">avg</td>
<td align="center">平均值</td>
</tr>
<tr>
<td align="center">sum</td>
<td align="center">求和</td>
</tr>
</tbody></table>
</li>
<li><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 聚合函数(字段列表) <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>

<p>注意：null值不参与所有聚合函数运算</p>
</li>
</ol>
<p>​    </p>
<p>​    <strong>DQL-分组查询</strong></p>
<ol>
<li><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件] <span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组字段名 [<span class="keyword">HAVING</span> 分组后过滤条件];</span><br></pre></td></tr></table></figure>
</li>
<li><p>WHERE和HAVING的区别</p>
<ul>
<li>执行时机不同：where是分组之前进行过滤，不满足where条件则不参与分组，而having是分组之后对结果进行过滤</li>
<li>判断条件不同：where不能对聚合函数进行判断，而having可以</li>
</ul>
<ol start="3">
<li><p>执行顺序：where&gt;聚合函数&gt;having</p>
</li>
<li><p>分组之后查询的字段一般为聚合函数和进行分组的字段，查询其他字段无任何意义</p>
</li>
</ol>
</li>
</ol>
<p>​    <strong>DQL-排序查询</strong></p>
<ol>
<li><p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span>, 字段<span class="number">2</span> 排序方式<span class="number">2</span> ...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>排序方式</p>
<ul>
<li>ASC：升序(默认值)</li>
<li>DESC：降序</li>
</ul>
</li>
<li><p>多字段排序时，第一个字段值相同时才会根据第二个字段排序</p>
</li>
</ol>
<p>​    <strong>DQL-分页查询</strong></p>
<ol>
<li><p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> 起始索引,查询记录数;</span><br></pre></td></tr></table></figure>
</li>
<li><p> 起始索引从0开始，起始索引 = (要查询页码-1) <code>*</code> 每页显示记录数</p>
</li>
<li><p> 分页查询在不同数据库中语法不一样，在MySQL中是LIMIT</p>
</li>
<li><p> 如果查询的是第一页数据，起始索引可以省略，直接简写为LIMIT 10</p>
</li>
</ol>
<h4 id="5-DCL-SQL开发人员对其操作比较少"><a href="#5-DCL-SQL开发人员对其操作比较少" class="headerlink" title="5. DCL(SQL开发人员对其操作比较少)"></a>5. DCL(SQL开发人员对其操作比较少)</h4><p>​    <strong>DCL-权限控制</strong></p>
<ol>
<li><p>查询用户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建用户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//主机名约束了用户可以访问的数据库，设置为%可以访问所有数据库</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>; </span><br></pre></td></tr></table></figure>
</li>
<li><p>修改用户密码</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除用户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>；</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>​    <strong>DCL-权限控制</strong></p>
<ol>
<li><p>查询权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>授予权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//如果是所有数据库以及所有表则写*.*,设置多个权限用,隔开</span><br><span class="line"><span class="keyword">GRANT</span> 授权列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>撤销权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">FROM</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2022/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/">数据结构03</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2022-10-31T05:59:43.000Z" itemprop="datePublished">
    2022-10-31
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h4 id="1-typedef"><a href="#1-typedef" class="headerlink" title="1. typedef"></a>1. typedef</h4><p>​    C语言允许为一个数据类型起一个新的别名，使用typedef关键字来进行定义</p>
<p>​    typedef 的用法一般为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  oldName  newName;</span><br></pre></td></tr></table></figure>

<p>​    注意：一般新名字全部字母大写</p>
<p>​    范例：为结构体起一个别名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> sid;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">&#125;ST,*PST;<span class="comment">//ST等价于struct Student, PST等价于struct Student *</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    ST st;</span><br><span class="line">    st.sid = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,st.sid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-链表-离散存储"><a href="#2-链表-离散存储" class="headerlink" title="2. 链表(离散存储)"></a>2. 链表(离散存储)</h4><p><strong>链表的定义：</strong></p>
<p>​    ​    1. n个结点离散分配，<br>​    ​    2. 彼此通过指针相连<br>​    ​    3. 每个结点只有一个前驱结点，每个结点只有一个后续结点<br>​    ​    4. 首结点没有前驱结点，尾结点没有后续结点</p>
<p><strong>专业术语：</strong></p>
<ul>
<li>首结点：第一个存了有效数据的结点</li>
<li>尾结点：最后一个存了有效数据的结点，尾结点的指针域为空</li>
<li>头结点：第一个有效结点(首结点)之前的结点，方便我们对链表算法进行操作，里面不包含有效数据和数组长度，但头结点的数据类型和首结点的数据类型一样</li>
<li>头指针：指向头结点的指针变量，存放了头结点的地址</li>
<li>尾指针：指向尾结点的指针变量</li>
</ul>
<p><strong>如果希望通过一个函数来对链表进行处理，至少需要接受链表的哪些参数：</strong></p>
<p>​    只需要一个参数：头指针</p>
<p>​    通过头指针可以推算出链表的其他所有信息</p>
<h4 id="3-链表结点数据类型的表示"><a href="#3-链表结点数据类型的表示" class="headerlink" title="3. 链表结点数据类型的表示"></a>3. 链表结点数据类型的表示</h4><p>​    一个结点可以分为两个部分：数据域和指针域</p>
<p>​    指针域中的指针指向了一个完整的结点</p>
<p>​    范例：结点的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;  <span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;NODE,*PNODE;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="4-链表的分类"><a href="#4-链表的分类" class="headerlink" title="4. 链表的分类"></a>4. 链表的分类</h4><ul>
<li>单链表：每个结点的指针域只能指向后面结点</li>
<li>双链表：每一个结点有两个指针域</li>
<li>循环链表：能通过任何一个结点找到其他所有的结点</li>
<li>非循环链表：尾结点为null</li>
</ul>
<p>​    </p>
<h4 id="5-链表的伪算法"><a href="#5-链表的伪算法" class="headerlink" title="5. 链表的伪算法"></a>5. 链表的伪算法</h4><ol>
<li><p>非循环单链表：将q结点插入到p结点后面</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xRglh8"><img src="https://s1.ax1x.com/2022/10/25/xRglh8.png" alt="xRglh8.png"></a></p>
</li>
</ol>
<p>​    伪算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line">r = p-&gt;pNext;</span><br><span class="line">p-&gt;pNext = q;</span><br><span class="line">q-&gt;pNext = r;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line">q-&gt;pNext = p-&gt;pNext;</span><br><span class="line">p-&gt;pNext = q;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>非循环单链表：将p结点后面的那个结点删除</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xR2PDs"><img src="https://s1.ax1x.com/2022/10/25/xR2PDs.png" alt="xR2PDs.png"></a></p>
</li>
</ol>
<p>​    伪算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意:由于直接连会导致中间那个结点找不到从而导致内存的浪费,所以要先存起来,最后也要进行释放</span></span><br><span class="line">r = p-&gt;pNext;</span><br><span class="line">p-&gt;pNext = p-&gt;pNext-&gt;pNext;</span><br><span class="line"><span class="built_in">free</span>(r);</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h4 id="6-链表的算法"><a href="#6-链表的算法" class="headerlink" title="6. 链表的算法"></a>6. 链表的算法</h4><ol>
<li><p><strong>算法–链表的创建以及链表的遍历</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">count</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">count</span> * <span class="title">pNext</span>;</span></span><br><span class="line">&#125;NODE,* PNODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function">PNODE <span class="title">count_create</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_write</span><span class="params">(PNODE pHead)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设置头指针</span></span><br><span class="line">    PNODE pHead = <span class="literal">NULL</span>;</span><br><span class="line">    pHead = count_create(); <span class="comment">//创建一个非循环单链表，并返回头结点地址</span></span><br><span class="line">    count_write(pHead); <span class="comment">//遍历打印出来</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PNODE <span class="title">count_create</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp; <span class="comment">//临时存放用户输入的数据</span></span><br><span class="line">    <span class="keyword">int</span> num; <span class="comment">//存放有效结点的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置头指针指向头结点，头结点不存放任何有效数据</span></span><br><span class="line">    PNODE pHead = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="comment">//头结点的指针域设为NULL，防止后面没有结点</span></span><br><span class="line">    pHead-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pHead)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表的尾指针，用来挂每一个新生成的链表结点</span></span><br><span class="line">    PNODE pTail = pHead;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input number :&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; num ; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The %d number:&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tmp);</span><br><span class="line">        PNODE new_Node = (PNODE) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == new_Node)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新生成结点的指针域设置为NULL</span></span><br><span class="line">        new_Node-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//新生成的结点的数据域设置值</span></span><br><span class="line">        new_Node-&gt;number =tmp;</span><br><span class="line">        <span class="comment">//将新生成的结点挂在尾指针上</span></span><br><span class="line">        pTail-&gt;pNext = new_Node;</span><br><span class="line">        <span class="comment">//将尾指针指向新生成的新结点</span></span><br><span class="line">        pTail = new_Node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_write</span><span class="params">(PNODE pHead)</span></span>&#123;</span><br><span class="line">    PNODE pTail = pHead-&gt;pNext;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">NULL</span>!=pTail)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span> ,pTail-&gt;number);</span><br><span class="line">        <span class="comment">//将指针向后移</span></span><br><span class="line">        pTail = pTail-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p><strong>算法–链表的是否为空的判断和求链表长度</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否为空的函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;  //C语言使用bool类型需要导入的头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(PNODE pHead)</span></span>; <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(PNODE pHead)</span></span>&#123; <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pHead-&gt;pNext)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_len</span><span class="params">(PNODE pHead)</span></span>; <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_len</span><span class="params">(PNODE pHead)</span></span>&#123; <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    PNODE p = pHead-&gt;pNext;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">NULL</span> != p)&#123;</span><br><span class="line">        ++len;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p><strong>算法–链表的冒泡排序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(PNODE pHead)</span></span>; <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(PNODE pHead)</span></span>&#123; <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">int</span> i,j,tmp;</span><br><span class="line">    <span class="keyword">int</span> len = count_len(pHead);</span><br><span class="line">    PNODE p = pHead-&gt;pNext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;len<span class="number">-1</span> ; i++)&#123;</span><br><span class="line">        PNODE q = p-&gt;pNext;</span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>; j &lt; len ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;number&gt;q-&gt;number)&#123;</span><br><span class="line">                tmp = p-&gt;number;</span><br><span class="line">                p-&gt;number = q-&gt;number;</span><br><span class="line">                q-&gt;number = tmp;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            q = q-&gt;pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p><strong>算法–链表的插入元素和删除元素</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的插入算法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">count_insert</span><span class="params">(PNODE pHead, <span class="keyword">int</span> pos , <span class="keyword">int</span> val)</span></span>; <span class="comment">//函数声明 pos表示在有效结点第pos个增加结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">count_insert</span><span class="params">(PNODE pHead, <span class="keyword">int</span> pos , <span class="keyword">int</span> val)</span></span>&#123; <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PNODE p = pHead;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;pos; i++)&#123;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">        <span class="comment">//一定要判空，否则程序有bug</span></span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    pNew-&gt;number = val;</span><br><span class="line">    pNew-&gt;pNext = p-&gt;pNext;</span><br><span class="line">    p-&gt;pNext = pNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表的删除算法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">count_delete</span><span class="params">(PNODE pHead, <span class="keyword">int</span> pos , <span class="keyword">int</span> *val)</span></span>; <span class="comment">//函数声明，pos表示删除有效结点的第pos个</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">count_delete</span><span class="params">(PNODE pHead, <span class="keyword">int</span> pos , <span class="keyword">int</span> *val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PNODE p = pHead;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i&lt;pos ;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;pNext==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pNext==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PNODE tmp = p-&gt;pNext;</span><br><span class="line">    *val = tmp-&gt;number;</span><br><span class="line">    <span class="comment">//将p指针指向下下个结点</span></span><br><span class="line">    p-&gt;pNext = p-&gt;pNext-&gt;pNext;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2022/10/31/JavaEE05/">JavaEE05</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2022-10-31T05:58:35.000Z" itemprop="datePublished">
    2022-10-31
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/JavaEE/">JavaEE</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="request内置对象详解"><a href="#request内置对象详解" class="headerlink" title="request内置对象详解"></a>request内置对象详解</h2><h4 id="1-request内置对象的作用"><a href="#1-request内置对象的作用" class="headerlink" title="1. request内置对象的作用"></a>1. request内置对象的作用</h4><p>​    在JSP之中，request内置对象的主要工作就是服务器端接收客户端发送来的请求参数。</p>
<h4 id="2-request对象的继承结构"><a href="#2-request对象的继承结构" class="headerlink" title="2. request对象的继承结构"></a>2. request对象的继承结构</h4><p>​    request属于<code>javax.servlet.http.HttpServletRequest</code>接口的对象</p>
<table>
<thead>
<tr>
<th>继承结构</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public interface HttpServletRequest extends ServletRequest</td>
<td>扩展ServletRequest接口以提供HTTP servlet的请求信息</td>
</tr>
</tbody></table>
<p>​    注意：HttpServletRequest是继承<code>javax.servlet.ServletRequest</code>接口，但是ServletRequest接口只有一个子接口，不写成一个的原因是HttpServletRequest子接口是专门为了处理HTTP协议而提供的，而ServletRequest接口是负责所有相关协议的公共接口，以后可能还会有新的协议，新的协议要开发只需要让新的协议继续继承ServletRequest接口即可。</p>
<p>​    <strong>注意：如果以后要进行方法查询一定要两个接口一起看(从子接口开始找)，且所有提供接收参数的方法都在ServletRequest父接口提供</strong></p>
<h4 id="3-request内置对象解决传递参数乱码"><a href="#3-request内置对象解决传递参数乱码" class="headerlink" title="3. request内置对象解决传递参数乱码"></a>3. request内置对象解决传递参数乱码</h4><p>​    在使用form表单时，如果输入中文在提交后会变为中文乱码</p>
<p>​    在乱码问题的解决上需要考虑两种情况</p>
<ul>
<li><p>POST提交请求(表单上使用)：可以直接使用ServletRequest父接口定义的方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public void setCharacterEncoding(String env) throws UnsupportedEncodingException</td>
<td align="center">方法</td>
<td align="center">设置String env来重写此请求正文中使用的字符编码的名称。必须在使用getReader()读取请求参数或输入之前调用此方法。否则，它没有效果。</td>
</tr>
</tbody></table>
</li>
<li><p>GET提交请求(直接输入访问路径或者表单)：</p>
<p>Tomcat8以下的默认编码格式是<strong>ISO-8859-1</strong>，此时接收后需要进行编码的转换，以上就不用转了</p>
<p>如果是getParameter()方法其返回值为一个字符串，在String类中提供有改变字符串编码的方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public byte[] getBytes(String charsetName) throws UnsupportedEncodingException</td>
<td align="center">方法</td>
<td align="center">使用给定的字符集将此字符串编码为一个字节序列，并将结果存储到一个新的字节数组中。</td>
</tr>
<tr>
<td align="center">public String(byte[] bytes, String charsetName) throws UnsupportedEncodingException</td>
<td align="center">构造方法</td>
<td align="center">通过使用指定的字符集对指定的字节数组进行解码，构造新的String</td>
</tr>
</tbody></table>
<p>注意：<code>charsetName</code>表示要设置的字符集</p>
<p>将字符编码转换为<code>UTF-8</code>后再将字符数组使用上述构造方法设置为<code>UTF-8</code>转成String类型输出即可在页面正常显示</p>
</li>
</ul>
<p>​    在HttpServletRequest接口里面有一个方法，此方法可以判断出当前的请求模式</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public String getMethod()</td>
<td align="center">方法</td>
<td align="center">返回用于发出此请求的HTTP方法的名称，例如GET、POST或PUT。</td>
</tr>
</tbody></table>
<h4 id="4-POST与GET请求的区别"><a href="#4-POST与GET请求的区别" class="headerlink" title="4. POST与GET请求的区别"></a>4. POST与GET请求的区别</h4><ul>
<li>POST请求：主要用在表单上，处理路径只是提交路径其不会改变</li>
<li>GET请求：只要是用户直接进行页面访问，那么请求类型一定就是GET请求，表单上也可以使用GET请求，但是GET请求会将所有的请求参数都附加到表单访问路径上，所以不能够传递过多的内容，一般只能够传递4K~5K的内容</li>
</ul>
<p>​    注意：由于GET请求传递内容有限，所以一般使用POST请求</p>
<h4 id="5-request对象接收请求参数"><a href="#5-request对象接收请求参数" class="headerlink" title="5. request对象接收请求参数"></a>5. request对象接收请求参数</h4><p>​    <strong>request内置对象接收参数的来源</strong></p>
<ul>
<li><p>第一种来源：表单提交</p>
</li>
<li><p>第二种来源：标签指令传递(<code>&lt;jsp:include&gt;</code>、<code>&lt;jsp:forward&gt;</code>)</p>
</li>
<li><p>第三种来源：地址重写</p>
<p>地址重写的基本结构：<code>xxxxxx.jsp?参数名称=内容&amp;参数名称=内容...</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如以下代码为向inpuut.jsp页面传递了两个参数</span></span><br><span class="line">&lt;a href=&quot;input.jsp?msg=hello&amp;mid=30&quot;&gt;访问&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>地址重写相当于GET请求</p>
</li>
</ul>
<p>​    <strong>隐藏域</strong></p>
<p>​    在表单中有一种表单类型为隐藏域(其会跟着表单一起提交，但是其内容不能够由用户输入且用户无法看见隐藏域)</p>
<blockquote>
<input type="hidden" name ="name" value="lxs">
</blockquote>
<p>​    注意：一般隐藏域属于辅助的信息内容，一般都是固定好的</p>
<p>​    <strong>request内置对象的父类中提供有两个接收参数的方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public <strong>String</strong> getParameter(String name)</td>
<td align="center">方法</td>
<td align="center">以String形式返回请求参数的值，如果该参数不存在，则返回null。只有在确定参数只有一个值时，才应使用此方法。如果参数可能有多个值，请使用getParameterValues()</td>
</tr>
<tr>
<td align="center">public <strong>String[]</strong> getParameterValues(String name)</td>
<td align="center">方法</td>
<td align="center">返回包含给定请求参数的所有值的String对象数组，如果该参数不存在，则返回null。</td>
</tr>
</tbody></table>
<p>​    注意：getParameter只能接收一个内容，而getParameterValues可以接收一组内容</p>
<p>​    request内置对象提供返回全部请求参数名称的方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public Enumeration&lt;String&gt; getParameterNames()</code></td>
<td align="center">方法</td>
<td align="center">返回包含此请求中包含的参数名称的String对象的枚举。如果请求没有参数，该方法将返回空Enumeration。</td>
</tr>
</tbody></table>
<p>​    注意：通过这个方法就可以获得传递参数的名字，而通过传递参数的名字就可以获取到值</p>
<p>​    <strong>补充：Enumeration类(接口)</strong></p>
<p>​    Enumeration接口是Iterator迭代器的“古老版本”，从JDK 1.0开始，Enumeration接口就已经存在了(Iterator从JDK 1.2才出现)</p>
<p>​    Enumeration接口的方法介绍</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean hasMoreElements()</td>
<td align="center">方法</td>
<td align="center">这是检测Enumeration 对象是否还有元素，有则返回true,否则false</td>
</tr>
<tr>
<td align="center">E nextElement()</td>
<td align="center">方法</td>
<td align="center">如果Enumeration对象还有元素，该方法得到下一个元素</td>
</tr>
</tbody></table>
<p>​    </p>
<p>​    范例：动态的接收参数</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送方 form.jsp文件</span></span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span>%&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;request.jsp&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">	&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;text1&quot;</span> /&gt;</span><br><span class="line">	&lt;input type=<span class="string">&quot;checkbox&quot;</span> name=<span class="string">&quot;**box&quot;</span> value=<span class="string">&quot;1&quot;</span>&gt;<span class="number">1</span></span><br><span class="line">	&lt;input type=<span class="string">&quot;checkbox&quot;</span> name=<span class="string">&quot;**box&quot;</span> value=<span class="string">&quot;2&quot;</span>&gt;<span class="number">2</span></span><br><span class="line">	&lt;input type=<span class="string">&quot;checkbox&quot;</span> name=<span class="string">&quot;**box&quot;</span> value=<span class="string">&quot;3&quot;</span>&gt;<span class="number">3</span></span><br><span class="line">	&lt;input type=<span class="string">&quot;checkbox&quot;</span> name=<span class="string">&quot;**box&quot;</span> value=<span class="string">&quot;4&quot;</span>&gt;<span class="number">4</span></span><br><span class="line">	&lt;input type=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;submit1&quot;</span> value=<span class="string">&quot;提交&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收方 request.jsp文件</span></span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span>%&gt;</span><br><span class="line">&lt;%<span class="comment">//取得属性</span></span><br><span class="line">	request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">	Enumeration&lt;String&gt; e = request.getParameterNames();</span><br><span class="line">	<span class="keyword">while</span>(e.hasMoreElements())&#123;</span><br><span class="line">		String s = e.nextElement();</span><br><span class="line">		<span class="keyword">if</span>(s.startsWith(<span class="string">&quot;**&quot;</span>))&#123;</span><br><span class="line">			String[] str = request.getParameterValues(s);</span><br><span class="line">%&gt;</span><br><span class="line">			&lt;h3&gt;&lt;%=Arrays.toString(str)%&gt;&lt;/h3&gt;</span><br><span class="line">&lt;%</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">%&gt;</span><br><span class="line">			&lt;h4&gt;&lt;%=request.getParameter(s)%&gt;&lt;/h4&gt;</span><br><span class="line">&lt;%</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>​    注意：为了区分接收的一个参数是对应一个值还是多个值，对多个值参数在设置<code>name</code>属性时一般在前面加<code>**</code>，如<code>**XXXX</code>，用作区分</p>
<h4 id="6-通过request对象实现资源定位"><a href="#6-通过request对象实现资源定位" class="headerlink" title="6. 通过request对象实现资源定位"></a>6. 通过request对象实现资源定位</h4><p>​    在request对象中还有一个重要的操作方法：取得路径名称(该方法在<code>javax.servlet.http.HttpServletRequest</code>中定义)</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public String getContextPath()</td>
<td align="center">方法</td>
<td align="center">取得上下文路径</td>
</tr>
</tbody></table>
<p>​    getContextPath()取得的是整个虚拟目录的映射路径，在之前Tomcat的<code>conf/server.xml</code>中设置添加了<code>&lt;Context path = &quot;/lxs&quot; docBase = &quot;D:\lxsweb&quot; /&gt;</code>，getContextPath()方法取得的是<code>/lxs</code></p>
<p>​    通过取得整个虚拟目录的映射路径，我们可以实现资源定位。在实际开发中，我们会导入img、css、js，此时文件通常是使用传统<code>../</code>、<code>/</code>的形式进行引用，但此时如果代码文件发生移动，那么其的路径会发生变化则需要重写配置<code>../</code>、<code>/</code>。而使用getContextPath()可以解决这个问题。</p>
<p>​    范例：1.输出项目根路径，2.实现资源定位</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.jsp与images同级</span></span><br><span class="line"><span class="comment">//新建文件夹images，导入图片文件img_1.jpg</span></span><br><span class="line"><span class="comment">//编写文件test.jsp文件</span></span><br><span class="line">&lt;%<span class="meta">@page</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">	String contextpath = request.getContextPath();</span><br><span class="line">%&gt;</span><br><span class="line"><span class="comment">//输出项目根路径</span></span><br><span class="line">&lt;h1&gt;&lt;%=contextpath%&gt;&lt;/h1&gt;</span><br><span class="line"><span class="comment">//实现资源定位</span></span><br><span class="line">&lt;img src=<span class="string">&quot;&lt;%=contextpath%&gt;/images/img_1.jpg&quot;</span> height=<span class="string">&quot;40%&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>​    注意：此时不管test.jsp放在什么位置，图片都可以正常的显示出来，<strong>在实际开发中都会使用这种方式来引用资源</strong></p>
<h4 id="7-通过request对象取得基础信息"><a href="#7-通过request对象取得基础信息" class="headerlink" title="7. 通过request对象取得基础信息"></a>7. 通过request对象取得基础信息</h4><p>​    在<code>javax.servlet.http.HttpServletRequest</code>接口的父接口<code>javax.servlet.ServletRequest</code>中提供有取得其他基本信息的方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public String getRemoteAddr()</td>
<td align="center">方法</td>
<td align="center">返回发送请求的客户端或最后一个代理的IP地址</td>
</tr>
<tr>
<td align="center">public String getScheme()</td>
<td align="center">方法</td>
<td align="center">返回用于发出此请求的协议名称，例如http、https或ftp</td>
</tr>
<tr>
<td align="center">public String getServerName()</td>
<td align="center">方法</td>
<td align="center">返回请求发送到的服务器的主机名</td>
</tr>
<tr>
<td align="center">public int getServerPort()</td>
<td align="center">方法</td>
<td align="center">返回请求发送到的端口号</td>
</tr>
</tbody></table>
<p>​    范例：上述方法的使用以及获取项目的基本路径</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写文件path.jsp</span></span><br><span class="line">&lt;%<span class="meta">@page</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">	String ip = request.getRemoteAddr();</span><br><span class="line">	String scheme = request.getScheme();</span><br><span class="line">	String name = request.getServerName();</span><br><span class="line">	<span class="keyword">int</span> port = request.getServerPort();</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;ip地址：&lt;%=ip%&gt;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;协议：&lt;%=scheme%&gt;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;主机名：&lt;%=name%&gt;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;端口号：&lt;%=port%&gt;&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">	String path = request.getScheme()+<span class="string">&quot;://&quot;</span>+ request.getServerName()+<span class="string">&quot;:&quot;</span>+request.getServerPort()+request.getContextPath();</span><br><span class="line">%&gt;</span><br><span class="line">&lt;h1&gt;访问路径：&lt;%=path%&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>####8. getAttribute()和getParameter()的区别</p>
<p>​    1、getAttribute是返回(object)对象,getParameter返回字符串。</p>
<p>​    2、getAttribute可以返回格式化任意类型，getParameter只能返回字符串</p>
<p>​    3、与getAttribute()方法对应的有setAttribute()方法，但是没有与getParameter()相对的setParameter()</p>
<p>​    4、request.getAttribute获取的是服务器设置的数据，request.getParameter获取的是客户端比如浏览器的数据(获取http提交过来的数据)</p>
<p>​    5、getParameter方法就是服务器端接受客户端传递过来的数据时使用；getAttribute方法是在服务器端内部使用，数据通过getParameter获取进来之后，在另一个页面还想继续使用这个数据就要把这个数据通过setAttribute保存起来，想用时再用getAttribute取出来即可使用<br>​    </p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2022/10/09/javaEE04/">javaEE04</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2022-10-09T06:36:39.000Z" itemprop="datePublished">
    2022-10-09
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/JavaEE/">JavaEE</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="JSP内置对象"><a href="#JSP内置对象" class="headerlink" title="JSP内置对象"></a>JSP内置对象</h2><h4 id="1-内置对象的概念"><a href="#1-内置对象的概念" class="headerlink" title="1. 内置对象的概念"></a>1. 内置对象的概念</h4><p>​    在Java程序中给了你一个类，要使用他用户需要创建一个对象，而<strong>内置对象指的是不需要用户自己创建的对象</strong>(即不需要用户自己手工进行对象实例化)。而是由WEB容器在它启动时默认创建好的对象，用户可以直接拿来使用</p>
<h4 id="2-内置对象"><a href="#2-内置对象" class="headerlink" title="2. 内置对象"></a>2. 内置对象</h4><p>​    当前主要学习JSP中提供的九个内置对象</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">对象名称</th>
<th align="center">JavaEEAPI路径</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">pageContext</td>
<td align="center">javax.servlet.jsp.PageContext</td>
<td align="center">页面的上下文操作</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">request</td>
<td align="center">javax.servlet.http.HttpServletRequest</td>
<td align="center">服务器端接收客户端请求内容</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">response</td>
<td align="center">javax.servlet.http.HttpServletResponse</td>
<td align="center">服务器端回应客户端的请求操作</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">session</td>
<td align="center">javax.servlet.http.HttpSession</td>
<td align="center">描述每一个用户(登录)的信息</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">application</td>
<td align="center">javax.servlet.ServletContext</td>
<td align="center">描述整个当前项目的上下文</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">config</td>
<td align="center">javax.servlet.ServletConfig</td>
<td align="center">取得默认的配置信息</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">out</td>
<td align="center">javax.servlet.jsp.Writer</td>
<td align="center">进行输出，一般不用</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">page</td>
<td align="center">javax.lang.Object</td>
<td align="center">每一个页面都属于Object子类(一般不用)</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">exception</td>
<td align="center">java.lang.Throwable</td>
<td align="center">默认情况下，所有的异常都可以由容器处理，处理方式为输出错误信息并结束程序运行</td>
</tr>
</tbody></table>
<p>​    通过JavaEEAPI路径可以查询到每个对象有的方法</p>
<p>​    <strong>注意：在这九个内置对象中，前五个内置对象是精华需要重点了解学习</strong>，但要学好JSP开发，以上内置对象需要全部记住</p>
<h4 id="3-四种属性范围"><a href="#3-四种属性范围" class="headerlink" title="3. 四种属性范围"></a>3. 四种属性范围</h4><p>​    四种属性范围是整个JavaWeb的核心概念，如果不清楚四种属性范围，就无法更好的理解MVC，也无法进行有效的程序开发，以及后面理解Struts、SpringMVC等概念</p>
<p>​    <strong>属性范围的概念</strong></p>
<p>​    在任何一个Web项目中都会存在多个页面，如果一个对象需要跨越多个页面后依然可以被使用，这被称为属性的保存范围，在JSP中对属性的操作提供如下三个方法。</p>
<ol>
<li><p><strong>设置属性：<code>public void setAttribute(String name,Object value)</code></strong></p>
<p>属性名要String类型且不允许重复(重复就会覆盖)，value是Object类型意味着可以报存所有的Java类型</p>
</li>
<li><p><strong>取得属性：<code>public Object getAttribute(String name)</code></strong></p>
</li>
<li><p><strong>删除属性：<code>public void removeAttribute(String name)</code></strong></p>
</li>
</ol>
<p>​    在JSP里面一共有四个对象具备以上的三个方法：pageContext、request、session、application</p>
<p>​    四种属性范围刚好也是对应了这四个对象</p>
<h4 id="4-page属性范围-pageContext"><a href="#4-page属性范围-pageContext" class="headerlink" title="4. page属性范围(pageContext)"></a>4. page属性范围(pageContext)</h4><p>​    <strong>page属性范围：对象只能够在当前的JSP页面中使用</strong></p>
<p>​    注意：page属性范围不是只使用page对象操作，事实上没有这个对象，我们是使用pageContext对象完成</p>
<p>​    范例：通过pageContext设置本页面属性</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写文件page.jsp</span></span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span>%&gt;</span><br><span class="line">&lt;%<span class="comment">//设置属性</span></span><br><span class="line">	pageContext.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;LXS&quot;</span>);</span><br><span class="line">	pageContext.setAttribute(<span class="string">&quot;this_time&quot;</span>,<span class="keyword">new</span> Date());</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%<span class="comment">//取得属性</span></span><br><span class="line">	String tname = (String) pageContext.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">	Date this_time = (Date) pageContext.getAttribute(<span class="string">&quot;this_time&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;h1&gt;姓名：&lt;%=tname%&gt;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;时刻：&lt;%=this_time%&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>​    注意：pageContext的属性作用范围只在当前页面，如果发生跳转(不管是服务器跳转还是客户端跳转)那么pageContext所设置的属性的值不会保留到其他页面</p>
<h4 id="5-request属性范围-request"><a href="#5-request属性范围-request" class="headerlink" title="5. request属性范围(request)"></a>5. request属性范围(request)</h4><p>​    如果想在执行服务器跳转后依然可以取得设置的属性内容，则可以采用request属性范围</p>
<p>​    范例：使用request对象来传递服务器跳转的值</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写文件request_a.jsp</span></span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span>%&gt;</span><br><span class="line">&lt;%<span class="comment">//设置属性</span></span><br><span class="line">	request.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;LXS&quot;</span>);</span><br><span class="line">	request.setAttribute(<span class="string">&quot;this_time&quot;</span>,<span class="keyword">new</span> Date());</span><br><span class="line">%&gt;</span><br><span class="line"><span class="comment">//服务器端跳转</span></span><br><span class="line">&lt;jsp:forward page=<span class="string">&quot;request.jsp&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写文件request_b.jsp</span></span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span>%&gt;</span><br><span class="line">&lt;%<span class="comment">//取得属性</span></span><br><span class="line">	String tname = (String) request.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">	Date this_time = (Date) request.getAttribute(<span class="string">&quot;this_time&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;h1&gt;姓名：&lt;%=tname%&gt;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;时刻：&lt;%=this_time%&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>​    注意：只有是服务器端跳转无论跳转几次，request设置的属性可以一直被保留下来</p>
<p>​    <strong>注意：服务器端跳转与客户端跳转的最大使用区别：服务器端跳转可以传递request属性，而客户端跳转不能传递request属性</strong></p>
<h4 id="6-session属性范围-session"><a href="#6-session属性范围-session" class="headerlink" title="6. session属性范围(session)"></a>6. session属性范围(session)</h4><p>​    如果不想受到跳转的类型限制，则可以继续扩大属性的保存范围，使用session范围，只要设置了一个session属性，那所有与之相关联的所有页面都可以访问。</p>
<p>​    范例：session对象的使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写文件session_a.jsp</span></span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span>%&gt;</span><br><span class="line">&lt;%<span class="comment">//设置属性</span></span><br><span class="line">	session.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;LXS&quot;</span>);</span><br><span class="line">	session.setAttribute(<span class="string">&quot;this_time&quot;</span>,<span class="keyword">new</span> Date());</span><br><span class="line">%&gt;</span><br><span class="line"><span class="comment">//客户端跳转</span></span><br><span class="line">&lt;a href=&quot;session_b&quot;&gt;跳转&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写文件session_b.jsp</span></span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span>%&gt;</span><br><span class="line">&lt;%<span class="comment">//取得属性</span></span><br><span class="line">	String tname = (String) session.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">	Date this_time = (Date) session.getAttribute(<span class="string">&quot;this_time&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;h1&gt;姓名：&lt;%=tname%&gt;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;时刻：&lt;%=this_time%&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>​    注意：虽然session属性范围可以包括所有的跳转页面，但如果关闭浏览器再次访问，session设置的属性会失效</p>
<p>​    <strong>session最简单的概念为用于客户端描述一个个用户的信息，每个用户的信息彼此独立</strong></p>
<h4 id="7-application属性范围-application"><a href="#7-application属性范围-application" class="headerlink" title="7. application属性范围(application)"></a>7. application属性范围(application)</h4><p>​    如果需要在浏览器关闭后，再次打开依然可以访问到我们设置的属性，那么需要将属性范围设置为application范围</p>
<p>​    范例：application对象的使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写文件application_a.jsp</span></span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span>%&gt;</span><br><span class="line">&lt;%<span class="comment">//设置属性</span></span><br><span class="line">	application.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;LXS&quot;</span>);</span><br><span class="line">	application.setAttribute(<span class="string">&quot;this_time&quot;</span>,<span class="keyword">new</span> Date());</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写文件application_b.jsp</span></span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span>%&gt;</span><br><span class="line">&lt;%<span class="comment">//取得属性</span></span><br><span class="line">	String tname = (String) application.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">	Date this_time = (Date) application.getAttribute(<span class="string">&quot;this_time&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;h1&gt;姓名：&lt;%=tname%&gt;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;时刻：&lt;%=this_time%&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>​    注意：上述代码并没有写跳转语句，但当打开<code>application_a.jsp</code>再打开<code>application_b.jsp</code>，依然可以访问到设置的属性</p>
<p>​    <strong>注意：只要设置了此属性，那么意味着属性保存在服务器上，所有的用户都可以访问到，与是否关闭浏览器无关，但如果关闭服务器，则该设置的属性失效，即如果服务器不关闭，该设置的属性将一直存在</strong></p>
<h4 id="8-四种属性范围总结"><a href="#8-四种属性范围总结" class="headerlink" title="8. 四种属性范围总结"></a>8. 四种属性范围总结</h4><p>​    保存范围越大的属性，实际上占用的资源时间长，所以对于属性范围的选择几乎不会选择application范围(保存时间过长会占用服务器资源使得服务器性能下降)，剩下三种都会有使用到</p>
<h4 id="9-pageContext对象的进阶"><a href="#9-pageContext对象的进阶" class="headerlink" title="9. pageContext对象的进阶"></a>9. pageContext对象的进阶</h4><p>​    pageContext对象实际上可以设置上面的四种属性范围，在pageContext对应的类(<code>javax.servlet.jsp.PageContext</code>)的父类(<code>javax.servlet.jsp.JspContext</code>)中提供了另外一组<strong>重载</strong>的属性操作方法</p>
<ul>
<li><p><strong>设置属性：<code>public abstract void setAttribute(String name,Object value,int scope)</code></strong></p>
</li>
<li><p><strong>取得属性：<code>public abstract Object getAttribute(String name,int scope)</code></strong></p>
</li>
</ul>
<ul>
<li>**删除属性：<code>public abstract void removeAttribute(String name,int scope)**</code></li>
</ul>
<p>​    对于重载方法中的scope参数取值都在PageContext类里面定义</p>
<table>
<thead>
<tr>
<th align="center">scope在PageContext类中的定义</th>
<th align="center">类型</th>
<th align="center">对应数值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public static final int PAGE_SCOPE</td>
<td align="center">静态常量</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">public static final int REQUEST_SCOPE</td>
<td align="center">静态常量</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">public static final int SESSION_SCOPE</td>
<td align="center">静态常量</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">public static final int APPLICATION_SCOPE</td>
<td align="center">静态常量</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p>​    范例pageContext对应方法的进阶使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写文件pageContext_a.jsp</span></span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span>%&gt;</span><br><span class="line">&lt;%<span class="comment">//设置属性</span></span><br><span class="line">	pageContext.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;LXS&quot;</span>,<span class="number">4</span>);</span><br><span class="line">	pageContext.setAttribute(<span class="string">&quot;this_time&quot;</span>,<span class="keyword">new</span> Date(),<span class="number">4</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写文件pageContext_b.jsp</span></span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span>%&gt;</span><br><span class="line">&lt;%<span class="comment">//取得属性</span></span><br><span class="line">	String tname = (String) application.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">	Date this_time = (Date) application.getAttribute(<span class="string">&quot;this_time&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;h1&gt;姓名：&lt;%=tname%&gt;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;时刻：&lt;%=this_time%&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>​    pageContext是一个功能强大的对象，但是这个对象只能够在JSP中使用</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2022/10/09/javaEE03/">javaEE03</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2022-10-09T06:31:30.000Z" itemprop="datePublished">
    2022-10-09
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/JavaEE/">JavaEE</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="web项目编写"><a href="#web项目编写" class="headerlink" title="web项目编写"></a>web项目编写</h2><h4 id="1-Idea对Javaweb的项目创建"><a href="#1-Idea对Javaweb的项目创建" class="headerlink" title="1. Idea对Javaweb的项目创建"></a>1. Idea对Javaweb的项目创建</h4><pre><code>   1. 点击新建项目，选择`Java Enterprise`，更改项目名称，将项目模板改为`Web 应用程序`，将应用程序服务器改为自己下载的Tomcat路径，下面都不用动，点`next`

   2. 这里的第三方框架暂时都是用不上，只需要在已添加项中有`Servlet`就行
   3. 点击完成Javaweb项目就创建完成</code></pre>
<p>​    <strong>项目结构的概述</strong></p>
<pre><code>   1. .idea不用管他，在src中编写文件

   2. 在java文件夹中编写java代码
   3. 在resources文件夹中放置配置文件
   4. 在webapp中放jsp文件
   5. 需要的包要在pom.xml中声明</code></pre>
<p>​    <strong>欢迎页与列表</strong></p>
<p>​    在项目新建后即可运行，点击运行可以运行项目自动生成的jsp欢迎页面，但在学习过程中需要列表来显示所有页面，此时可以通过修改Tomcat中的<code>conf/web.xml</code>文件的<code>welcome-file-list</code>来更改</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//web.xml文件里的默认设置；名叫index的页面作为主页，这几个页面(不一定只有三个)都有的话显示优先级为从上到下</span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    可以把这串设置复制到自己项目的xml文件中，然后自己修改首次登录页面(如果项目中没有设置默认是使用Tomcat提供的xml中的设置)，<strong>如果项目中没有名叫这几个的页面，则显示列表</strong></p>
<h4 id="2-Javaweb的jdbc连接"><a href="#2-Javaweb的jdbc连接" class="headerlink" title="2. Javaweb的jdbc连接"></a>2. Javaweb的jdbc连接</h4><p>​    使用jsp来引入jdbc，<strong>此时mysql的驱动程序应当复制一份到Tomcat的<code>lib</code>目录下</strong></p>
<blockquote>
<p>C:\Program Files\Apache Software Foundation\Tomcat 8.5_Tomcat8new\lib</p>
</blockquote>
<p>​    否则会出现错误：数据库无法找到</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javax.servlet.ServletException: java.lang.ClassNotFoundException: com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>



<p>​    还有一种情况是url书写时发生错误，如端口号写错，则提示错误：数据库连接异常</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javax.servlet.ServletException: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure</span><br></pre></td></tr></table></figure>



<p>​    另外，在JSP中写JDBC没有对异常有强制处理，一旦出错就是报500，因为默认情况下，所有的异常都可以由容器处理，处理方式为输出错误信息并结束程序运行</p>
<h4 id="3-数据检查"><a href="#3-数据检查" class="headerlink" title="3. 数据检查"></a>3. 数据检查</h4><p>​    在系统开发当中，数据的安全性检查分为两个部分</p>
<ul>
<li><p>服务器的验证：由JSP文件负责验证</p>
</li>
<li><p>客户端验证：由JavaScript完成</p>
</li>
</ul>
<p>​    <strong>任何一个健壮的系统这两个验证都需要编写，即两端都要编写验证</strong></p>

      
    </div>
</article>

    </li>
  
</ul>

  <section id="nav-wrapper">
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">next »</a>
    </nav>
  </section>


            <footer>
    <div>© 2022 - nature </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>