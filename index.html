<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>祈雨</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="祈雨">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="祈雨">
<meta property="og:locale">
<meta property="article:author" content="nature">
<meta property="article:tag" content="Rain">
<meta name="twitter:card" content="summary">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">祈雨</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Spring04" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/04/25/Spring04/" class="article-date">
  <time datetime="2023-04-25T11:27:33.000Z" itemprop="datePublished">2023-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/04/25/Spring04/">Spring04</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SpringMVC的数据的请求和响应"><a href="#SpringMVC的数据的请求和响应" class="headerlink" title="SpringMVC的数据的请求和响应"></a>SpringMVC的数据的请求和响应</h2><h4 id="1-SpringMVC的数据相应方式"><a href="#1-SpringMVC的数据相应方式" class="headerlink" title="1. SpringMVC的数据相应方式"></a>1. SpringMVC的数据相应方式</h4><p><strong>1. 页面跳转</strong></p>
<ul>
<li>直接返回字符串</li>
<li>通过ModelAndView对象返回</li>
</ul>
<p><strong>2.回写数据</strong></p>
<ul>
<li>直接返回字符串</li>
<li>返回对象或集合</li>
</ul>
<h4 id="2-页面跳转"><a href="#2-页面跳转" class="headerlink" title="2. 页面跳转"></a>2. 页面跳转</h4><p>​    <strong>(1).返回字符串形式</strong></p>
<p>​        此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9Vqgdx"><img src="https://s1.ax1x.com/2023/04/22/p9Vqgdx.png" alt="p9Vqgdx.png"></a></p>
<p>​    该种形式就是上面代码模拟的形式</p>
<p>​    <strong>(2).返回ModelAndView形式</strong></p>
<p>​    Model表示模型，作用为封装数据；View表示视图，作用为展示数据。在返回视图给页面时可以不携带数据，只展示视图</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9VOPjH"><img src="https://s1.ax1x.com/2023/04/22/p9VOPjH.png" alt="p9VOPjH.png"></a></p>
<p>​    modelAndView.setViewName(“页面路径”)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;/user/save/result&quot;</span>);<span class="comment">//默认为forward模式  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ModelAndView mv = new ModelAndView(&quot;redirect:/user/save/result&quot;);//redirect模式</span></span><br></pre></td></tr></table></figure>



<p>​    也可以为model设置数据，通过方法<code>modelAndView.addObject(键值对)</code></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9VOxqs"><img src="https://s1.ax1x.com/2023/04/22/p9VOxqs.png" alt="p9VOxqs.png"></a></p>
<p>​    当然也可以换一种方式，通过注入思想，直接在方法传递形参，因为本身方法是SpringMVC调用，所以在调用方法时自动创造形参相对应的对象</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9VxqTs"><img src="https://s1.ax1x.com/2023/04/22/p9VxqTs.png" alt="p9VxqTs.png"></a></p>
<p>​    在使用字符串形式时，也可以通过Model对象来传递参数，下面代码的model对象也是由SpringMVC自动创建</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9Vze1K"><img src="https://s1.ax1x.com/2023/04/22/p9Vze1K.png" alt="p9Vze1K.png"></a></p>
<h4 id="3-回写数据"><a href="#3-回写数据" class="headerlink" title="3. 回写数据"></a>3. 回写数据</h4><p>​    <strong>(1).直接返回字符串</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9VzXHH"><img src="https://s1.ax1x.com/2023/04/22/p9VzXHH.png" alt="p9VzXHH.png"></a></p>
<p>​    可以通过SpringMVC框架直接注入：通过形参声明response引用类型由SpringMVC分配对象</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ZSVEj"><img src="https://s1.ax1x.com/2023/04/22/p9ZSVEj.png" alt="p9ZSVEj.png"></a></p>
<p>​    注意：回写是不需要跳转，方法返回值为void</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ZSu80"><img src="https://s1.ax1x.com/2023/04/22/p9ZSu80.png" alt="p9ZSu80.png"></a></p>
<p>​    浏览器输入页面后得到回写的字符串</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ZSGVJ"><img src="https://s1.ax1x.com/2023/04/22/p9ZSGVJ.png" alt="p9ZSGVJ.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9Zpmee"><img src="https://s1.ax1x.com/2023/04/22/p9Zpmee.png" alt="p9Zpmee.png"></a></p>
<p>​    注意：该注解加在方法前，如果不加注解，SpringMVC会把返回的return的字符串当作跳转页面名称进行资源匹配</p>
<p>​    使用<code>@ResponseBody</code>注解进行字符串的回写</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9Zp5Sx"><img src="https://s1.ax1x.com/2023/04/22/p9Zp5Sx.png" alt="p9Zp5Sx.png"></a></p>
<p>​    上述回写字符串一般没什么意义，在实际开发中会回写json格式字符串，把某个实体类中存储的数据转换器json格式进行返回</p>
<p>​    首先在pom.xml导json相关的包，</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9Zx2Us"><img src="https://s1.ax1x.com/2023/04/23/p9Zx2Us.png" alt="p9Zx2Us.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ZxfCq"><img src="https://s1.ax1x.com/2023/04/23/p9ZxfCq.png" alt="p9ZxfCq.png"></a></p>
<p>​    通过新建对象ObjectMapper，并调用对象中方法<code>writeValueAsString(要转成json格式字符串的对象)</code>，进行转换</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ZxxxK"><img src="https://s1.ax1x.com/2023/04/23/p9ZxxxK.png" alt="p9ZxxxK.png"></a></p>
<p>​    <strong>(2).返回对象或者集合</strong></p>
<p>​    对于手动转型为字符串的操作，SpringMVC有提供自动转型的功能，但要实现该功能需要手动的进行配置</p>
<p>​    找处理器适配器<code>(org.springframework.web.servlet.HandlerAdapter)</code>中的<code>RequestMappingHandlerAdapter</code>，在这个类中提供有<code>setMessageConverters</code>方法指定多个消息转换器</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eFYtg"><img src="https://s1.ax1x.com/2023/04/23/p9eFYtg.png" alt="p9eFYtg.png"></a></p>
<p>​    在spring-mvc.xml文件中注入且<strong>修改处理器适配器的转换逻辑</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eiHln"><img src="https://s1.ax1x.com/2023/04/23/p9eiHln.png" alt="p9eiHln.png"></a></p>
<p>​    此时在java类只要传递对象SpringMVC就可以自动的把它转换为json格式</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eFkm6"><img src="https://s1.ax1x.com/2023/04/23/p9eFkm6.png" alt="p9eFkm6.png"></a></p>
<p>​    除了上述的spring-mvc.xml配置非常繁琐还可以通过如下方式简化配置</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ekC4g"><img src="https://s1.ax1x.com/2023/04/23/p9ekC4g.png" alt="p9ekC4g.png"></a></p>
<p>​    <strong>HandlerMapping(处理器映射器)，是SpringMVC中用来处理Request请求URL到具体Controller的，其自身也分成很多种类；</strong></p>
<p>​    <strong>HandlerAdapter(处理器适配器)，是SpringMVC中用来处理具体请求映射到具体方法的，其自身也分很多种类</strong></p>
<p>​    在spring-mvc.xml文件中配置注解驱动取代注入配置处理器适配器，注意：使用mvc的注解驱动需要导入命名空间和约束路径</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eF5B6"><img src="https://s1.ax1x.com/2023/04/23/p9eF5B6.png" alt="p9eF5B6.png"></a></p>
<p>​    导入完之后编写注解驱动</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eF29J"><img src="https://s1.ax1x.com/2023/04/23/p9eF29J.png" alt="p9eF29J.png"></a></p>
<h4 id="4-SpringMVC获得请求参数"><a href="#4-SpringMVC获得请求参数" class="headerlink" title="4. SpringMVC获得请求参数"></a>4. SpringMVC获得请求参数</h4><p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eAqOI"><img src="https://s1.ax1x.com/2023/04/23/p9eAqOI.png" alt="p9eAqOI.png"></a></p>
<p><strong>(1).获得基本类型参数</strong></p>
<p>​    Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配</p>
<p>​    注意：客户端请求任何参数都是字符串形式，但用了Spring框架可以帮你把数据进行自动转型</p>
<p>​    编写方法获得请求参数<code>localhost:8080/user/quick11?username=zhangsan&amp;age=18</code> </p>
<p>​    该方法有<code>@ResponBody</code>表示不进行页面跳转，返回值为void表示不回写数据，两个形参由于接收GET请求的参数</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eEyAf"><img src="https://s1.ax1x.com/2023/04/23/p9eEyAf.png" alt="p9eEyAf.png"></a></p>
<p><strong>(2).获得POJO类型参数</strong></p>
<p>​    Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eVAvd"><img src="https://s1.ax1x.com/2023/04/23/p9eVAvd.png" alt="p9eVAvd.png"></a></p>
<p><strong>(3).获得数组类型参数</strong></p>
<p>​    Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配</p>
<p>​    因为数组默认是打印地址，所以要使用<code>Arrays.asList()</code>方法打印</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eeA0I"><img src="https://s1.ax1x.com/2023/04/23/p9eeA0I.png" alt="p9eeA0I.png"></a></p>
<p><strong>(4).获得集合类型参数</strong></p>
<p>​    获得集合参数时，在编写方法时要将集合参数包装到一个POJO中，以POJO为形参才能够接收</p>
<p>​    封装的POJO一般叫做VO对象，为该对象生成get、set以及toString方法</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eQIbQ"><img src="https://s1.ax1x.com/2023/04/23/p9eQIbQ.png" alt="p9eQIbQ.png"></a></p>
<p>​    在提交数据时，需要使用form表单进行提交，name的属性值要与后端的值相同</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9elNZQ"><img src="https://s1.ax1x.com/2023/04/23/p9elNZQ.png" alt="p9elNZQ.png"></a></p>
<p>​    Controller业务中的方法vo来当作形参接收，vo与表单的userList[x]相对应</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9e3K3t"><img src="https://s1.ax1x.com/2023/04/23/p9e3K3t.png" alt="p9e3K3t.png"></a></p>
<p><strong>(5).获得ajax发送的集合类型参数</strong></p>
<p>​    当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用<code>@RequestBody</code>可以直接接收集合数据无需使用POJO进行包装</p>
<p>​    一般发生ajax请求除了可以使用原生的js外，还可以导入jQuery包</p>
<p>​    导入jQuery包，编写ajax请求</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eYsQ1"><img src="https://s1.ax1x.com/2023/04/23/p9eYsQ1.png" alt="p9eYsQ1.png"></a></p>
<p>​    服务端直接用集合来接收，方法参数前要加注解<code>@RequestBody</code></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eYLTS"><img src="https://s1.ax1x.com/2023/04/23/p9eYLTS.png" alt="p9eYLTS.png"></a></p>
<p>​    因为有静态资源访问的问题，需要在<code>spring-mvc.xml</code>文件下加一句话</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9etep9"><img src="https://s1.ax1x.com/2023/04/23/p9etep9.png" alt="p9etep9.png"></a></p>
<h4 id="5-SpringMVC获得请求参数-静态资源访问的开启"><a href="#5-SpringMVC获得请求参数-静态资源访问的开启" class="headerlink" title="5. SpringMVC获得请求参数-静态资源访问的开启"></a>5. SpringMVC获得请求参数-静态资源访问的开启</h4><p>​    如果不加静态资源设置spring-mvc.xml会使得访问不成功，原因是导入的jQuery文件找不到，因为在web.xml的文件中的前端控制器的配置是<code>/</code>，其是缺省的servlet，客户端发送请求找对应servlet进行处理，如果没有则全部交给缺省的进行处理，即下面代码中名字叫<code>DispatcherServlet</code>的servlet进行处理，但其内部进行虚拟路径的匹配，而jQuery.js也通过<code>@RequestMapping(&quot;/quick15&quot;)</code>进行匹配，但是没有，所以匹配不上</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eU9aT"><img src="https://s1.ax1x.com/2023/04/23/p9eU9aT.png" alt="p9eU9aT.png"></a></p>
<p>​    下面代码表示在SpringMVC框架中开放资源的访问权限，mapping表示映射地址，location表示哪个目录下的资源是对外开放的</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9etep9"><img src="https://s1.ax1x.com/2023/04/23/p9etep9.png" alt="p9etep9.png"></a></p>
<h4 id="6-请求数据乱码问题"><a href="#6-请求数据乱码问题" class="headerlink" title="6. 请求数据乱码问题"></a>6. 请求数据乱码问题</h4><p>​    Tomcat8.5的服务器，对于GET请求是不会乱码的，但POST请求对于中文会出现乱码问题</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9edQvd"><img src="https://s1.ax1x.com/2023/04/23/p9edQvd.png" alt="p9edQvd.png"></a></p>
<p>​    在web.xml文件中配置一个全局过滤器，并配置过滤器以那种方式进行编码，<code>&lt;filter-mapping&gt;</code> 配置对什么资源进行过滤，<code>/*</code>表示对所有的资源进行过滤</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ed2PU"><img src="https://s1.ax1x.com/2023/04/23/p9ed2PU.png" alt="p9ed2PU.png"></a></p>
<h4 id="7-参数绑定注解-requestParam"><a href="#7-参数绑定注解-requestParam" class="headerlink" title="7. 参数绑定注解@requestParam"></a>7. 参数绑定注解<code>@requestParam</code></h4><p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ewnZq"><img src="https://s1.ax1x.com/2023/04/23/p9ewnZq.png" alt="p9ewnZq.png"></a></p>
<p>​    实际意思就是，请求参数xxx与Controller中的业务方法的参数名称要不一致时，可以在Controller中的业务方法的参数名称使用<code>@requestParam(value=&quot;xxx&quot;)</code>绑定请求参数xxx，且该注解如果只有一个属性可以省略value</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9e0l7t"><img src="https://s1.ax1x.com/2023/04/23/p9e0l7t.png" alt="p9e0l7t.png"></a></p>
<h4 id="8-获得Restful风格的参数"><a href="#8-获得Restful风格的参数" class="headerlink" title="8. 获得Restful风格的参数"></a>8. 获得Restful风格的参数</h4><p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eW8SI"><img src="https://s1.ax1x.com/2023/04/23/p9eW8SI.png" alt="p9eW8SI.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eWNm8"><img src="https://s1.ax1x.com/2023/04/23/p9eWNm8.png" alt="p9eWNm8.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eWy60"><img src="https://s1.ax1x.com/2023/04/23/p9eWy60.png" alt="p9eWy60.png"></a></p>
<p>​    上述url地址/user/1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用<code>@PathVariable</code>注解进行占位符的匹配获取工作</p>
<p>​    在<code>@RequestMapping(&quot;/quick/&#123;xxxx&#125;&quot;)</code>来进行占位符的声明，用<code>@PathVariable(value=&quot;xxxx&quot;)</code>来获取占位符对应的参数，<strong>xxxx必须完全匹配</strong>，并把参数赋值给方法的形参</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9efENQ"><img src="https://s1.ax1x.com/2023/04/23/p9efENQ.png" alt="p9efENQ.png"></a></p>
<h4 id="9-自定义类型转换器"><a href="#9-自定义类型转换器" class="headerlink" title="9. 自定义类型转换器"></a>9. 自定义类型转换器</h4><p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9efqvq"><img src="https://s1.ax1x.com/2023/04/23/p9efqvq.png" alt="p9efqvq.png"></a></p>
<p><strong>自定义类型转换器的开发步骤：</strong></p>
<ol>
<li>定义转换器类实现Converter接口(SpringMVC提供的转换器接口)</li>
<li>在Spring-mvc.xml配置文件中声明转换器</li>
<li>在<code>&lt;annotation-driven&gt;</code> 中引用转换器</li>
</ol>
<p>​    <code>Converter&lt;S,T&gt;</code>接口，要实现泛型，S代表要转换前的类型，后面的T代表要转成的类型，在该接口中有一个未实现方法convert需要实现，参数是S，返回值为T</p>
<p>​    新建一个DateConverter的实现类，实现converter接口</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9e5YCQ"><img src="https://s1.ax1x.com/2023/04/23/p9e5YCQ.png" alt="p9e5YCQ.png"></a></p>
<p>​    在Spring-mvc.xml配置文件中声明转换器，<code>&lt;list&gt;</code>中为刚刚自定义转换器类的全限定名 <a target="_blank" rel="noopener" href="https://imgse.com/i/p9e5wD0"><img src="https://s1.ax1x.com/2023/04/23/p9e5wD0.png" alt="p9e5wD0.png"></a></p>
<p>​    通过指定转换器工厂帮产生日期转换器，传刚刚注入的id值</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9e5hb6"><img src="https://s1.ax1x.com/2023/04/23/p9e5hb6.png" alt="p9e5hb6.png"></a></p>
<h4 id="10-获得Servlet相关API"><a href="#10-获得Servlet相关API" class="headerlink" title="10. 获得Servlet相关API"></a>10. 获得Servlet相关API</h4><p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9e73ss"><img src="https://s1.ax1x.com/2023/04/23/p9e73ss.png" alt="p9e73ss.png"></a></p>
<p>​    获取方式为，在想要使用的方法的形参进行注入，因为方法是框架调用，所以SpringMVC框架会帮你生成引用类型对应的对象</p>
<p>​    这个知识点前面有使用过</p>
<h4 id="11-获得请求头信息"><a href="#11-获得请求头信息" class="headerlink" title="11. 获得请求头信息"></a>11. 获得请求头信息</h4><p>​    请求头是键值对形式</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ebDV1"><img src="https://s1.ax1x.com/2023/04/23/p9ebDV1.png" alt="p9ebDV1.png"></a></p>
<p>​    注意：required的取值为true或者false，表示访问资源时是否要携带指定的请求头</p>
<p>​    <strong>网页的请求头</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ebbRS"><img src="https://s1.ax1x.com/2023/04/23/p9ebbRS.png" alt="p9ebbRS.png"></a></p>
<p>​    获得请求头User-Agent请求头携带的信息，<code>@RequestHeader</code>的value对应的值要与网页的一致</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eqAsJ"><img src="https://s1.ax1x.com/2023/04/23/p9eqAsJ.png" alt="p9eqAsJ.png"></a></p>
<p>​    由于Cookie比较特殊，所以有如下注解获得Cookie对应的信息</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eqJeA"><img src="https://s1.ax1x.com/2023/04/23/p9eqJeA.png" alt="p9eqJeA.png"></a></p>
<p>​    使用<code>@CookieValue</code>获得cookie值</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eq6wn"><img src="https://s1.ax1x.com/2023/04/23/p9eq6wn.png" alt="p9eq6wn.png"></a></p>
<h4 id="12-文件上传"><a href="#12-文件上传" class="headerlink" title="12. 文件上传"></a>12. 文件上传</h4><p><strong>文件上传客户端三要素</strong></p>
<pre><code>1. 表单项`type=&quot;file&quot;`

   2. 表单的提交方式是`POST`
   3. 表单的enctype属性是多部分表单形式，及`enctype=&quot;multipart/form-data&quot;`</code></pre>
<p>​    创建upload.jsp文件，编写文件上传表单</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9mUl9g"><img src="https://s1.ax1x.com/2023/04/24/p9mUl9g.png" alt="p9mUl9g.png"></a></p>
<p><strong>文件上传原理</strong></p>
<ul>
<li>当form表单修改为多部份表单时，request.getParameter()将失效</li>
<li>enctype=<code>&quot;application/x-www-form-urlencoded&quot;</code>时，form表单的正文格式是：<code>key=value&amp;key=value&amp;key=value</code>，即键值对格式，这种方法也是form表单的默认提交格式</li>
<li>当form表单的enctype取值为Mutilpart/form-data时，请求正文内容就变成多部分形式：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ma0dP"><img src="https://s1.ax1x.com/2023/04/24/p9ma0dP.png" alt="p9ma0dP.png"></a></p>
<p><strong>单文件上传步骤</strong></p>
<pre><code>1. 导入fileupload和io坐标

   2. 配置文件上传解析器，**应该这个xml文件也是由之前的`&lt;mvc-annotation-driven&gt;`解析的，这是我的猜测待考证**
   3. 编写文件上传代码</code></pre>
<p>​    在pom.xml导入fileupload和io坐标</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9mdEwt"><img src="https://s1.ax1x.com/2023/04/24/p9mdEwt.png" alt="p9mdEwt.png"></a></p>
<p>​    在spring-mvc.xml文件中配置文件上传解析器</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9mdXcQ"><img src="https://s1.ax1x.com/2023/04/24/p9mdXcQ.png" alt="p9mdXcQ.png"></a></p>
<p>​    在后台代码中，<strong>形参设置时应该与请求参数(form表单传递过来的参数)相一致</strong>，只不过传递的文件会被SpringMVC封装为一个叫MultipartFile类型的对象，其名字应该与form表单中file的name属性值一致</p>
<p>​    在后台代码接收前面upload.jsp中form表单传递的值</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9m0QZn"><img src="https://s1.ax1x.com/2023/04/24/p9m0QZn.png" alt="p9m0QZn.png"></a></p>
<p>​    除了打印，将接收到的文件转存到磁盘某个位置(未来有服务器可以存到网络地址)，<code>getOriginaFilename()</code>作用为获得上传文件的文件名</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9mBFOJ"><img src="https://s1.ax1x.com/2023/04/24/p9mBFOJ.png" alt="p9mBFOJ.png"></a></p>
<p><strong>多文件上传步骤</strong></p>
<p>​    与单文件上传一样，注意后台形参接收时与请求参数一致就行</p>
<p>​    如果前台<code>&lt;input type=&quot;file&quot; name =&quot;xxx&quot;&gt;</code> 多个name的属性值一样，那么后台使用数组接收就行，注意：数组名应与name属性值一致</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9mB7A1"><img src="https://s1.ax1x.com/2023/04/24/p9mB7A1.png" alt="p9mB7A1.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9mBbh6"><img src="https://s1.ax1x.com/2023/04/24/p9mBbh6.png" alt="p9mBbh6.png"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/25/Spring04/" data-id="clh1gtw7s001t90wc0vvjcp1x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SSM/" rel="tag">SSM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring03" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/04/25/Spring03/" class="article-date">
  <time datetime="2023-04-25T11:24:27.000Z" itemprop="datePublished">2023-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/04/25/Spring03/">Spring03</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="监听器的使用与Spring集成Web环境"><a href="#监听器的使用与Spring集成Web环境" class="headerlink" title="监听器的使用与Spring集成Web环境"></a>监听器的使用与Spring集成Web环境</h2><h4 id="1-应用上下文的创建"><a href="#1-应用上下文的创建" class="headerlink" title="1. 应用上下文的创建"></a>1. 应用上下文的创建</h4><p>​    因为上下文对象是通过<code>new ClasspathXmlApplicationContext(Spring配置文件)</code>获得，但每一次获取Bean时都要编写一次，这样会使得上下文对象创建多次</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ipmxH"><img src="https://s1.ax1x.com/2023/04/18/p9ipmxH.png" alt="p9ipmxH.png"></a></p>
<p>​    <strong>思想：将创建上下文对象的行为放在监听器中，并由监听器存储在ServletContext域中，需要使用对象时，通过ServletContext对象向ServletContext域中获取</strong></p>
<p>​    <strong>监听器的配置</strong></p>
<p>​    新建java文件，继承实现监听servletContext的接口</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9i9MpF"><img src="https://s1.ax1x.com/2023/04/18/p9i9MpF.png" alt="p9i9MpF.png"></a></p>
<p>​    需要在web.xml文件，编写配置告知tomcat有这个监听器</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9i9JTx"><img src="https://s1.ax1x.com/2023/04/18/p9i9JTx.png" alt="p9i9JTx.png"></a></p>
<p>​    从容器中获取上下文对象</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9i9hcQ"><img src="https://s1.ax1x.com/2023/04/18/p9i9hcQ.png" alt="p9i9hcQ.png"></a></p>
<h4 id="2-监听器的优化"><a href="#2-监听器的优化" class="headerlink" title="2. 监听器的优化"></a>2. 监听器的优化</h4><p>​    使用web.xml配置**全局初始化参数<code>&lt;context-param&gt;</code> **，<code>&lt;param-name&gt;</code>写自定义的名字，<code>&lt;param-value&gt;</code> 写名字对应的值</p>
<p>​    web.xml文件配置参数</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9iCPN6"><img src="https://s1.ax1x.com/2023/04/18/p9iCPN6.png" alt="p9iCPN6.png"></a></p>
<p>​    java文件来读取参数</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9iCA3D"><img src="https://s1.ax1x.com/2023/04/18/p9iCA3D.png" alt="p9iCA3D.png"></a></p>
<p>​    新建一个工具类将具体的名字，像代码中的<code>&quot;app&quot;</code>给隐藏掉，即当需要对象时直接给对象而不是通过名字获取对象，其实本质就是把那句话变成一个方法返回值，就是一个封装</p>
<p>​    工具类封装</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EUBNQ"><img src="https://s1.ax1x.com/2023/04/21/p9EUBNQ.png" alt="p9EUBNQ.png"></a></p>
<p>​    调用类直接使用，doGet为收到GET请求后调用</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EaFDf"><img src="https://s1.ax1x.com/2023/04/21/p9EaFDf.png" alt="p9EaFDf.png"></a></p>
<h4 id="3-Spring提供上述监听器获取应用上下文工具"><a href="#3-Spring提供上述监听器获取应用上下文工具" class="headerlink" title="3. Spring提供上述监听器获取应用上下文工具"></a>3. Spring提供上述监听器获取应用上下文工具</h4><p>​    上面代码有个同名监听器是仿的，目的是要领会监听器内部的实现</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EdDln"><img src="https://s1.ax1x.com/2023/04/21/p9EdDln.png" alt="p9EdDln.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9Ed4p9"><img src="https://s1.ax1x.com/2023/04/21/p9Ed4p9.png" alt="p9Ed4p9.png"></a></p>
<p>​    在pom.xml文件导入spring-web坐标</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EdLkD"><img src="https://s1.ax1x.com/2023/04/21/p9EdLkD.png" alt="p9EdLkD.png"></a></p>
<p>​    在web.xml文件下配置监听器，并设置全局初始化参数，因为要获取的是resource下的spring的xml文件的上下文，路径为<code>classpath:XXXX.xml</code></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EwUnx"><img src="https://s1.ax1x.com/2023/04/21/p9EwUnx.png" alt="p9EwUnx.png"></a></p>
<p>​    通过调用Spring监听器对象提供的方法，如上面写的假的监听器一样，这个方法是static的，获得上下文对象</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EwvUU"><img src="https://s1.ax1x.com/2023/04/21/p9EwvUU.png" alt="p9EwvUU.png"></a></p>
<h4 id="4-SpringMVC的概述"><a href="#4-SpringMVC的概述" class="headerlink" title="4. SpringMVC的概述"></a>4. SpringMVC的概述</h4><p>​    SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架，<strong>SpringMVC是属于管项目的web层的</strong></p>
<p>​    将共有行为抽取出来，由框架封装</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9E5Xlt"><img src="https://s1.ax1x.com/2023/04/21/p9E5Xlt.png" alt="p9E5Xlt.png"></a></p>
<p>​    <strong>SpringMVC的使用</strong></p>
<pre><code>1. 导入SpringMVC包

   2. 配置Servlet，先找共有行为再找特有行为
   3. 编写POJO(普通JavaBean)，也称为Controller
   4. 通过注解把POJO放到Spring容器中
   5. 配置spring-mvc.xml文件(配置组件扫描)
   6. 执行访问测试</code></pre>
<p>​    在pom.xml文件导入SpringMVC包</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EID1I"><img src="https://s1.ax1x.com/2023/04/21/p9EID1I.png" alt="p9EID1I.png"></a></p>
<p>​    在web.xml中配置SpringMVC的前端控制器<code>&lt;servlet&gt;</code> ，<code>&lt;load-on-startup&gt;</code> 代表服务器启动时就去加载servlet，不配置则默认为第一次访问时创建对象；<code>&lt;servlet-mapping&gt;</code>为映射地址，  <code>&lt;url-pattern&gt;/&lt;url-pattern&gt;</code>，这个<code>/</code>表示缺省的servlet，即每次访问任何请求都要走这个servlet，也有<code>*.xxx</code>为扩展名为<code>*.xxx</code>时才走这个servlet</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EI53n"><img src="https://s1.ax1x.com/2023/04/21/p9EI53n.png" alt="p9EI53n.png"></a></p>
<p>​    创建Controller的Java包，return后接要跳转的jsp，用注解将UserController存入spring容器中，注解<code>@RequestMapping(&quot;/quick&quot;)</code>为请求映射，当访问quick时映射到save方法，执行方法的逻辑</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EHSvn"><img src="https://s1.ax1x.com/2023/04/21/p9EHSvn.png" alt="p9EHSvn.png"></a></p>
<p>​    创建Spring的xml文件，进行组件扫描    </p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9E7HDP"><img src="https://s1.ax1x.com/2023/04/21/p9E7HDP.png" alt="p9E7HDP.png"></a></p>
<p>​    配置组件扫描的这个xml文件没有加载，所以最先是<code>new ClassPathXmlApplicationContext(&quot;参数为resource文件夹的xml文件路径&quot;)</code>，限制是spring，所以只需要在前端控制器声明有这个配置文件，<code>&lt;init-param&gt;</code> 代表servlet在初始化时执行，<code>&lt;param-name&gt;</code> 是监听器的名字，<code>&lt;param-value&gt;</code> 是路径</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EHart"><img src="https://s1.ax1x.com/2023/04/21/p9EHart.png" alt="p9EHart.png"></a></p>
<h4 id="5-SpringMVC的执行流程解析"><a href="#5-SpringMVC的执行流程解析" class="headerlink" title="5. SpringMVC的执行流程解析"></a>5. SpringMVC的执行流程解析</h4><p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9VNbaF"><img src="https://s1.ax1x.com/2023/04/22/p9VNbaF.png" alt="p9VNbaF.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9VNzKx"><img src="https://s1.ax1x.com/2023/04/22/p9VNzKx.png" alt="p9VNzKx.png"></a></p>
<h4 id="6-SpringMVC的组件解析"><a href="#6-SpringMVC的组件解析" class="headerlink" title="6. SpringMVC的组件解析"></a>6. SpringMVC的组件解析</h4><p><code>@RequestMapping</code></p>
<p><strong>作用：</strong>用于建立请求URL和处理请求方法之间的对应关系</p>
<p><strong>位置：</strong></p>
<ul>
<li><p>类上，请求URL的第一级访问目录，此处不写的话，就相当于根目录</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9VaD78"><img src="https://s1.ax1x.com/2023/04/22/p9VaD78.png" alt="p9VaD78.png"></a></p>
</li>
<li><p>方法上，请求URL的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9VaOj1"><img src="https://s1.ax1x.com/2023/04/22/p9VaOj1.png" alt="p9VaOj1.png"></a></p>
<p>这个方式是为了区分是哪个模块的方法，此时return方法返回的是<code>http://localhost:8080/xxx/</code>下的<code>success.jsp</code>页面，如果jsp文件路径不对会报404，可以改为带<code>/success.jsp</code>表示要在当前web应用下找这个资源</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9Vd25D"><img src="https://s1.ax1x.com/2023/04/22/p9Vd25D.png" alt="p9Vd25D.png"></a></p>
</li>
</ul>
<p><strong>属性：</strong></p>
<ul>
<li>value：用于指定请求的URL，在只有value的情况下可以省略，但多个属性不能省如上面代码完整的应该为<code>@RequestMapping(value=&quot;/quick&quot;)</code></li>
<li>method：用于指定请求的方式，默认是GET，如果要改为POST，它存储方式是枚举类型为<code>@RequestMapping(value=&quot;/quick&quot;,method=RequestMethod.POST)</code>，注意：jsp表单提交是GET类型的，设置成POST会报错</li>
<li>params：用于指定限制请求参数的条件，它支持简单的表达式，要求请求参数的key和value必须和配置的一模一样<ul>
<li><code>params=&#123;&quot;accountName&quot;&#125;</code>，表示请求参数必须有accountName，没有这个参数则该资源不能被你访问</li>
<li><code>params=&#123;&quot;money!100&quot;&#125;</code>，表示请求参数中money不能是100</li>
</ul>
</li>
</ul>
<h4 id="7-SpringMVC的组件扫描"><a href="#7-SpringMVC的组件扫描" class="headerlink" title="7. SpringMVC的组件扫描"></a>7. SpringMVC的组件扫描</h4><p>​    springMVC是管理web层的，所以组件扫描时，只扫描web层相关，而其他的像dao层、service层归Spring来扫描</p>
<p>​    为了让只扫springmvc，可以在其配置的xml文件中进行如下设置</p>
<p>​    <code>include-filter</code>表示包括如果改为<code>exclude-filter</code>表示不包括，<code>type=&quot;annotation&quot;</code>表示扫描类型为注解，expression=”注解的全限定名”</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9V0b9g"><img src="https://s1.ax1x.com/2023/04/22/p9V0b9g.png" alt="p9V0b9g.png"></a></p>
<h4 id="8-SpringMVC的xml文件配置"><a href="#8-SpringMVC的xml文件配置" class="headerlink" title="8. SpringMVC的xml文件配置"></a>8. SpringMVC的xml文件配置</h4><p>​    有点难，可以反复看<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1WZ4y1P7Bp/?p=49&spm_id_from=pageDriver&vd_source=41e90cead08809b70890e8713c58ac8b">13-SpringMVC组件解析-SpringMVC的XML配置解析（资源解析器）_哔哩哔哩_bilibili</a></p>
<p>​    可以自行配置视图解析器，配置完后方法return时指定页面就可以少写页面的前缀和后缀</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9VBXGD"><img src="https://s1.ax1x.com/2023/04/22/p9VBXGD.png" alt="p9VBXGD.png"></a></p>
<h4 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h4><p>​    <a target="_blank" rel="noopener" href="https://imgse.com/i/p9VDMd0"><img src="https://s1.ax1x.com/2023/04/22/p9VDMd0.png" alt="p9VDMd0.png"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/25/Spring03/" data-id="clh1gtw7s001q90wcc4cp1fr2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SSM/" rel="tag">SSM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/04/25/Spring02/" class="article-date">
  <time datetime="2023-04-25T11:22:16.000Z" itemprop="datePublished">2023-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/04/25/Spring02/">Spring02</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数据库连接池与Spring注解"><a href="#数据库连接池与Spring注解" class="headerlink" title="数据库连接池与Spring注解"></a>数据库连接池与Spring注解</h2><h4 id="1-数据源-连接池-的作用"><a href="#1-数据源-连接池-的作用" class="headerlink" title="1. 数据源(连接池)的作用"></a>1. 数据源(连接池)的作用</h4><ul>
<li>提高程序性能</li>
<li>实例化数据源，初始化部分连接资源</li>
<li>使用连接资源时从数据源中获取</li>
<li>使用完毕后连接资源归还给数据源</li>
</ul>
<p>​    常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等</p>
<h4 id="2-数据源的开发步骤"><a href="#2-数据源的开发步骤" class="headerlink" title="2. 数据源的开发步骤"></a>2. 数据源的开发步骤</h4><pre><code>1. 导入数据源的坐标(jar)和数据库驱动坐标(jar)
   2. 创建数据源对象
   3. 设置数据源的基本连接数据库的数据
   4. 使用数据源获取连接资源和归还连接资源</code></pre>
<p>​    在pom.xml文件中导入坐标，mysql、c3p0、druid</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppOCFxS"><img src="https://s1.ax1x.com/2023/04/11/ppOCFxS.png" alt="ppOCFxS.png"></a></p>
<p>​    在java代码，创建c3p0数据源对象，以及给对应数据库的参数，获取数据库连接对象</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppOCdG6"><img src="https://s1.ax1x.com/2023/04/11/ppOCdG6.png" alt="ppOCdG6.png"></a></p>
<p>​    番外：创建druid数据源对象</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppOCHds"><img src="https://s1.ax1x.com/2023/04/11/ppOCHds.png" alt="ppOCHds.png"></a></p>
<h4 id="3-数据库参数的提取"><a href="#3-数据库参数的提取" class="headerlink" title="3. 数据库参数的提取"></a>3. 数据库参数的提取</h4><p>​    在上述数据库配置时，代码是耦合的，为了降低耦合需要将数据库参数字符串单独提取到一个(<code>XXXXX.properties</code>)文件存放</p>
<p>​    在resource文件夹下创建jdbc.properties文件</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppjkMkQ"><img src="https://s1.ax1x.com/2023/04/12/ppjkMkQ.png" alt="ppjkMkQ.png"></a></p>
<p>​    加载.properties文件来连接数据库，通过Java提供的ResourceBundle类以及该类提供的getBundle(“.properties文件的类加载路径，且该文件不需要写扩展名”)方法，来导入.properties文件。通过ResourceBundle对象的getString(“.properties文件中定义的key值”)，来获得对应的字符串</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppjA7G9"><img src="https://s1.ax1x.com/2023/04/12/ppjA7G9.png" alt="ppjA7G9.png"></a></p>
<h4 id="4-Spring产生数据源对象"><a href="#4-Spring产生数据源对象" class="headerlink" title="4. Spring产生数据源对象"></a>4. Spring产生数据源对象</h4><p>​    对于c3p0连接池的对象dataSource的创建使用Spring容器完成</p>
<p>​    创建xml文件把CombopooledDataSource类进行注入，并通过类中已编写的set方法(该类为第三方jar包的)注入参数</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppjEfSA"><img src="https://s1.ax1x.com/2023/04/12/ppjEfSA.png" alt="ppjEfSA.png"></a></p>
<p>​    java文件完成对Spring的加载以及对数据库对象的打印</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppjVV61"><img src="https://s1.ax1x.com/2023/04/12/ppjVV61.png" alt="ppjVV61.png"></a></p>
<h4 id="5-进一步优化，Spring抽取jdbc配置文件"><a href="#5-进一步优化，Spring抽取jdbc配置文件" class="headerlink" title="5. 进一步优化，Spring抽取jdbc配置文件"></a>5. 进一步优化，Spring抽取jdbc配置文件</h4><p>​     在spring的xml文件中加载.properties文件获得连接信息</p>
<p>​    需要引入命名空间(beans标签下直接引入)和约束路径(在属性<code>xsi:schemaLocation</code>下作为属性值引入)</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppz0y8S"><img src="https://s1.ax1x.com/2023/04/14/ppz0y8S.png" alt="ppz0y8S.png"></a></p>
<p>​    加载properties文件，其中<code>classpath:</code>表示该文件在类加载路径下</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppzBZIP"><img src="https://s1.ax1x.com/2023/04/14/ppzBZIP.png" alt="ppzBZIP.png"></a></p>
<p>​    引入.properties文件中对应的值，通过<code>$&#123;&#125;</code>来引入</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppzBvLj"><img src="https://s1.ax1x.com/2023/04/14/ppzBvLj.png" alt="ppzBvLj.png"></a></p>
<h4 id="6-Spring注解开发"><a href="#6-Spring注解开发" class="headerlink" title="6. Spring注解开发"></a>6. Spring注解开发</h4><p>​    Spring是轻代码重配置的框架，配置比较繁重影响开发效率，所以注解开发时一种趋势，注解代替xml配置文件可以简化配置，提高开发效率</p>
<h4 id="7-Spring的原始注解-老一点注解"><a href="#7-Spring的原始注解-老一点注解" class="headerlink" title="7. Spring的原始注解(老一点注解)"></a>7. Spring的原始注解(老一点注解)</h4><p>​    Spring原始注解主要是代替<code>&lt;Bean&gt;</code> 的配置</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9SdWjJ"><img src="https://s1.ax1x.com/2023/04/14/p9SdWjJ.png" alt="p9SdWjJ.png"></a></p>
<p>​    <strong>使用原始注解可以对xml文件内编写的内容进行替代，如果要使用注解需要在Spring的xml文件中进行声明</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9pMbDS"><img src="https://s1.ax1x.com/2023/04/15/p9pMbDS.png" alt="p9pMbDS.png"></a></p>
<p>​    <code>base-package=&quot;包名&quot;</code>，其会扫描该包下所有的子包，包下所有使用了注解的都会被扫描到</p>
<p>​    使用注解<code>@Component（&quot;唯一标识&quot;）</code>等同于对xml文件中的bean的配置，在需要Spring配置的类的上方写注解</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9pKqYR"><img src="https://s1.ax1x.com/2023/04/15/p9pKqYR.png" alt="p9pKqYR.png"></a></p>
<p>​    如果需要进行注入，则可以使用<code>@Autowired</code>和<code>@Qualifier(&quot;要注入的对象&quot;)</code>进行注入，注入代码需要写在类的里面</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9pMJXT"><img src="https://s1.ax1x.com/2023/04/15/p9pMJXT.png" alt="p9pMJXT.png"></a></p>
<p>​    在Spring的xml文件中配置组件扫描</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9pQ85d"><img src="https://s1.ax1x.com/2023/04/15/p9pQ85d.png" alt="p9pQ85d.png"></a></p>
<h4 id="8-原始注解详解"><a href="#8-原始注解详解" class="headerlink" title="8. 原始注解详解"></a>8. 原始注解详解</h4><p><strong>1. 代码的可读性</strong></p>
<p>​    在不同的层中都使用@Component会造成代码可读性下降，为了让可读性增加有了<code>@Controller</code>—web层；<code>@Service</code>—service层；<code>@Repository</code>—dao层，功能都是一样的只是方便读代码</p>
<p><strong>2. set方法的省略</strong></p>
<p>​    如果使用的是注解方式进行Spring配置，则可以省略set方法，因为注解直接写在java文件的属性上，所以不需要为属性再写set方法</p>
<p>​    </p>
<p><strong>3. <code>@Autowired</code>和<code>@Qualifier</code>的区别，以及注解<code>@Resource</code></strong></p>
<p>​    <code>@Autowired</code>是按照数据类型从Spring容器中进行匹配</p>
<p>​    如下面代码，其会在Spring容器中寻找一个UserDao类型的对象赋值给变量userDao</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure>



<p>​    <code>@Qualifier</code>是按照id值从容器中进行匹配，但其要结合<code>@Autowired</code>一起使用</p>
<p>​    <code>@Resource(name=&quot;id值&quot;)</code>，其相当于上述两个注解一起使用</p>
<p><strong>4. <code>@Value</code></strong></p>
<p>​    <code>@Value(&quot;要注入的值&quot;)</code>是对常量数据进行注入</p>
<p>​    对变量driver进行注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;itcast&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String driver;</span><br></pre></td></tr></table></figure>

<p>​    除了注入常量还可以注入键值对，只要Spring容器中加载了.properties文件就可以直接通过<code>$&#123;&#125;</code>进行注入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;jdbc.drive&#125;&quot;)</span><br><span class="line">private String driver;</span><br></pre></td></tr></table></figure>



<p><strong>5. <code>@Scope</code></strong></p>
<p>​    <code>@Scope(&quot;属性值&quot;)</code>，具体属性值见笔记<code>Spring01.md</code>，其写在类的上方，用来指定<code>&lt;bean&gt;</code> 是可以创造单例还是多例</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9pyj3t"><img src="https://s1.ax1x.com/2023/04/15/p9pyj3t.png" alt="p9pyj3t.png"></a></p>
<p><strong>6. <code>@PostConstruct</code>和<code>@preDestroy</code></strong></p>
<p>​    写在类中的方法前，表示对象在创建或者销毁时要执行的方法</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9p6l59"><img src="https://s1.ax1x.com/2023/04/15/p9p6l59.png" alt="p9p6l59.png"></a></p>
<h4 id="9-Spring新注解"><a href="#9-Spring新注解" class="headerlink" title="9. Spring新注解"></a>9. Spring新注解</h4><p>​    原始注解不能完全代替xml配置文件，还需要使用注解替代的配置如下：</p>
<ul>
<li>非自定义的Bean的配置：如第三方jar包中的类</li>
<li>加载properties文件的配置：<code>&lt;context:property-placeholder&gt;</code></li>
<li>组件扫描的配置：<code>&lt;context:component-scan&gt;</code></li>
<li>引入其他文件：<code>&lt;import&gt;</code> </li>
</ul>
<p>​    Spring新注解 </p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9p6xi9"><img src="https://s1.ax1x.com/2023/04/15/p9p6xi9.png" alt="p9p6xi9.png"></a></p>
<h4 id="10-Spring新注解详解"><a href="#10-Spring新注解详解" class="headerlink" title="10. Spring新注解详解"></a>10. Spring新注解详解</h4><p>​    通过新建一个java类并在类中使用新注解来替代spring的xml文件</p>
<p><strong>1. <code>@Configuration</code></strong></p>
<p>​    写在类前标志该类为Spring核心配置类</p>
<p><strong>2. <code>@ComponentScan(&quot;包名&quot;)</code></strong></p>
<p>​    相当于xml文件中的配置组件扫描</p>
<p><strong>3. <code>@PropertySource(&quot;路径&quot;)</code></strong></p>
<p>​    <code>@PropertySource(&quot;路径&quot;)</code>为导入.properties文件到Spring容器中</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p99RpcR"><img src="https://s1.ax1x.com/2023/04/16/p99RpcR.png" alt="p99RpcR.png"></a></p>
<p><strong>4. <code>@Bean(&quot;自己设定的id&quot;)</code></strong></p>
<p>​    <code>@Bean(&quot;自己设定的id&quot;)</code>写在方法前，用于将当前方法的返回值以自己设定的id名称存储到Spring容器中</p>
<p>​    下图代码已经将.properties文件抽取到Spring容器中，但是<code>$&#123;&#125;</code>是在xml文件中才可以这样写，所以需要使用<code>@value</code>来获取.properties文件的值，这个代码返回了数据库连接池c3p0的对象</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p99RqxA"><img src="https://s1.ax1x.com/2023/04/16/p99RqxA.png" alt="p99RqxA.png"></a></p>
<p><strong>5. <code>@Import(&quot;需要加载的类的名字.class&quot;)</code></strong></p>
<p>​    其本质是一个数组，可以一次多个添加</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p99Wco8"><img src="https://s1.ax1x.com/2023/04/16/p99Wco8.png" alt="p99Wco8.png"></a></p>
<h4 id="11-main方法对于使用注解-配置类-后的加载"><a href="#11-main方法对于使用注解-配置类-后的加载" class="headerlink" title="11. main方法对于使用注解(配置类)后的加载"></a>11. main方法对于使用注解(配置类)后的加载</h4><p>​    因为之前充当web测试的main方法它引入的是xml文件，所以应改为<code>AnnotationConfigApplicationContext(要引入的类名.class)</code></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p99f9w6"><img src="https://s1.ax1x.com/2023/04/16/p99f9w6.png" alt="p99f9w6.png"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/25/Spring02/" data-id="clh1gtw7q001p90wc34n23d3e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SSM/" rel="tag">SSM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Spring01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/04/25/Spring01/" class="article-date">
  <time datetime="2023-04-25T11:20:13.000Z" itemprop="datePublished">2023-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/04/25/Spring01/">Spring01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Spring开发入门"><a href="#Spring开发入门" class="headerlink" title="Spring开发入门"></a>Spring开发入门</h2><h4 id="1-传统Javaweb开发的困惑与解决方案"><a href="#1-传统Javaweb开发的困惑与解决方案" class="headerlink" title="1. 传统Javaweb开发的困惑与解决方案"></a>1. 传统Javaweb开发的困惑与解决方案</h4><p>问题1：传统javaweb的开发中对于数据的操作，往往都需要new对象来完成操作</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppbxDFU"><img src="https://s1.ax1x.com/2023/04/10/ppbxDFU.png" alt="ppbxDFU.png"></a></p>
<pre><code>解决思路：程序代码中不去new对象，第三方根据要求为程序提供需要的Bean对象</code></pre>
<p>问题2：事物功能、日志功能耦合在业务代码中</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppbxrYF"><img src="https://s1.ax1x.com/2023/04/10/ppbxrYF.png" alt="ppbxrYF.png"></a></p>
<pre><code>解决思路：第三方提供Bean对象的**代理对象(BeanProxy)**，该对象是对Bean的增强，可以完成事物操作</code></pre>
<h4 id="2-IoC、DI、AOP思想"><a href="#2-IoC、DI、AOP思想" class="headerlink" title="2. IoC、DI、AOP思想"></a>2. IoC、DI、AOP思想</h4><pre><code>IoC思想：控制反转，强调的是原来在程序中创建Bean的权利反转给第三方

DI思想：依赖注入，强调的Bean之间关系，这种关系第三方负责去设置

AOP思想：面向切面编程，功能的横向抽取，主要的实现方式是Proxy。(面向对象编程是纵向设计一个Bean)</code></pre>
<h4 id="3-框架概念"><a href="#3-框架概念" class="headerlink" title="3. 框架概念"></a>3. 框架概念</h4><pre><code>框架是基于基础技术之上，从众多业务中抽取出的通用解决方案，可以提升开发效率，并且框架具备扩展性</code></pre>
<h4 id="4-Spring的简介"><a href="#4-Spring的简介" class="headerlink" title="4.Spring的简介"></a>4.Spring的简介</h4><pre><code>spring是分层的JavaSE/EE应用full-stack轻量级开源框架，以Ioc(反转控制)和AOP(面向切面编程)为内核</code></pre>
<h4 id="5-Spring程序开发步骤"><a href="#5-Spring程序开发步骤" class="headerlink" title="5. Spring程序开发步骤"></a>5. Spring程序开发步骤</h4><pre><code>在jsp/servlet中，会用接口来引用接口实现的对象。

对于Spring开发，会在xml配置文件中用id标识来获取接口实现类全限定名，而后接口类通过Spring框架读取xml文件根据标识来获取对象，如下图所示</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppb9xOA"><img src="https://s1.ax1x.com/2023/04/09/ppb9xOA.png" alt="ppb9xOA.png"></a></p>
<pre><code>步骤总结：

1. 通过maven导入Spring开发的基本包坐标
 2. 编写Dao接口和实现类
 3. 创建Spring核心配置文件，在main/resources/创建xml文件
 4. 在Spring配置文件中配置UserDaoImpl
 5. 使用Spring的API获得Bean实例</code></pre>
<h4 id="6-Spring配置文件xml的介绍"><a href="#6-Spring配置文件xml的介绍" class="headerlink" title="6.Spring配置文件xml的介绍"></a>6.Spring配置文件xml的介绍</h4><h5 id="1-Bean标签基本配置"><a href="#1-Bean标签基本配置" class="headerlink" title="(1)Bean标签基本配置"></a>(1)Bean标签基本配置</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;唯一标识&quot; class=&quot;类的全限定名&quot;&gt;&lt;/bean&gt; //bean和class是基本属性</span><br></pre></td></tr></table></figure>

<pre><code>默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功</code></pre>
<h5 id="2-Bean标签的范围配置"><a href="#2-Bean标签的范围配置" class="headerlink" title="(2)Bean标签的范围配置"></a>(2)Bean标签的范围配置</h5><pre><code>属性  scope：指对象的作用范围，取值如下：</code></pre>
<table>
<thead>
<tr>
<th align="center">属性值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>singleton</strong></td>
<td align="center"><strong>默认值，单例</strong></td>
</tr>
<tr>
<td align="center"><strong>prototype</strong></td>
<td align="center"><strong>多例</strong></td>
</tr>
<tr>
<td align="center">request</td>
<td align="center">WEB项目中，Spring创建一个Bean的对象，将对象存入到request域中</td>
</tr>
<tr>
<td align="center">session</td>
<td align="center">WEB项目中，Spring创建一个Bean的对象，将对象存入到session域中</td>
</tr>
<tr>
<td align="center">global session</td>
<td align="center">WEB项目中，应用在Portlet环境，如果没有Portlet环境那么global session相当于session</td>
</tr>
</tbody></table>
<p>单例和多例的区别：</p>
<pre><code>单例是不管getBean(&quot;id&quot;)获取几次，都是同一地址的对象，多例获取几次，就创造几个对象，详细如下图所示</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppb8rIf"><img src="https://s1.ax1x.com/2023/04/09/ppb8rIf.png" alt="ppb8rIf.png"></a></p>
<h5 id="3-Bean生命周期的配置"><a href="#3-Bean生命周期的配置" class="headerlink" title="(3)Bean生命周期的配置"></a>(3)Bean生命周期的配置</h5><pre><code>属性  init-method：指定类中的初始化方法名称

属性  destroy-method：指定类中销毁方法名称

这些要指定的方法需要在接口实现类中编写，在使用bean标签加载时指定</code></pre>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;唯一标识&quot; class=&quot;类的全限定名&quot; init-method=&quot;bean初始化要执行的方法名&quot; destroy-method=&quot;bean销毁时要执行的方法名&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<pre><code>bean的创建是在main函数中用Spring的API创建</code></pre>
<h5 id="4-Bean实例化三种方法"><a href="#4-Bean实例化三种方法" class="headerlink" title="(4)Bean实例化三种方法"></a>(4)Bean实例化三种方法</h5><ul>
<li><p><strong>无参构造方法实例化</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;给接口类起的唯一标识名&quot; class=&quot;该接口实现类的全限定名&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>工厂静态方法实例化</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;给接口起的唯一标识名&quot; class=&quot;工厂类的全限定名&quot; factory-method=&quot;工厂类中返回该接口实现类的静态方法的名字&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>工厂实例方法实例化</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;给工厂类起的唯一标识名&quot; class=&quot;工厂类的全限定名&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;给接口起的唯一标识名&quot; factory-bean=&quot;给工厂类起的唯一标识名&quot; factory-method=&quot;工厂类中返回该接口实现类的动态方法的名字&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<pre><code>工厂方式实例化在JDBC获取时会使用到，但重点还是应该深入了解无参构造方法实例化</code></pre>
<h4 id="7-Bean的依赖注入"><a href="#7-Bean的依赖注入" class="headerlink" title="7. Bean的依赖注入"></a>7. Bean的依赖注入</h4><h5 id="1-从spring容器外部获取"><a href="#1-从spring容器外部获取" class="headerlink" title="1.从spring容器外部获取"></a>1.从spring容器外部获取</h5><p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppql3kT"><img src="https://s1.ax1x.com/2023/04/10/ppql3kT.png" alt="ppql3kT.png"></a></p>
<pre><code>在项目中会写service层调用dao层的实例，可以在编写service方法时，用spring获取dao类的实例，通过实例调用dao层的方法。

这个操作相当于在Spring容器外将Dao组装到service内部完成操作</code></pre>
<h5 id="2-从spring容器内部注入-依赖注入"><a href="#2-从spring容器内部注入-依赖注入" class="headerlink" title="2. 从spring容器内部注入(依赖注入)"></a>2. 从spring容器内部注入(依赖注入)</h5><p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppqln6s"><img src="https://s1.ax1x.com/2023/04/10/ppqln6s.png" alt="ppqln6s.png"></a></p>
<p><strong>两种注入方法</strong></p>
<p><strong>(1)使用set方法注入：</strong></p>
<pre><code>需要设置service层获得spring的对象，设置spring.xml文件将dao层对象注入，核心是编写xml文件完成注入

service层的实现中需要编写一个私有的dao的对象，并且编写setXxxx方法将私有dao对象赋值</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppq1MgH"><img src="https://s1.ax1x.com/2023/04/10/ppq1MgH.png" alt="ppq1MgH.png"></a></p>
<pre><code>spring的xml文件中的注入代码`property`的`name`属性写之前service层中setXxxx方法的xxxx(注意大小写)，ref属性写要注入的类的id</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppq3VMj"><img src="https://s1.ax1x.com/2023/04/10/ppq3VMj.png" alt="ppq3VMj.png"></a></p>
<pre><code>番外：`property`可以用p命名空间注入简化，引入命名空间是在`beans`标签引入</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppq89X9"><img src="https://s1.ax1x.com/2023/04/10/ppq89X9.png" alt="ppq89X9.png"></a></p>
<pre><code>所以上面spring的xml文件的代码也可以改为</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppq83AP"><img src="https://s1.ax1x.com/2023/04/10/ppq83AP.png" alt="ppq83AP.png"></a></p>
<p><strong>(2)使用有参构造方法注入：</strong></p>
<pre><code>service层的实现中需要编写一个私有的dao的对象，并且编写有参构造方法在构造时对私有dao对象赋值，同时为了编码规范应该在声明无参构造方法</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppqHEUH"><img src="https://s1.ax1x.com/2023/04/10/ppqHEUH.png" alt="ppqHEUH.png"></a></p>
<pre><code>在spring的xml文件中完成注入，其中`constructor-arg`中的`name`属性值为上面构造方法的参数名，ref属性写要注入的类的id</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppqH8aQ"><img src="https://s1.ax1x.com/2023/04/10/ppqH8aQ.png" alt="ppqH8aQ.png"></a></p>
<h5 id="3-补充：依赖注入的概念"><a href="#3-补充：依赖注入的概念" class="headerlink" title="3.补充：依赖注入的概念"></a>3.补充：依赖注入的概念</h5><p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppqlc1H"><img src="https://s1.ax1x.com/2023/04/10/ppqlc1H.png" alt="ppqlc1H.png"></a></p>
<h4 id="8-Bean的依赖注入的数据类型"><a href="#8-Bean的依赖注入的数据类型" class="headerlink" title="8. Bean的依赖注入的数据类型"></a>8. Bean的依赖注入的数据类型</h4><pre><code>除对象的引用可以注入，普通数据类型，集合都可以在容器中进行注入(用set或者构造方法)</code></pre>
<h5 id="1-普通数据类型的注入"><a href="#1-普通数据类型的注入" class="headerlink" title="1.普通数据类型的注入"></a>1.普通数据类型的注入</h5><pre><code>在dao的实现类中，建立成员变量，编写set方法</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppqHqzt"><img src="https://s1.ax1x.com/2023/04/10/ppqHqzt.png" alt="ppqHqzt.png"></a></p>
<pre><code>在spring的xml文件完成注入，name属性值为set后面一串首字母小写，因为是普通数据类型用value赋值</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppqHjL8"><img src="https://s1.ax1x.com/2023/04/10/ppqHjL8.png" alt="ppqHjL8.png"></a></p>
<h5 id="2-集合的注入"><a href="#2-集合的注入" class="headerlink" title="2.集合的注入"></a>2.集合的注入</h5><pre><code>在dao的实现类中，建立成员变量，编写set方法</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppqqC7D"><img src="https://s1.ax1x.com/2023/04/10/ppqqC7D.png" alt="ppqqC7D.png"></a></p>
<pre><code>在spring的xml文件完成注入，name属性值为set后面一串首字母小写，因为值比较特殊需要在`property`内部设置值，在其内部有子标签</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppqqaHU"><img src="https://s1.ax1x.com/2023/04/10/ppqqaHU.png" alt="ppqqaHU.png"></a></p>
<pre><code>而后通过子标签配置值，如list标签设置为下图所示，其余两个略</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppqq2DK"><img src="https://s1.ax1x.com/2023/04/10/ppqq2DK.png" alt="ppqq2DK.png"></a></p>
<h4 id="9-Spring配置文件的import标签"><a href="#9-Spring配置文件的import标签" class="headerlink" title="9.Spring配置文件的import标签"></a>9.Spring配置文件的import标签</h4><pre><code>项目中的不同模块需要拆分，此时要在主配置文件引入这些模块需要使用import标签进行加载

语法：resource属性值为要引入的Spring配置文件的位置</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">import</span> resource=<span class="string">&quot;applicationContext-xxx.xml&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<pre><code>当主文件加载时，分文件也会被加载

[![ppLLaXq.png](https://s1.ax1x.com/2023/04/11/ppLLaXq.png)](https://imgse.com/i/ppLLaXq)</code></pre>
<h4 id="10-小结"><a href="#10-小结" class="headerlink" title="10. 小结"></a>10. 小结</h4><p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppLOigs"><img src="https://s1.ax1x.com/2023/04/11/ppLOigs.png" alt="ppLOigs.png"></a></p>
<h4 id="11-Spring相关API"><a href="#11-Spring相关API" class="headerlink" title="11. Spring相关API"></a>11. Spring相关API</h4><p><strong>1. ApplicationContext继承体系</strong></p>
<pre><code>applicationContext：接口类型，可以通过其实例获得Spring容器的Bean对象</code></pre>
<p>​    </p>
<p><strong>2. ApplicationContext的实现类</strong></p>
<pre><code>(1).ClassPathXmlApplicationContext(&quot;参数为resource文件夹的xml文件路径&quot;)

    它是从类的根路径下加载配置文件(推荐使用)

(2).FileSystemXmlApplicationContext(&quot;参数为xml文件在电脑中的磁盘路径&quot;)

    它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置

(3).AnnotationConfigApplicationContext

    当使用注解配置容器对象时，需要使用此类来创建spring容器，它用来读取注解(之后再学)</code></pre>
<p><strong>3. getBean()方法使用</strong></p>
<pre><code>getBean()的API文档</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppLjplj"><img src="https://s1.ax1x.com/2023/04/11/ppLjplj.png" alt="ppLjplj.png"></a></p>
<pre><code>第一个是上面使用过的，传递的是xml文件中设置的id值

第二个是传字节码对象类型(xxxx.class)

第一个允许出现相同类型的bean因为可以用id进行区分，第二个只能由一种类型的bean



相同效果的两种方式的代码编写</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppLjXuR"><img src="https://s1.ax1x.com/2023/04/11/ppLjXuR.png" alt="ppLjXuR.png"></a></p>
<pre><code>这个UserService是接口类，等于是获得接口类的反射</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/25/Spring01/" data-id="clh1gtw7p001m90wc0ek534bb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SSM/" rel="tag">SSM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-生日-个人提升计划2023" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/11/%E7%94%9F%E6%97%A5-%E4%B8%AA%E4%BA%BA%E6%8F%90%E5%8D%87%E8%AE%A1%E5%88%922023/" class="article-date">
  <time datetime="2022-12-11T09:06:20.000Z" itemprop="datePublished">2022-12-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/11/%E7%94%9F%E6%97%A5-%E4%B8%AA%E4%BA%BA%E6%8F%90%E5%8D%87%E8%AE%A1%E5%88%922023/">生日-个人提升计划2023</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Personal-Development-Plan-2023"><a href="#Personal-Development-Plan-2023" class="headerlink" title="Personal Development Plan-2023"></a>Personal Development Plan-2023</h4><ol>
<li><p>少打农</p>
</li>
<li><p>恢复睡眠，提升卫生习惯</p>
</li>
<li><p>改掉话痨</p>
</li>
<li><p>使用“了”和“吧”优先级下调</p>
</li>
<li><p>约束日常消费</p>
</li>
<li><p>明年这时有能力帮助一些山区学生</p>
</li>
<li><p>牢记20大会议精神，始终坚持两个维护</p>
</li>
<li><p>不要和烂尾大帝学烂尾</p>
</li>
<li><p>下行承压，控制情绪</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/11/%E7%94%9F%E6%97%A5-%E4%B8%AA%E4%BA%BA%E6%8F%90%E5%8D%87%E8%AE%A1%E5%88%922023/" data-id="clh1gtw8m004790wc2y3y11uq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9D%82%E8%AE%B0/" rel="tag">杂记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构05" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8405/" class="article-date">
  <time datetime="2022-12-03T07:22:01.000Z" itemprop="datePublished">2022-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8405/">数据结构05</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列(queue)"></a>队列(queue)</h2><h4 id="1-队列的概念"><a href="#1-队列的概念" class="headerlink" title="1. 队列的概念"></a>1. 队列的概念</h4><p>​    一种可以实现“先进先出”的存储结构，不能在中间插入，只能在一端入，另一端出，入的那端不能出，出的那端不能入</p>
<h4 id="2-队列的分类"><a href="#2-队列的分类" class="headerlink" title="2.队列的分类"></a>2.队列的分类</h4><ul>
<li><p>链式队列    –用链表实现</p>
</li>
<li><p>数组队列    –用动态数组实现、</p>
<p>​    使用数组来实现队列通常都必须是循环队列</p>
</li>
</ul>
<p>​    规定：在队首(front)删除元素，在队尾(rear)加入元素，定义两个变量：front指向队首的第一个元素，rear指向队尾元素的下一个元素</p>
<p>​    图示如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/z8QyZR"><img src="https://s1.ax1x.com/2022/11/23/z8QyZR.png" alt="z8QyZR.png"></a></p>
<p>​    注意：错开设置是为了方便对队列进行操作，就像链表pHead指向第一个元素的前一个不存储数据的头结点，pTail指向最后一个结点一样</p>
<h4 id="3-循环队列"><a href="#3-循环队列" class="headerlink" title="3. 循环队列"></a>3. 循环队列</h4><p><strong>(1). 使用数组来实现队列为什么必须为循环队列</strong></p>
<p>​     当插入元素或者删除元素时，front和rear都是向后移动，此时前面的数组空间都无法使用即被浪费了，所以需要使用循环队列来减少空间浪费</p>
<p>​    当front或rear指向最后一个元素，且还要再往后移时，此时需要将其指向第一个元素，这样的设计就是一个循环队列</p>
<p><strong>(2).循环队列需要几个参数来确定，以及参数的含义</strong></p>
<p>​    需要两个参数来确定：front、rear</p>
<p>​    这两个参数不同场合有不同的含义</p>
<ol>
<li><p>队列初始化</p>
<p>front和rear的值都是0</p>
</li>
<li><p>队列非空</p>
<p>front代表队列的第一个元素</p>
<p>rear代表队列的最后一个有效元素的下一个元素</p>
</li>
<li><p>队列空</p>
<p>front和rear的值相等，但不一定就是为0</p>
</li>
</ol>
<p><strong>(3).循环队列入队的伪算法</strong></p>
<ol>
<li><p>将值存入rear所指向的位置</p>
</li>
<li><p>rear = (rear + 1)%数组的长度</p>
</li>
</ol>
<p><strong>(4).循环队列出队的伪算法</strong></p>
<p>​    front = (front + 1)%数组长度</p>
<p><strong>(5).循环队列判断队列为空的伪算法</strong></p>
<p>​    如果front与rear的值相等，则该队列就一定为空</p>
<p><strong>(6).循环队列判断队列为满的伪算法</strong></p>
<p>​    <strong>两种方法：</strong></p>
<p>​    1. 设定一个len变量来记录数组中有效数据的长度，当达到数组长度时，则拒绝继续添加</p>
<p>​    <strong>2. 设定：数组中有n个元素，若已经放了n-1个元素，那么数组就已经满了(一般使用第二种方法)</strong></p>
<p>​    <strong>第二种方法的判断条件</strong></p>
<p>​    如果<code>front == (rear + 1)%数组长度</code>，则队列已满</p>
<h4 id="4-算法"><a href="#4-算法" class="headerlink" title="4. 算法"></a>4. 算法</h4><ol>
<li><p>队列的定义以及初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体定义队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *pBase;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125;QUEUE,*PQUEUE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PQUEUE pQ)</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PQUEUE pQ)</span></span>&#123;  <span class="comment">//函数体</span></span><br><span class="line">    pQ-&gt;pBase = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">6</span>);</span><br><span class="line">    pQ-&gt;front = <span class="number">0</span>;</span><br><span class="line">    pQ-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>队满的判断，以及队列的入队操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为满</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">full_queue</span><span class="params">(PQUEUE pQ)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">full_queue</span><span class="params">(PQUEUE pQ)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pQ-&gt;front == ((pQ-&gt;rear+<span class="number">1</span>)%<span class="number">6</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队操作</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">en_queue</span><span class="params">(PQUEUE pQ,<span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">en_queue</span><span class="params">(PQUEUE pQ,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(full_queue(pQ))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pQ-&gt;pBase[pQ-&gt;rear] = val;</span><br><span class="line">    pQ-&gt;rear = (pQ-&gt;rear+<span class="number">1</span>)%<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>队列的遍历操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse_queue</span><span class="params">(PQUEUE pQ)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse_queue</span><span class="params">(PQUEUE pQ)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = pQ-&gt;front;</span><br><span class="line">    <span class="keyword">while</span>(i!=pQ-&gt;rear)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,pQ-&gt;pBase[i]);</span><br><span class="line">        i = (i+<span class="number">1</span>)%<span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>队列判断为空以及出队操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty_queue</span><span class="params">(PQUEUE pQ)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty_queue</span><span class="params">(PQUEUE pQ)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pQ-&gt;front==pQ-&gt;rear)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">out_queue</span><span class="params">(PQUEUE pQ,<span class="keyword">int</span> * val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">out_queue</span><span class="params">(PQUEUE pQ,<span class="keyword">int</span> * val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(empty_queue(pQ))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *val = pQ-&gt;pBase[pQ-&gt;front];</span><br><span class="line">    pQ-&gt;front = (pQ-&gt;front+<span class="number">1</span>)%<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>mian函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QUEUE Q;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    init(&amp;Q);</span><br><span class="line">    <span class="keyword">if</span>(en_queue(&amp;Q,<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;true\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">    en_queue(&amp;Q,<span class="number">2</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">3</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">4</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">5</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">6</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">7</span>);</span><br><span class="line">    traverse_queue(&amp;Q);</span><br><span class="line">    <span class="keyword">if</span>(out_queue(&amp;Q,&amp;num))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nok,the num is %d&quot;</span>,num);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    traverse_queue(&amp;Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="5-队列的具体应用"><a href="#5-队列的具体应用" class="headerlink" title="5. 队列的具体应用"></a>5. 队列的具体应用</h4><p>​    所有和时间有关的操作都有队列的影子</p>
<p>​    比如：像操作系统里有等待队列，线程有阻塞队列</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8405/" data-id="clh1gtw8i003u90wchpn07zwq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL复习03" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/21/MySQL%E5%A4%8D%E4%B9%A003/" class="article-date">
  <time datetime="2022-11-21T00:46:50.000Z" itemprop="datePublished">2022-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/21/MySQL%E5%A4%8D%E4%B9%A003/">MySQL复习03</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h4 id="1-多表关系"><a href="#1-多表关系" class="headerlink" title="1. 多表关系"></a>1. 多表关系</h4><p>​    在数据库表结构设计时，一般各个表结构之间存在着各种联系，基本上分为三种：</p>
<ul>
<li>一对多(多对一)</li>
<li>多对多</li>
<li>一对一</li>
</ul>
<p>​    <strong>一对多(多对一)</strong></p>
<p>​    案例：部门与员工的关系</p>
<p>​    关系：一个部门对应多个员工，一个员工对应一个部门</p>
<p>​    实现：在多的一方建立外键。指向一的一方的主键</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/zVAki4"><img src="https://s1.ax1x.com/2022/11/15/zVAki4.png" alt="zVAki4.png"></a></p>
<p>​    <strong>多对多</strong></p>
<p>​    案例：学生与课程的关系</p>
<p>​    关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择</p>
<p>​    实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/zVAEW9"><img src="https://s1.ax1x.com/2022/11/15/zVAEW9.png" alt="zVAEW9.png"></a></p>
<p>​    <strong>一对一</strong></p>
<p>​    案例：用户与用户详情的关系</p>
<p>​    关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详细字段放在另一张表中，以提升操作效率</p>
<p>​    实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/zVEvD0"><img src="https://s1.ax1x.com/2022/11/15/zVEvD0.png" alt="zVEvD0.png"></a></p>
<h4 id="2-多表查询概述"><a href="#2-多表查询概述" class="headerlink" title="2. 多表查询概述"></a>2. 多表查询概述</h4><p>​    指从多张表中查询数据</p>
<pre><code> 笛卡尔积</code></pre>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp,dept;</span><br></pre></td></tr></table></figure>

<p>​    笛卡尔积：两个集合，A集合和B集合的所有组合情况(在多表查询时，需要消除无效的笛卡尔积)</p>
<p>​    通过where语句可以消除无效的笛卡尔积，但不满足where的数据也会被消除掉</p>
<p>​    多表查询的分类</p>
<ul>
<li>连接查询<ul>
<li>内连接：相当于查询A、B交集部分数据</li>
<li>外连接：<ul>
<li>左外连接：查询左表所有数据，以及两张表交集部分数据</li>
<li>右外连接：查询右表所有数据，以及两张表交集部分数据</li>
</ul>
</li>
<li>自连接：当前表与自身的连接查询，自连接必须使用表别名</li>
</ul>
</li>
<li>子查询</li>
</ul>
<h4 id="3-内连接"><a href="#3-内连接" class="headerlink" title="3. 内连接"></a>3. 内连接</h4><p>​    内连接查询的是两张表的交集部分</p>
<p>​    内连接查询语法</p>
<ul>
<li><p>隐式内连接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>,表<span class="number">2</span> <span class="keyword">WHERE</span> 条件...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示内连接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> [<span class="keyword">INNER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件... <span class="keyword">WHERE</span> 筛选条件;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<p>​    范例：内连接的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表结构：emp,dept</span></span><br><span class="line"><span class="comment">-- 连接条件：emp.dept_id = dept.id</span></span><br><span class="line"><span class="comment">-- 查询每一个员工的姓名，以及关联的部门的名称(隐式内连接实现)</span></span><br><span class="line"><span class="keyword">SELECT</span> emp.name,dept.name <span class="keyword">FROM</span> emp,dept <span class="keyword">WHERE</span> emp.dept_id = dept_id;</span><br><span class="line">//如果表名太长可以起别名，但起别名之后WHERE后面的使用字段必须要用别名来引用，不可以用表原名引用</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询每一个员工的姓名。及关联的部门的名称(显示内连接实现)</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name, d.name <span class="keyword">FROM</span> emp e <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept d <span class="keyword">on</span> e.dept_id = d.id;</span><br><span class="line">//INNER关键字是可以省略的</span><br></pre></td></tr></table></figure>

<p>​    注意：隐式和显式只是语法不同，查询结果是相同的</p>
<h4 id="4-外连接"><a href="#4-外连接" class="headerlink" title="4. 外连接"></a>4. 外连接</h4><p>​    外连接查询语法</p>
<ul>
<li><p>左外连接：查询左表(表1)所有数据，以及两张表交集部分数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>右外连接：查询右表(表2)所有数据，以及两张表交集部分数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件...;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>​    范例：外连接的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表结构：emp,dept</span></span><br><span class="line"><span class="comment">-- 连接条件：emp.dept_id = dept.id</span></span><br><span class="line"><span class="comment">-- 1.查询emp表的所有数据，和对应的部门信息(左外连接)</span></span><br><span class="line"><span class="keyword">SELECT</span> e.*,d.name <span class="keyword">FROM</span> emp e <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> dept d <span class="keyword">ON</span> e.dept_id = d.id;</span><br><span class="line">//OUTER关键字可以省略</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.查询dept表的所有数据，和对应的员工信息(右外连接)</span></span><br><span class="line"><span class="keyword">SELECT</span> d.*,e.name <span class="keyword">FROM</span> emp e <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> dept d <span class="keyword">ON</span> e.dept_id = d.id;</span><br></pre></td></tr></table></figure>

<p>​    注意：一般开发中左外连接用的多，因为右外连接可以转化为左外连接</p>
<h4 id="4-自连接"><a href="#4-自连接" class="headerlink" title="4. 自连接"></a>4. 自连接</h4><p>​    自连接查询语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A 别名A <span class="keyword">JOIN</span> 表A 别名B <span class="keyword">ON</span> 条件...;</span><br></pre></td></tr></table></figure>

<p>​    自连接可以是内连接也可以是外连接</p>
<p>​    范例：自连接的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表结构：emp</span></span><br><span class="line"><span class="comment">-- 1.查询员工及其所属领导的名字</span></span><br><span class="line"><span class="keyword">SELECT</span> a.name,b.name <span class="keyword">FROM</span> emp a, emp b <span class="keyword">WHERE</span> a.managerid = b.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.查询所有员工及其领导的名字，如果员工没有领导，也需要查询出来</span></span><br><span class="line"><span class="keyword">SELECT</span> a.name <span class="string">&#x27;员工&#x27;</span>, b.name <span class="string">&#x27;领导&#x27;</span> <span class="keyword">FROM</span> emp a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> emp b <span class="keyword">ON</span> a.managerid = b.id;</span><br></pre></td></tr></table></figure>



<h4 id="5-联合查询"><a href="#5-联合查询" class="headerlink" title="5. 联合查询"></a>5. 联合查询</h4><p>​    联合查询是将多次查询的结果合并起来，形成一个新的查询结果集</p>
<p>​    联合查询的语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A...</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表B...;</span><br></pre></td></tr></table></figure>

<p>​    对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致</p>
<p>​    范例：联合查询的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.将薪资低于5000的员工和年龄大于50岁的员工全部查询出来</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> salary &lt; <span class="number">5000</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age &lt; <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<p>​    联合查询将这两次查询的结果合并在一起显示</p>
<p>​    <strong>注意：<code>UNION ALL</code>会将查到的全部数据直接合并在一起，<code>UNION</code>会对合并之后的数据去重</strong></p>
<h4 id="6-子查询概念"><a href="#6-子查询概念" class="headerlink" title="6. 子查询概念"></a>6. 子查询概念</h4><p>​    SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询</p>
<p>​    子查询的语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> <span class="keyword">column</span> = (<span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> t2);</span><br></pre></td></tr></table></figure>

<p>​    注意：子查询外部的语句可以是INSERT、UPDATE、DELETE、SELECT的任意一个</p>
<p>​    根据子查询结果的不同，将子查询分类为：</p>
<ul>
<li>标量子查询(子查询结果为单个值)</li>
<li>列子查询(子查询结果为一列)</li>
<li>行子查询(子查询结果为一行)</li>
<li>表子查询(子查询结果为多行多列)</li>
</ul>
<p>​    根据子查询的位置，将子查询分类为：</p>
<ul>
<li>WHERE之后</li>
<li>FROM之后</li>
<li>SELECT之后</li>
</ul>
<h4 id="7-标量子查询"><a href="#7-标量子查询" class="headerlink" title="7. 标量子查询"></a>7. 标量子查询</h4><p>​    子查询返回的结果是单个值(数字、字符串、日期等)，最简单的形式，这种子查询称为标量子查询</p>
<p>​    常见的操作符：<code>=</code>、<code>&lt;&gt;</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code></p>
<p>​    范例：标量子查询的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.查询“销售部”的所有员工信息</span></span><br><span class="line"><span class="comment">-- a.查询“销售部”部门ID</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">&#x27;销售部&#x27;</span>;</span><br><span class="line"><span class="comment">-- b.根据销售部部门ID，查询员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id = <span class="number">2</span>;</span><br><span class="line"><span class="comment">--通过子查询将a与b写为一条语句</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id = (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">&#x27;销售部&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="8-列子查询"><a href="#8-列子查询" class="headerlink" title="8. 列子查询"></a>8. 列子查询</h4><p>​    子查询返回的结果是一列(即多行)，这种子查询称为列子查询</p>
<p>​    常用操作符：IN、NOT IN、ANY、SOME、ALL</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IN</td>
<td align="center">在指定的集合范围之内，多选一</td>
</tr>
<tr>
<td align="center">NOT IN</td>
<td align="center">不在指定的集合范围之内</td>
</tr>
<tr>
<td align="center">ANY</td>
<td align="center">子查询返回列表中，有任意一个满足即可</td>
</tr>
<tr>
<td align="center">SOME</td>
<td align="center">与ANY等同，使用SOME的地方都可以使用ANY</td>
</tr>
<tr>
<td align="center">ALL</td>
<td align="center">子查询返回列表的所有值都必须满足</td>
</tr>
</tbody></table>
<p>​    范例：列子查询的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.查询“销售部”和“市场部”的所有员工信息</span></span><br><span class="line"><span class="comment">-- a.查询“销售部”和“市场部”的部门ID</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&#x27;销售部&#x27;</span> <span class="keyword">or</span> <span class="keyword">name</span> = <span class="string">&#x27;市场部&#x27;</span>;</span><br><span class="line"><span class="comment">-- b.根据部门ID查询员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id <span class="keyword">IN</span>(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">-- 将a,b写为一条语句</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id <span class="keyword">IN</span>(<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&#x27;销售部&#x27;</span> <span class="keyword">or</span> <span class="keyword">name</span> = <span class="string">&#x27;市场部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.查询比财务部所有人工资都高的员工信息</span></span><br><span class="line"><span class="comment">-- a.查询财务部所有人员的工资</span></span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id = (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> <span class="keyword">name</span> =<span class="string">&#x27;财务部&#x27;</span>);</span><br><span class="line"><span class="comment">-- b.比财务部所有人工资都高的员工信息,与a结合</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> salary &gt; <span class="keyword">ALL</span>(<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id = (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> <span class="keyword">name</span> =<span class="string">&#x27;财务部&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.查询比研发部任意一个人工资高的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> salary &gt; <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id = (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> <span class="keyword">name</span> =<span class="string">&#x27;研发部&#x27;</span>));</span><br></pre></td></tr></table></figure>



<h4 id="9-行子查询"><a href="#9-行子查询" class="headerlink" title="9. 行子查询"></a>9. 行子查询</h4><p>​    子查询返回的结果是一行(即多列)，这种子查询称为行子查询</p>
<p>​    常用的操作符：=、&lt;&gt;、IN、NOT IN</p>
<p>​    范例：行子查询的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.查询与“张三”的薪资及直属领导相同的员工信息</span></span><br><span class="line"><span class="comment">-- a.张无忌的薪资及直属领导</span></span><br><span class="line"><span class="keyword">SELECT</span> salary,managerid <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">&#x27;张无忌&#x27;</span>;</span><br><span class="line"><span class="comment">-- b.查询与“张无忌”的薪资及直属领导相同的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> (salary,managerid) = (<span class="number">1000</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">-- 将a,b写为一条语句</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> (salary,managerid) = (<span class="keyword">SELECT</span> salary,managerid <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">&#x27;张无忌&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="10-表子查询"><a href="#10-表子查询" class="headerlink" title="10. 表子查询"></a>10. 表子查询</h4><p>​    子查询返回的结果是多行多列，这种子查询称为表子查询，一般放在FROM之后，把查询结果作为一张临时表在和其他表联合查询，也会放在WHERE后面使用IN来完成查找</p>
<p>​    常用操作符：IN</p>
<p>​    范例：表子查询的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.查询与“张三”，“李四”的职位和薪资相同的员工信息</span></span><br><span class="line"><span class="comment">-- a.查询“张三”，“李四”的职位和薪资</span></span><br><span class="line"><span class="keyword">SELECT</span> job,salary <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">&#x27;张三&#x27;</span> <span class="keyword">or</span> <span class="keyword">name</span> = <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="comment">-- b.查询与“张三”，“李四”的职位和薪资相同的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> (job,salary) <span class="keyword">IN</span> (<span class="keyword">SELECT</span> job,salary <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">&#x27;张三&#x27;</span> <span class="keyword">or</span> <span class="keyword">name</span> = <span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.查询入职日期是“2006-01-01”之后的员工信息，及其部门信息</span></span><br><span class="line"><span class="comment">-- a.入职日期是“2006-01-01”之后的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> entrydate&gt;<span class="string">&#x27;2006-01-01&#x27;</span>;</span><br><span class="line"><span class="comment">-- b.查询这部分员工对应的部门信息，因为如果部门为空也要查询出来，所以要用到左外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> e.*,d.* <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> entrydate&gt;<span class="string">&#x27;2006-01-01&#x27;</span>) e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept d <span class="keyword">ON</span> e.dept_id=d.id;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/21/MySQL%E5%A4%8D%E4%B9%A003/" data-id="clh1gtw7o001h90wcfeq91df7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL复习02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/21/MySQL%E5%A4%8D%E4%B9%A002/" class="article-date">
  <time datetime="2022-11-21T00:45:24.000Z" itemprop="datePublished">2022-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/21/MySQL%E5%A4%8D%E4%B9%A002/">MySQL复习02</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="函数与约束"><a href="#函数与约束" class="headerlink" title="函数与约束"></a>函数与约束</h2><h4 id="1-字符串函数"><a href="#1-字符串函数" class="headerlink" title="1. 字符串函数"></a>1. 字符串函数</h4><p>​    MySQL中内置了很多字符串函数，常见的如下表：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">concat(S1,S2,…,Sn)</td>
<td align="center">字符串拼接，将(S1,S2,…,Sn)拼接为一个字符串</td>
</tr>
<tr>
<td align="center">lower(str)</td>
<td align="center">将字符串str全部转为小写</td>
</tr>
<tr>
<td align="center">upper(str)</td>
<td align="center">将字符串str全部转为大写</td>
</tr>
<tr>
<td align="center">lpad(str,n,pad)</td>
<td align="center">左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td align="center">rpad(str,n,pad)</td>
<td align="center">右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td align="center">trim(str)</td>
<td align="center">去掉字符串头部和尾部空格</td>
</tr>
<tr>
<td align="center">substring(str,start,len)</td>
<td align="center">返回从字符串str从start位置起的len长度的字符串，<strong>索引值是从1开始</strong></td>
</tr>
</tbody></table>
<p>​    <strong>注意：str可以传类型是字符串的列名</strong></p>
<p>​    范例：字符串函数的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- concat</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">concat</span>(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--lower</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">lower</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--upper</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">upper</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--lpad</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">lpad</span>(<span class="string">&#x27;01&#x27;</span>,<span class="number">5</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--rpad</span></span><br><span class="line"><span class="keyword">SELECT</span> rpad(<span class="string">&#x27;01&#x27;</span>,<span class="number">5</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--trim</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">trim</span>(<span class="string">&#x27; hello world &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--substring</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">substring</span>(<span class="string">&#x27;12345&#x27;</span>,<span class="number">1</span>,<span class="number">3</span>); //索引值从1开始</span><br></pre></td></tr></table></figure>



<h4 id="2-数值函数"><a href="#2-数值函数" class="headerlink" title="2. 数值函数"></a>2. 数值函数</h4><p>​    常见的数值函数如下表：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ceil(x)</td>
<td align="center">向上取整</td>
</tr>
<tr>
<td align="center">floor(x)</td>
<td align="center">向下取整</td>
</tr>
<tr>
<td align="center">mod(x,y)</td>
<td align="center">返回x/y的模</td>
</tr>
<tr>
<td align="center">rand()</td>
<td align="center">返回0~1内的随机数</td>
</tr>
<tr>
<td align="center">round(x,y)</td>
<td align="center">得参数x的整体进行四舍五入的值，保留y位小数</td>
</tr>
</tbody></table>
<p>​    范例：数值函数的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ceil</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ceil</span>(<span class="number">1.1</span>);  //结果2</span><br><span class="line"></span><br><span class="line"><span class="comment">-- floor</span></span><br><span class="line">SELSECT floor(1.1) //结果1</span><br><span class="line"></span><br><span class="line"><span class="comment">-- mod</span></span><br><span class="line">SELSET mod(3,4);  //3除4的余数，结果3</span><br><span class="line"></span><br><span class="line"><span class="comment">--rand</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">rand</span>(); //0~1随机数</span><br><span class="line"></span><br><span class="line"><span class="comment">--round</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">round</span>(<span class="number">2.345</span>,<span class="number">2</span>); //结果2.35</span><br></pre></td></tr></table></figure>

<p>​    注意：生成的数字可以作为字符串参与上面字符串函数中</p>
<h4 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3. 日期函数"></a>3. 日期函数</h4><p>​    常见日期函数如下：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">curdate()</td>
<td align="center">返回当前日期</td>
</tr>
<tr>
<td align="center">curtime()</td>
<td align="center">返回当前时间</td>
</tr>
<tr>
<td align="center">now()</td>
<td align="center">返回当前日期和时间，<strong>即返回的是date类型</strong></td>
</tr>
<tr>
<td align="center">year(date)</td>
<td align="center">获取指定date的年份</td>
</tr>
<tr>
<td align="center">month(date)</td>
<td align="center">获取指定date的月份</td>
</tr>
<tr>
<td align="center">day(date)</td>
<td align="center">获取指定date的日期</td>
</tr>
<tr>
<td align="center">date_add(date,interval expr type)</td>
<td align="center">在指定日期下增加一个时间间隔，返回该时间值</td>
</tr>
<tr>
<td align="center">datediff(date1,date2)</td>
<td align="center">返回起始时间date1和结束时间date2之间的天数，结果为date1-date2</td>
</tr>
</tbody></table>
<p>​    范例：日期函数的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- curdate</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">curdate</span>();  //结果2022-11-14</span><br><span class="line"></span><br><span class="line"><span class="comment">-- curtime</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">curtime</span>();  //结果9:29:15</span><br><span class="line"></span><br><span class="line"><span class="comment">-- now</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">now</span>();  //结果2022-11-14 9:29:54</span><br><span class="line"></span><br><span class="line"><span class="comment">-- year</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>(<span class="keyword">now</span>()); //结果2022</span><br><span class="line"></span><br><span class="line"><span class="comment">-- month</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">month</span>(<span class="keyword">now</span>());  //结果11</span><br><span class="line"></span><br><span class="line"><span class="comment">-- day</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">day</span>(<span class="keyword">now</span>());  //结果14</span><br><span class="line"></span><br><span class="line"><span class="comment">--date_add</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">date_add</span>(<span class="keyword">now</span>(),<span class="built_in">INTERVAL</span> <span class="number">10</span> <span class="keyword">DAY</span>);  //结果2022-11-24 10:05:31</span><br><span class="line"></span><br><span class="line"><span class="comment">-- datediff</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">datediff</span>(<span class="string">&#x27;2022-12-01&#x27;</span>,<span class="string">&#x27;2022-11-1&#x27;</span>); 结果30，注意如果前小后大则值为负数</span><br></pre></td></tr></table></figure>



<h4 id="4-流程函数"><a href="#4-流程函数" class="headerlink" title="4. 流程函数"></a>4. 流程函数</h4><p>​    流程函数在SQL语句中实现条件筛选，从而提高语句的效率</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">if(value,t,f)</td>
<td align="center">如果value为true，则返回true否则返回f</td>
</tr>
<tr>
<td align="center">ifnull(value1,value2)</td>
<td align="center">判定第一个参数是否为空，即如果value1不为空，返回value1，否则返回value2</td>
</tr>
<tr>
<td align="center">case [表中字段] when [val] then [res1]…else [default] end</td>
<td align="center">如果val1与表中数据判断为true返回res1,…(可以写多个判断的)否则返回default默认值</td>
</tr>
<tr>
<td align="center">case when [表中字段]比较运算 then [res1]…else [default] end</td>
<td align="center">如果不是具体的而是范围，使用该语法</td>
</tr>
</tbody></table>
<p>​    范例：流程控制函数的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- if</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">if</span>(<span class="literal">true</span>,<span class="string">&#x27;ok&#x27;</span>,<span class="string">&#x27;error&#x27;</span>);  //结果ok</span><br><span class="line"></span><br><span class="line"><span class="comment">--ifnull</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ifnull</span>(<span class="literal">null</span>,<span class="string">&#x27;error&#x27;</span>);  //结果error</span><br><span class="line"></span><br><span class="line"><span class="comment">-- case when then else end</span></span><br><span class="line"><span class="comment">-- 需求：查询员工表emp中员工姓名和工作地址(北京/上海---&gt;一线城市，其他---&gt;二线城市)</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="keyword">name</span>,</span><br><span class="line">	(<span class="keyword">case</span> workaddress <span class="keyword">when</span> <span class="string">&#x27;北京&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;一线城市&#x27;</span> <span class="keyword">when</span> <span class="string">&#x27;上海&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;一线城市&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;二线城市&#x27;</span> <span class="keyword">end</span>) <span class="keyword">AS</span> <span class="string">&#x27;工作地址&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure>



<h4 id="5-约束"><a href="#5-约束" class="headerlink" title="5. 约束"></a>5. 约束</h4><p>​    约束是作用于表中字段上的规则，用于限制存储在表中的数据</p>
<p>​    约束的目的是保证数据库中数据的正确、有效性和完整性</p>
<p>​    约束的分类</p>
<table>
<thead>
<tr>
<th align="center">约束</th>
<th align="center">描述</th>
<th align="center">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="center">非空约束</td>
<td align="center">限制该字段的数据不能为null</td>
<td align="center">NOT NULL</td>
</tr>
<tr>
<td align="center">唯一约束</td>
<td align="center">保证该字段的所有数据都是唯一、不重复的</td>
<td align="center">UNIQUE</td>
</tr>
<tr>
<td align="center">主键约束</td>
<td align="center">主键是一行数据的唯一标识，要求非空且唯一</td>
<td align="center">PRIMARY KEY</td>
</tr>
<tr>
<td align="center">默认约束</td>
<td align="center">保存数据时，如果未指定该字段的值，则采用默认值</td>
<td align="center">DEFAULT</td>
</tr>
<tr>
<td align="center">检查约束</td>
<td align="center">保证字段值满足某一条件</td>
<td align="center">CHECK</td>
</tr>
<tr>
<td align="center">外键约束</td>
<td align="center">用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td>
<td align="center">FOREIGN KEY</td>
</tr>
</tbody></table>
<p>​    注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束</p>
<p>​    范例：约束的使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>;</span><br><span class="line">	name VARCHAR(20) NOT NULL UNIQUE;</span><br><span class="line">	age INT <span class="keyword">CHECK</span>(age&gt;<span class="number">0</span> &amp;&amp; age&lt;=<span class="number">120</span>);</span><br><span class="line">	statues CHAR(1) DEFAULT &#x27;1&#x27;;</span><br><span class="line">)<span class="keyword">COMMENT</span> <span class="string">&#x27;用户表&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="6-外键约束"><a href="#6-外键约束" class="headerlink" title="6.外键约束"></a>6.外键约束</h4><p>​    概念：用来让两张表的数据之间建立连接，保证数据的一致性和完整性</p>
<p>​    一般把设立外键的表叫做子表，而让该外键为主键的表叫主表</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/zEiZ1x"><img src="https://s1.ax1x.com/2022/11/15/zEiZ1x.png" alt="zEiZ1x.png"></a></p>
<p>​    设置外键后，当要删除主表的数据时，要判定该数据在子表中是否存在关联关系，如果存在则拒绝删除操作</p>
<p>​    外键约束的语法：</p>
<ul>
<li><p>添加外键</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//建表时直接创建</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">	字段名 数据类型</span><br><span class="line">	...</span><br><span class="line">	[<span class="keyword">CONSTRAINT</span>] [外键名称] <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(外键字段名) REFRENCES 主表(主表列名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//表建立后修改外键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(外键字段名) <span class="keyword">REFERENCES</span> 主表名(主表列名);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除外键</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> 外键名称;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>​    范例：外键的操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//增加外键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_emp_dept_id <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (dept_id) <span class="keyword">REFERENCES</span> dept(<span class="keyword">id</span>);</span><br><span class="line"></span><br><span class="line">//删除外键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> fk_emp_dept_id;</span><br></pre></td></tr></table></figure>



<p>​    外键约束：删除和更新行为</p>
<table>
<thead>
<tr>
<th align="center">行为</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NO ACTION</td>
<td align="center">当主表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新，<strong>外键约束的默认行为</strong></td>
</tr>
<tr>
<td align="center">RESTRICT</td>
<td align="center">与NO ACTION一致</td>
</tr>
<tr>
<td align="center">CASCADE(级联)</td>
<td align="center">当在主表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在从表中的记录</td>
</tr>
<tr>
<td align="center">SET NULL</td>
<td align="center">当在主表中删除对应记录时，首先检查该记录是否对应外键，如果有则设置从表中该外键值为null(此时需要设计时外键允许取null)</td>
</tr>
<tr>
<td align="center">SET DEFAULT</td>
<td align="center">主表有变更时，子表将外键列设置成一个默认的值(Innodb不支持)</td>
</tr>
</tbody></table>
<p>​    语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(外键字段名) <span class="keyword">REFERENCES</span> 主表名(主表列名) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br></pre></td></tr></table></figure>

<p>​    <code>ON UPDATE</code>：表示更新时怎么操作</p>
<p>​    <code>ON DELETE</code>：表示删除时怎么操作</p>
<p>​    前面一段与外键设置时语法相同</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/21/MySQL%E5%A4%8D%E4%B9%A002/" data-id="clh1gtw7p001k90wch7irftk7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构04" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8404/" class="article-date">
  <time datetime="2022-11-21T00:41:29.000Z" itemprop="datePublished">2022-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8404/">数据结构04</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h4 id="1-栈的定义"><a href="#1-栈的定义" class="headerlink" title="1. 栈的定义"></a>1. 栈的定义</h4><p>​    一种可以实现“先进后出”的存储结构<br>​    栈类似于箱子</p>
<h4 id="2-栈的分类"><a href="#2-栈的分类" class="headerlink" title="2. 栈的分类"></a>2. 栈的分类</h4><p>​    栈可以分为静态栈和动态栈</p>
<p>​    静态栈：通过数组实现</p>
<p>​    动态栈：通过链表实现</p>
<p>​    动态栈使用的更多</p>
<h4 id="3-栈可以实现的操作"><a href="#3-栈可以实现的操作" class="headerlink" title="3. 栈可以实现的操作"></a>3. 栈可以实现的操作</h4><p>​    1. 入栈(压栈)</p>
<p>​    2. 出栈</p>
<h4 id="4-动态栈的伪算法"><a href="#4-动态栈的伪算法" class="headerlink" title="4. 动态栈的伪算法"></a>4. 动态栈的伪算法</h4><ol>
<li><p>动态栈的实现</p>
<p>动态栈通过链表来实现，栈中的每一个元素通过一个结点来表示，要实现栈还需要声明一个栈顶和栈底，初始化栈时，会将栈顶和栈底指向同一个空的头结点，要向栈存入数据，则先新生成一个结点，再**将该新结点的指针域指向栈顶指向的结点(考虑到出栈时要删除，所以新指向旧)**，最后将栈顶移动到新结点上</p>
</li>
</ol>
<ol start="2">
<li>注意：动态栈属于链表栈，不存在满的问题</li>
</ol>
<ol start="3">
<li><p>压栈操作图示</p>
<p><img src="https://s1.ax1x.com/2022/11/10/z9SQFe.png" alt="z9SQFe.png"></p>
</li>
</ol>
<ol start="4">
<li><p>栈的遍历</p>
<p>栈的遍历由于栈是先进后出，所以需要通过栈顶确定指针p，通过指针p来自上向下进行操作，只要p指向的元素不是栈底，则可以对栈一直输出</p>
</li>
</ol>
<ol start="5">
<li><p>判断栈是否为空</p>
<p>当栈顶和栈底相等，则栈为空</p>
</li>
</ol>
<ol start="6">
<li><p>出栈</p>
<p>当栈中元素为空时，则出栈失败；不为空则将一指针p指向栈顶指向的元素，栈顶元素指向该元素的下一个元素，此时释放掉p指针指向的结点就行</p>
</li>
</ol>
<ol start="7">
<li><p>栈的清空</p>
<p>将栈内有效元素全部清空，只保留框架，实现需要定义指针p和q，p指向栈顶元素，q为NULL，如果p没有指向栈底，则q指向p的下一个元素，当将p指向元素释放后p在移动到q上，只要p指向的不是栈底则一直循环执行该算法，循环结束后应将栈顶指向栈底</p>
</li>
</ol>
<h4 id="5-动态栈的算法"><a href="#5-动态栈的算法" class="headerlink" title="5. 动态栈的算法"></a>5. 动态栈的算法</h4><ol>
<li><p>算法-栈的定义、栈的初始化、压栈、遍历栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义栈中的每一个结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span></span><br><span class="line">&#125;NODE,*PNODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">    PNODE pTop;</span><br><span class="line">    PNODE pBottom;</span><br><span class="line">&#125;STACK,*PSTACK;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PSTACK pSt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(PSTACK pSt,<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STACK st;    <span class="comment">//定义栈</span></span><br><span class="line">    init(&amp;st);   <span class="comment">//栈的初始化</span></span><br><span class="line">    push(&amp;st,<span class="number">1</span>); <span class="comment">//压栈</span></span><br><span class="line">    push(&amp;st,<span class="number">2</span>);</span><br><span class="line">    write_stack(&amp;st); <span class="comment">//遍历栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PSTACK pSt)</span></span>&#123;</span><br><span class="line">    pSt-&gt;pTop = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pSt-&gt;pTop)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pSt-&gt;pBottom = pSt-&gt;pTop;</span><br><span class="line">    <span class="comment">//指针域置为空</span></span><br><span class="line">    pSt-&gt;pTop-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(PSTACK pSt,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    PNODE p = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    p-&gt;data = num;</span><br><span class="line">    p-&gt;pNext = pSt-&gt;pTop;</span><br><span class="line">    pSt-&gt;pTop =p;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_stack</span><span class="params">(PSTACK pSt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    PNODE p = pSt-&gt;pTop;</span><br><span class="line">    <span class="keyword">while</span>(pSt-&gt;pBottom!=p)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">        p=p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>算法-栈是否为空的判断、出栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt; //bool类型需要声明的头文件</span></span></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">(PSTACK pST)</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">(PSTACK pSt)</span></span>&#123;  <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">if</span>(pSt-&gt;pTop==pSt-&gt;pBottom)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈，并返回出栈的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(PSTACK pSt,<span class="keyword">int</span> * val)</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(PSTACK pSt,<span class="keyword">int</span> * val)</span></span>&#123;  <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">if</span>(empty(pSt))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PNODE p = pSt-&gt;pTop;</span><br><span class="line">    pSt-&gt;pTop = pSt-&gt;pTop-&gt;pNext;</span><br><span class="line">    *val = p-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法-栈的清空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(PSTACK pSt)</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(PSTACK pSt)</span></span>&#123;  <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">if</span>(empty(pSt))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PNODE p = pSt-&gt;pTop;</span><br><span class="line">    PNODE q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=pSt-&gt;pBottom)&#123;</span><br><span class="line">        q = p-&gt;pNext;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    pSt-&gt;pTop = pSt-&gt;pBottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h4 id="6-栈的应用"><a href="#6-栈的应用" class="headerlink" title="6. 栈的应用"></a>6. 栈的应用</h4><p>​    1. 函数调用<br>​    2. 中断<br>​    3. 表达式求值<br>​    4. 内存分配<br>​    5. 缓冲处理<br>​    6. 走迷宫</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8404/" data-id="clh1gtw8h003s90wchpmk9z54" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL复习01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/10/31/MySQL%E5%A4%8D%E4%B9%A001/" class="article-date">
  <time datetime="2022-10-31T14:47:15.000Z" itemprop="datePublished">2022-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/31/MySQL%E5%A4%8D%E4%B9%A001/">MySQL复习01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="MySQL概述"><a href="#MySQL概述" class="headerlink" title="MySQL概述"></a>MySQL概述</h3><h4 id="1-数据库相关概念"><a href="#1-数据库相关概念" class="headerlink" title="1. 数据库相关概念"></a>1. 数据库相关概念</h4><ol>
<li>数据库(DB)：存储数据的仓库，数据是有组织的进行存储</li>
<li>数据库管理系统(DBMS)：操纵和管理数据库的大型软件，类似像MySQL就是</li>
<li><strong>SQL：操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准</strong></li>
</ol>
<h4 id="2-主流关系型数据库管理系统"><a href="#2-主流关系型数据库管理系统" class="headerlink" title="2. 主流关系型数据库管理系统"></a>2. 主流关系型数据库管理系统</h4><p>​    Oracle(收费、大型)、MySQL(免费、中小型)、SQLServer(收费、中型)</p>
<h4 id="3-关系型数据库"><a href="#3-关系型数据库" class="headerlink" title="3. 关系型数据库"></a>3. 关系型数据库</h4><p>​    建立在关系模型基础上，由多张相互连接的二维表组成的数据库</p>
<p>​    <strong>用表结构存储数据的叫关系型数据库</strong></p>
<p>特点：</p>
<p>​    1. 使用表存储数据，格式统一，便于维护<br>​    2. 使用SQL语言操作，标准统一，使用方便</p>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><h4 id="1-SQL简介"><a href="#1-SQL简介" class="headerlink" title="1. SQL简介"></a>1. SQL简介</h4><p><strong>SQL通用语法</strong></p>
<ol>
<li>SQL语句可以单行书写或多行书写，以分号结尾</li>
<li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写</li>
<li>注释：<ul>
<li>单行注释：<code>--</code>注释内容或<code>#</code>注释内容(MySQL特有)</li>
<li>多行注释：<code>/*</code>注释内容<code>*/</code></li>
</ul>
</li>
</ol>
<p>​    <strong>SQL分类</strong></p>
<table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">全称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DDL</td>
<td align="center">Data Definition Language</td>
<td align="center">数据定义语言，用来定义数据库对象(数据库，表，字段)</td>
</tr>
<tr>
<td align="center">DML</td>
<td align="center">Data Manipulation Language</td>
<td align="center">数据操作语言，用来对数据库表中的数据进行增删改</td>
</tr>
<tr>
<td align="center">DQL</td>
<td align="center">Data Query Language</td>
<td align="center">数据查询语言，用来查询数据库中表的记录</td>
</tr>
<tr>
<td align="center">DCL</td>
<td align="center">Data Control Language</td>
<td align="center">数据控制语言，用来创建数据库用户、控制数据库的访问权限</td>
</tr>
</tbody></table>
<h4 id="2-DDL"><a href="#2-DDL" class="headerlink" title="2. DDL"></a>2. DDL</h4><p>​    <strong>DDL-数据库操作(命令行)</strong></p>
<ol>
<li><p>查询所有数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> [<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>] 数据库名 [defailt <span class="keyword">charset</span> 字符集] [<span class="keyword">collate</span> 排序规则];</span><br></pre></td></tr></table></figure>

<p>注意：一般不推荐设置字符集为<code>utf8</code>，因为其只占三个字节，而有些特殊字符是占四个字节的，所以推荐使用utf8mb4，它是支持四个字节的</p>
</li>
<li><p>删除数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> [<span class="keyword">if</span> <span class="keyword">exists</span>] 数据库名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入/切换数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> 数据库名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询当前数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>();</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>​    <strong>DDL-表操作(命令行)</strong></p>
<ol>
<li><p>查询当前数据库所有表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//前提是要先进入到数据库</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询表结构(表的字段设置，类型等信息)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询指定表的建表语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表的创建</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">	字段<span class="number">1</span> 字段<span class="number">1</span>类型 [<span class="keyword">comment</span> <span class="string">&#x27;注释&#x27;</span>],</span><br><span class="line">	字段<span class="number">2</span> 字段<span class="number">2</span>类型 [<span class="keyword">comment</span> <span class="string">&#x27;注释&#x27;</span>],</span><br><span class="line">	...</span><br><span class="line">	字段n 字段n类型 [<span class="keyword">comment</span> <span class="string">&#x27;注释&#x27;</span>]</span><br><span class="line">) [<span class="keyword">comment</span> <span class="string">&#x27;表注释&#x27;</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>向表结构中添加字段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 字段名 类型(长度) [<span class="keyword">COMMENT</span> 注释] [约束]；</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表中某字段的数据类型</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">MODIFY</span> 字段名 新的数据类型(长度);</span><br></pre></td></tr></table></figure>
</li>
<li><p>同时修改字段名和字段类型</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">CHANGE</span> 旧字段名 新字段名 类型(长度)  [<span class="keyword">COMMENT</span> 注释] [约束];</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除字段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 字段名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">RENAME</span> <span class="keyword">TO</span> 新表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] 表名;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>​    <strong>DDL-数据类型</strong></p>
<p>​    MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型</p>
<p>​    <strong>数值类型</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SMALLINT</td>
<td align="center">2 bytes</td>
<td align="center">大整数值</td>
</tr>
<tr>
<td align="center">INT</td>
<td align="center">4 bytes</td>
<td align="center">大整数值</td>
</tr>
<tr>
<td align="center">FLOAT</td>
<td align="center">4 bytes</td>
<td align="center">单精度浮点数值</td>
</tr>
<tr>
<td align="center">DOUBLE</td>
<td align="center">8 bytes</td>
<td align="center">双精度浮点数值</td>
</tr>
<tr>
<td align="center">DECIMAL</td>
<td align="center">使用时需要指定精度(总长)和标度(小数尾数)</td>
<td align="center">小数值</td>
</tr>
</tbody></table>
<ol>
<li><p>可以设置类型是否为无符号</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">age INT UNSIGNED</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以指定设置的范围</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">score double(4,1) //长度为4，小数部分为1</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>​    <strong>字符串类型</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CHAR</td>
<td align="center">0~255 bytes</td>
<td align="center">定长字符串</td>
</tr>
<tr>
<td align="center">VARCHAR</td>
<td align="center">0~65535 bytes</td>
<td align="center">变长字符串</td>
</tr>
</tbody></table>
<p>​    定长与变长的区别：</p>
<ul>
<li>CHAR：存入数据不管多大占用的空间都是那么多，其性能上要好</li>
<li>VARCHAR：根据你存储的内容去计算需要占用的空间</li>
</ul>
<p>​    <strong>日期类型</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">范围</th>
<th align="center">格式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DATE</td>
<td align="center">1000-01-01至9999-12-31</td>
<td align="center">YYYY-MM-DD</td>
<td align="center">日期值</td>
</tr>
<tr>
<td align="center">TIME</td>
<td align="center">-838:59:59至838:59:59</td>
<td align="center">HH:MM:SS</td>
<td align="center">时间值</td>
</tr>
<tr>
<td align="center">DATETIME</td>
<td align="center">1000-01-01 00:00:00至9999-12-31 23:59:59</td>
<td align="center">YYYY-MM-DD HH:MM:SS</td>
<td align="center">混合日期和时间值</td>
</tr>
</tbody></table>
<h4 id="3-DML"><a href="#3-DML" class="headerlink" title="3. DML"></a>3. DML</h4><p>​    <strong>DML-增加数据</strong></p>
<ol>
<li><p>给指定字段添加数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(字段名<span class="number">1</span>,字段名<span class="number">2</span>,...) <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>给全部字段添加数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,...); //注意：值应当与字段一一对应</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>​    <strong>注意：插入字符串和日期型数据应当包含在引号中</strong>，如果要添加多条数据，数据之间用<code>,</code>分隔</p>
<p>​    <strong>DML-修改和删除数据</strong></p>
<ol>
<li><p>修改数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段名<span class="number">1</span>=值<span class="number">1</span>,字段名<span class="number">2</span>=值<span class="number">2</span>,...[<span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure>

<p>注意：如果没有写<code>WHERE</code>条件，则会修改整张表的所有数据，<code>SET</code>后面为一条记录的多个字段</p>
</li>
<li><p>删除数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure>

<p>注意：DELETE语句删除的是整条记录，而不是某一字段的值，且如果没有写<code>WHERE</code>条件，则会删除整张表的所有数据</p>
</li>
</ol>
<h4 id="4-DQL"><a href="#4-DQL" class="headerlink" title="4. DQL"></a>4. DQL</h4><p>​    在日常的项目中查询的频次要远高于增删改的频次</p>
<p>​    DQL语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//编写顺序</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	字段列表</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	表名列表</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	条件列表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	分组字段列表</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">	分组后条件列表</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	排序字段列表</span><br><span class="line"><span class="keyword">LIMIT</span></span><br><span class="line">	分页参数</span><br></pre></td></tr></table></figure>



<p>​    <strong>DQL-基本查询</strong></p>
<ol>
<li><p>查询字段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查询某些字段</span><br><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>,字段<span class="number">2</span>, ... <span class="keyword">FROM</span> 表名;</span><br><span class="line">//查询所有字段</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置别名</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>[<span class="keyword">AS</span> <span class="string">&#x27;别名1&#x27;</span>],字段<span class="number">2</span>[<span class="keyword">AS</span> <span class="string">&#x27;别名2&#x27;</span>] ... <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>

<p>注意：设置别名时，<code>AS</code>是可以省略的，<strong>设置别名后查询到的列会显示别名</strong></p>
<ol start="3">
<li>对查询到的结果去除重复记录</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段列表 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>​    <strong>DQL-条件查询</strong></p>
<ol>
<li><p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件列表</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>条件</li>
</ol>
<table>
<thead>
<tr>
<th align="center">比较运算符(单个条件比较)</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&gt;=、&gt; 、&lt;、&lt;=、=</td>
<td align="center">大于等于、大于、小于、小于等于、等于</td>
</tr>
<tr>
<td align="center">&lt;&gt;、!=</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">BETWEEN…AND</td>
<td align="center">在某个范围之内，between后面跟的是小值，and后面是大值</td>
</tr>
<tr>
<td align="center">IN(…)</td>
<td align="center">列表中满足某1项就可以查询到该条记录</td>
</tr>
<tr>
<td align="center">LIKE ‘占位符’</td>
<td align="center">模糊匹配(_匹配单个字符，%匹配任意个字符)</td>
</tr>
<tr>
<td align="center">IS (NOT) NULL</td>
<td align="center">某字段(不)为空</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">逻辑运算符(用于将多个条件组装起来)</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AND 或 &amp;&amp;</td>
<td align="center">并且(多个条件同时成立)</td>
</tr>
<tr>
<td align="center">OR 或 ||</td>
<td align="center">或者(多个条件任意一个成立)</td>
</tr>
<tr>
<td align="center">NOT 或 !</td>
<td align="center">非(不是)</td>
</tr>
</tbody></table>
</li>
</ol>
<p>​    <strong>DQL补充-聚合函数(在分组查询中使用)</strong></p>
<ol>
<li><p>聚合函数的概念：将一列数据作为一个整体进行纵向计算</p>
</li>
<li><p>常见聚合函数</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">count</td>
<td align="center">统计数量</td>
</tr>
<tr>
<td align="center">max</td>
<td align="center">最大值</td>
</tr>
<tr>
<td align="center">min</td>
<td align="center">最小值</td>
</tr>
<tr>
<td align="center">avg</td>
<td align="center">平均值</td>
</tr>
<tr>
<td align="center">sum</td>
<td align="center">求和</td>
</tr>
</tbody></table>
</li>
<li><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 聚合函数(字段列表) <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>

<p>注意：null值不参与所有聚合函数运算</p>
</li>
</ol>
<p>​    </p>
<p>​    <strong>DQL-分组查询</strong></p>
<ol>
<li><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件] <span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组字段名 [<span class="keyword">HAVING</span> 分组后过滤条件];</span><br></pre></td></tr></table></figure>
</li>
<li><p>WHERE和HAVING的区别</p>
<ul>
<li>执行时机不同：where是分组之前进行过滤，不满足where条件则不参与分组，而having是分组之后对结果进行过滤</li>
<li>判断条件不同：where不能对聚合函数进行判断，而having可以</li>
</ul>
<ol start="3">
<li><p>执行顺序：where&gt;聚合函数&gt;having</p>
</li>
<li><p>分组之后查询的字段一般为聚合函数和进行分组的字段，查询其他字段无任何意义</p>
</li>
</ol>
</li>
</ol>
<p>​    <strong>DQL-排序查询</strong></p>
<ol>
<li><p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span>, 字段<span class="number">2</span> 排序方式<span class="number">2</span> ...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>排序方式</p>
<ul>
<li>ASC：升序(默认值)</li>
<li>DESC：降序</li>
</ul>
</li>
<li><p>多字段排序时，第一个字段值相同时才会根据第二个字段排序</p>
</li>
</ol>
<p>​    <strong>DQL-分页查询</strong></p>
<ol>
<li><p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> 起始索引,查询记录数;</span><br></pre></td></tr></table></figure>
</li>
<li><p> 起始索引从0开始，起始索引 = (要查询页码-1) <code>*</code> 每页显示记录数</p>
</li>
<li><p> 分页查询在不同数据库中语法不一样，在MySQL中是LIMIT</p>
</li>
<li><p> 如果查询的是第一页数据，起始索引可以省略，直接简写为LIMIT 10</p>
</li>
</ol>
<h4 id="5-DCL-SQL开发人员对其操作比较少"><a href="#5-DCL-SQL开发人员对其操作比较少" class="headerlink" title="5. DCL(SQL开发人员对其操作比较少)"></a>5. DCL(SQL开发人员对其操作比较少)</h4><p>​    <strong>DCL-权限控制</strong></p>
<ol>
<li><p>查询用户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建用户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//主机名约束了用户可以访问的数据库，设置为%可以访问所有数据库</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>; </span><br></pre></td></tr></table></figure>
</li>
<li><p>修改用户密码</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除用户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>；</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>​    <strong>DCL-权限控制</strong></p>
<ol>
<li><p>查询权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>授予权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//如果是所有数据库以及所有表则写*.*,设置多个权限用,隔开</span><br><span class="line"><span class="keyword">GRANT</span> 授权列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>撤销权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">FROM</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/31/MySQL%E5%A4%8D%E4%B9%A001/" data-id="clh1gtw7n001f90wceil0fpjn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构03" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/" class="article-date">
  <time datetime="2022-10-31T05:59:43.000Z" itemprop="datePublished">2022-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/">数据结构03</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h4 id="1-typedef"><a href="#1-typedef" class="headerlink" title="1. typedef"></a>1. typedef</h4><p>​    C语言允许为一个数据类型起一个新的别名，使用typedef关键字来进行定义</p>
<p>​    typedef 的用法一般为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  oldName  newName;</span><br></pre></td></tr></table></figure>

<p>​    注意：一般新名字全部字母大写</p>
<p>​    范例：为结构体起一个别名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> sid;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">&#125;ST,*PST;<span class="comment">//ST等价于struct Student, PST等价于struct Student *</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    ST st;</span><br><span class="line">    st.sid = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,st.sid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-链表-离散存储"><a href="#2-链表-离散存储" class="headerlink" title="2. 链表(离散存储)"></a>2. 链表(离散存储)</h4><p><strong>链表的定义：</strong></p>
<p>​    ​    1. n个结点离散分配，<br>​    ​    2. 彼此通过指针相连<br>​    ​    3. 每个结点只有一个前驱结点，每个结点只有一个后续结点<br>​    ​    4. 首结点没有前驱结点，尾结点没有后续结点</p>
<p><strong>专业术语：</strong></p>
<ul>
<li>首结点：第一个存了有效数据的结点</li>
<li>尾结点：最后一个存了有效数据的结点，尾结点的指针域为空</li>
<li>头结点：第一个有效结点(首结点)之前的结点，方便我们对链表算法进行操作，里面不包含有效数据和数组长度，但头结点的数据类型和首结点的数据类型一样</li>
<li>头指针：指向头结点的指针变量，存放了头结点的地址</li>
<li>尾指针：指向尾结点的指针变量</li>
</ul>
<p><strong>如果希望通过一个函数来对链表进行处理，至少需要接受链表的哪些参数：</strong></p>
<p>​    只需要一个参数：头指针</p>
<p>​    通过头指针可以推算出链表的其他所有信息</p>
<h4 id="3-链表结点数据类型的表示"><a href="#3-链表结点数据类型的表示" class="headerlink" title="3. 链表结点数据类型的表示"></a>3. 链表结点数据类型的表示</h4><p>​    一个结点可以分为两个部分：数据域和指针域</p>
<p>​    指针域中的指针指向了一个完整的结点</p>
<p>​    范例：结点的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;  <span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;NODE,*PNODE;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="4-链表的分类"><a href="#4-链表的分类" class="headerlink" title="4. 链表的分类"></a>4. 链表的分类</h4><ul>
<li>单链表：每个结点的指针域只能指向后面结点</li>
<li>双链表：每一个结点有两个指针域</li>
<li>循环链表：能通过任何一个结点找到其他所有的结点</li>
<li>非循环链表：尾结点为null</li>
</ul>
<p>​    </p>
<h4 id="5-链表的伪算法"><a href="#5-链表的伪算法" class="headerlink" title="5. 链表的伪算法"></a>5. 链表的伪算法</h4><ol>
<li><p>非循环单链表：将q结点插入到p结点后面</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xRglh8"><img src="https://s1.ax1x.com/2022/10/25/xRglh8.png" alt="xRglh8.png"></a></p>
</li>
</ol>
<p>​    伪算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line">r = p-&gt;pNext;</span><br><span class="line">p-&gt;pNext = q;</span><br><span class="line">q-&gt;pNext = r;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line">q-&gt;pNext = p-&gt;pNext;</span><br><span class="line">p-&gt;pNext = q;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>非循环单链表：将p结点后面的那个结点删除</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xR2PDs"><img src="https://s1.ax1x.com/2022/10/25/xR2PDs.png" alt="xR2PDs.png"></a></p>
</li>
</ol>
<p>​    伪算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意:由于直接连会导致中间那个结点找不到从而导致内存的浪费,所以要先存起来,最后也要进行释放</span></span><br><span class="line">r = p-&gt;pNext;</span><br><span class="line">p-&gt;pNext = p-&gt;pNext-&gt;pNext;</span><br><span class="line"><span class="built_in">free</span>(r);</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h4 id="6-链表的算法"><a href="#6-链表的算法" class="headerlink" title="6. 链表的算法"></a>6. 链表的算法</h4><ol>
<li><p><strong>算法–链表的创建以及链表的遍历</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">count</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">count</span> * <span class="title">pNext</span>;</span></span><br><span class="line">&#125;NODE,* PNODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function">PNODE <span class="title">count_create</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_write</span><span class="params">(PNODE pHead)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设置头指针</span></span><br><span class="line">    PNODE pHead = <span class="literal">NULL</span>;</span><br><span class="line">    pHead = count_create(); <span class="comment">//创建一个非循环单链表，并返回头结点地址</span></span><br><span class="line">    count_write(pHead); <span class="comment">//遍历打印出来</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PNODE <span class="title">count_create</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp; <span class="comment">//临时存放用户输入的数据</span></span><br><span class="line">    <span class="keyword">int</span> num; <span class="comment">//存放有效结点的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置头指针指向头结点，头结点不存放任何有效数据</span></span><br><span class="line">    PNODE pHead = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="comment">//头结点的指针域设为NULL，防止后面没有结点</span></span><br><span class="line">    pHead-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pHead)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表的尾指针，用来挂每一个新生成的链表结点</span></span><br><span class="line">    PNODE pTail = pHead;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input number :&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; num ; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The %d number:&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tmp);</span><br><span class="line">        PNODE new_Node = (PNODE) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == new_Node)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新生成结点的指针域设置为NULL</span></span><br><span class="line">        new_Node-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//新生成的结点的数据域设置值</span></span><br><span class="line">        new_Node-&gt;number =tmp;</span><br><span class="line">        <span class="comment">//将新生成的结点挂在尾指针上</span></span><br><span class="line">        pTail-&gt;pNext = new_Node;</span><br><span class="line">        <span class="comment">//将尾指针指向新生成的新结点</span></span><br><span class="line">        pTail = new_Node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_write</span><span class="params">(PNODE pHead)</span></span>&#123;</span><br><span class="line">    PNODE pTail = pHead-&gt;pNext;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">NULL</span>!=pTail)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span> ,pTail-&gt;number);</span><br><span class="line">        <span class="comment">//将指针向后移</span></span><br><span class="line">        pTail = pTail-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p><strong>算法–链表的是否为空的判断和求链表长度</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否为空的函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;  //C语言使用bool类型需要导入的头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(PNODE pHead)</span></span>; <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(PNODE pHead)</span></span>&#123; <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pHead-&gt;pNext)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_len</span><span class="params">(PNODE pHead)</span></span>; <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_len</span><span class="params">(PNODE pHead)</span></span>&#123; <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    PNODE p = pHead-&gt;pNext;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">NULL</span> != p)&#123;</span><br><span class="line">        ++len;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p><strong>算法–链表的冒泡排序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(PNODE pHead)</span></span>; <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(PNODE pHead)</span></span>&#123; <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">int</span> i,j,tmp;</span><br><span class="line">    <span class="keyword">int</span> len = count_len(pHead);</span><br><span class="line">    PNODE p = pHead-&gt;pNext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;len<span class="number">-1</span> ; i++)&#123;</span><br><span class="line">        PNODE q = p-&gt;pNext;</span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>; j &lt; len ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;number&gt;q-&gt;number)&#123;</span><br><span class="line">                tmp = p-&gt;number;</span><br><span class="line">                p-&gt;number = q-&gt;number;</span><br><span class="line">                q-&gt;number = tmp;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            q = q-&gt;pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p><strong>算法–链表的插入元素和删除元素</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的插入算法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">count_insert</span><span class="params">(PNODE pHead, <span class="keyword">int</span> pos , <span class="keyword">int</span> val)</span></span>; <span class="comment">//函数声明 pos表示在有效结点第pos个增加结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">count_insert</span><span class="params">(PNODE pHead, <span class="keyword">int</span> pos , <span class="keyword">int</span> val)</span></span>&#123; <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PNODE p = pHead;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;pos; i++)&#123;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">        <span class="comment">//一定要判空，否则程序有bug</span></span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    pNew-&gt;number = val;</span><br><span class="line">    pNew-&gt;pNext = p-&gt;pNext;</span><br><span class="line">    p-&gt;pNext = pNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表的删除算法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">count_delete</span><span class="params">(PNODE pHead, <span class="keyword">int</span> pos , <span class="keyword">int</span> *val)</span></span>; <span class="comment">//函数声明，pos表示删除有效结点的第pos个</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">count_delete</span><span class="params">(PNODE pHead, <span class="keyword">int</span> pos , <span class="keyword">int</span> *val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PNODE p = pHead;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i&lt;pos ;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;pNext==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pNext==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PNODE tmp = p-&gt;pNext;</span><br><span class="line">    *val = tmp-&gt;number;</span><br><span class="line">    <span class="comment">//将p指针指向下下个结点</span></span><br><span class="line">    p-&gt;pNext = p-&gt;pNext-&gt;pNext;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/" data-id="clh1gtw8g003p90wcazc30lkh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE05" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/10/31/JavaEE05/" class="article-date">
  <time datetime="2022-10-31T05:58:35.000Z" itemprop="datePublished">2022-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/31/JavaEE05/">JavaEE05</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="request内置对象详解"><a href="#request内置对象详解" class="headerlink" title="request内置对象详解"></a>request内置对象详解</h2><h4 id="1-request内置对象的作用"><a href="#1-request内置对象的作用" class="headerlink" title="1. request内置对象的作用"></a>1. request内置对象的作用</h4><p>​    在JSP之中，request内置对象的主要工作就是服务器端接收客户端发送来的请求参数。</p>
<h4 id="2-request对象的继承结构"><a href="#2-request对象的继承结构" class="headerlink" title="2. request对象的继承结构"></a>2. request对象的继承结构</h4><p>​    request属于<code>javax.servlet.http.HttpServletRequest</code>接口的对象</p>
<table>
<thead>
<tr>
<th>继承结构</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public interface HttpServletRequest extends ServletRequest</td>
<td>扩展ServletRequest接口以提供HTTP servlet的请求信息</td>
</tr>
</tbody></table>
<p>​    注意：HttpServletRequest是继承<code>javax.servlet.ServletRequest</code>接口，但是ServletRequest接口只有一个子接口，不写成一个的原因是HttpServletRequest子接口是专门为了处理HTTP协议而提供的，而ServletRequest接口是负责所有相关协议的公共接口，以后可能还会有新的协议，新的协议要开发只需要让新的协议继续继承ServletRequest接口即可。</p>
<p>​    <strong>注意：如果以后要进行方法查询一定要两个接口一起看(从子接口开始找)，且所有提供接收参数的方法都在ServletRequest父接口提供</strong></p>
<h4 id="3-request内置对象解决传递参数乱码"><a href="#3-request内置对象解决传递参数乱码" class="headerlink" title="3. request内置对象解决传递参数乱码"></a>3. request内置对象解决传递参数乱码</h4><p>​    在使用form表单时，如果输入中文在提交后会变为中文乱码</p>
<p>​    在乱码问题的解决上需要考虑两种情况</p>
<ul>
<li><p>POST提交请求(表单上使用)：可以直接使用ServletRequest父接口定义的方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public void setCharacterEncoding(String env) throws UnsupportedEncodingException</td>
<td align="center">方法</td>
<td align="center">设置String env来重写此请求正文中使用的字符编码的名称。必须在使用getReader()读取请求参数或输入之前调用此方法。否则，它没有效果。</td>
</tr>
</tbody></table>
</li>
<li><p>GET提交请求(直接输入访问路径或者表单)：</p>
<p>Tomcat8以下的默认编码格式是<strong>ISO-8859-1</strong>，此时接收后需要进行编码的转换，以上就不用转了</p>
<p>如果是getParameter()方法其返回值为一个字符串，在String类中提供有改变字符串编码的方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public byte[] getBytes(String charsetName) throws UnsupportedEncodingException</td>
<td align="center">方法</td>
<td align="center">使用给定的字符集将此字符串编码为一个字节序列，并将结果存储到一个新的字节数组中。</td>
</tr>
<tr>
<td align="center">public String(byte[] bytes, String charsetName) throws UnsupportedEncodingException</td>
<td align="center">构造方法</td>
<td align="center">通过使用指定的字符集对指定的字节数组进行解码，构造新的String</td>
</tr>
</tbody></table>
<p>注意：<code>charsetName</code>表示要设置的字符集</p>
<p>将字符编码转换为<code>UTF-8</code>后再将字符数组使用上述构造方法设置为<code>UTF-8</code>转成String类型输出即可在页面正常显示</p>
</li>
</ul>
<p>​    在HttpServletRequest接口里面有一个方法，此方法可以判断出当前的请求模式</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public String getMethod()</td>
<td align="center">方法</td>
<td align="center">返回用于发出此请求的HTTP方法的名称，例如GET、POST或PUT。</td>
</tr>
</tbody></table>
<h4 id="4-POST与GET请求的区别"><a href="#4-POST与GET请求的区别" class="headerlink" title="4. POST与GET请求的区别"></a>4. POST与GET请求的区别</h4><ul>
<li>POST请求：主要用在表单上，处理路径只是提交路径其不会改变</li>
<li>GET请求：只要是用户直接进行页面访问，那么请求类型一定就是GET请求，表单上也可以使用GET请求，但是GET请求会将所有的请求参数都附加到表单访问路径上，所以不能够传递过多的内容，一般只能够传递4K~5K的内容</li>
</ul>
<p>​    注意：由于GET请求传递内容有限，所以一般使用POST请求</p>
<h4 id="5-request对象接收请求参数"><a href="#5-request对象接收请求参数" class="headerlink" title="5. request对象接收请求参数"></a>5. request对象接收请求参数</h4><p>​    <strong>request内置对象接收参数的来源</strong></p>
<ul>
<li><p>第一种来源：表单提交</p>
</li>
<li><p>第二种来源：标签指令传递(<code>&lt;jsp:include&gt;</code>、<code>&lt;jsp:forward&gt;</code>)</p>
</li>
<li><p>第三种来源：地址重写</p>
<p>地址重写的基本结构：<code>xxxxxx.jsp?参数名称=内容&amp;参数名称=内容...</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如以下代码为向inpuut.jsp页面传递了两个参数</span></span><br><span class="line">&lt;a href=&quot;input.jsp?msg=hello&amp;mid=30&quot;&gt;访问&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>地址重写相当于GET请求</p>
</li>
</ul>
<p>​    <strong>隐藏域</strong></p>
<p>​    在表单中有一种表单类型为隐藏域(其会跟着表单一起提交，但是其内容不能够由用户输入且用户无法看见隐藏域)</p>
<blockquote>
<input type="hidden" name ="name" value="lxs">
</blockquote>
<p>​    注意：一般隐藏域属于辅助的信息内容，一般都是固定好的</p>
<p>​    <strong>request内置对象的父类中提供有两个接收参数的方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public <strong>String</strong> getParameter(String name)</td>
<td align="center">方法</td>
<td align="center">以String形式返回请求参数的值，如果该参数不存在，则返回null。只有在确定参数只有一个值时，才应使用此方法。如果参数可能有多个值，请使用getParameterValues()</td>
</tr>
<tr>
<td align="center">public <strong>String[]</strong> getParameterValues(String name)</td>
<td align="center">方法</td>
<td align="center">返回包含给定请求参数的所有值的String对象数组，如果该参数不存在，则返回null。</td>
</tr>
</tbody></table>
<p>​    注意：getParameter只能接收一个内容，而getParameterValues可以接收一组内容</p>
<p>​    request内置对象提供返回全部请求参数名称的方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public Enumeration&lt;String&gt; getParameterNames()</code></td>
<td align="center">方法</td>
<td align="center">返回包含此请求中包含的参数名称的String对象的枚举。如果请求没有参数，该方法将返回空Enumeration。</td>
</tr>
</tbody></table>
<p>​    注意：通过这个方法就可以获得传递参数的名字，而通过传递参数的名字就可以获取到值</p>
<p>​    <strong>补充：Enumeration类(接口)</strong></p>
<p>​    Enumeration接口是Iterator迭代器的“古老版本”，从JDK 1.0开始，Enumeration接口就已经存在了(Iterator从JDK 1.2才出现)</p>
<p>​    Enumeration接口的方法介绍</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean hasMoreElements()</td>
<td align="center">方法</td>
<td align="center">这是检测Enumeration 对象是否还有元素，有则返回true,否则false</td>
</tr>
<tr>
<td align="center">E nextElement()</td>
<td align="center">方法</td>
<td align="center">如果Enumeration对象还有元素，该方法得到下一个元素</td>
</tr>
</tbody></table>
<p>​    </p>
<p>​    范例：动态的接收参数</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送方 form.jsp文件</span></span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span>%&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;request.jsp&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">	&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;text1&quot;</span> /&gt;</span><br><span class="line">	&lt;input type=<span class="string">&quot;checkbox&quot;</span> name=<span class="string">&quot;**box&quot;</span> value=<span class="string">&quot;1&quot;</span>&gt;<span class="number">1</span></span><br><span class="line">	&lt;input type=<span class="string">&quot;checkbox&quot;</span> name=<span class="string">&quot;**box&quot;</span> value=<span class="string">&quot;2&quot;</span>&gt;<span class="number">2</span></span><br><span class="line">	&lt;input type=<span class="string">&quot;checkbox&quot;</span> name=<span class="string">&quot;**box&quot;</span> value=<span class="string">&quot;3&quot;</span>&gt;<span class="number">3</span></span><br><span class="line">	&lt;input type=<span class="string">&quot;checkbox&quot;</span> name=<span class="string">&quot;**box&quot;</span> value=<span class="string">&quot;4&quot;</span>&gt;<span class="number">4</span></span><br><span class="line">	&lt;input type=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;submit1&quot;</span> value=<span class="string">&quot;提交&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收方 request.jsp文件</span></span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span>%&gt;</span><br><span class="line">&lt;%<span class="comment">//取得属性</span></span><br><span class="line">	request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">	Enumeration&lt;String&gt; e = request.getParameterNames();</span><br><span class="line">	<span class="keyword">while</span>(e.hasMoreElements())&#123;</span><br><span class="line">		String s = e.nextElement();</span><br><span class="line">		<span class="keyword">if</span>(s.startsWith(<span class="string">&quot;**&quot;</span>))&#123;</span><br><span class="line">			String[] str = request.getParameterValues(s);</span><br><span class="line">%&gt;</span><br><span class="line">			&lt;h3&gt;&lt;%=Arrays.toString(str)%&gt;&lt;/h3&gt;</span><br><span class="line">&lt;%</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">%&gt;</span><br><span class="line">			&lt;h4&gt;&lt;%=request.getParameter(s)%&gt;&lt;/h4&gt;</span><br><span class="line">&lt;%</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>​    注意：为了区分接收的一个参数是对应一个值还是多个值，对多个值参数在设置<code>name</code>属性时一般在前面加<code>**</code>，如<code>**XXXX</code>，用作区分</p>
<h4 id="6-通过request对象实现资源定位"><a href="#6-通过request对象实现资源定位" class="headerlink" title="6. 通过request对象实现资源定位"></a>6. 通过request对象实现资源定位</h4><p>​    在request对象中还有一个重要的操作方法：取得路径名称(该方法在<code>javax.servlet.http.HttpServletRequest</code>中定义)</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public String getContextPath()</td>
<td align="center">方法</td>
<td align="center">取得上下文路径</td>
</tr>
</tbody></table>
<p>​    getContextPath()取得的是整个虚拟目录的映射路径，在之前Tomcat的<code>conf/server.xml</code>中设置添加了<code>&lt;Context path = &quot;/lxs&quot; docBase = &quot;D:\lxsweb&quot; /&gt;</code>，getContextPath()方法取得的是<code>/lxs</code></p>
<p>​    通过取得整个虚拟目录的映射路径，我们可以实现资源定位。在实际开发中，我们会导入img、css、js，此时文件通常是使用传统<code>../</code>、<code>/</code>的形式进行引用，但此时如果代码文件发生移动，那么其的路径会发生变化则需要重写配置<code>../</code>、<code>/</code>。而使用getContextPath()可以解决这个问题。</p>
<p>​    范例：1.输出项目根路径，2.实现资源定位</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.jsp与images同级</span></span><br><span class="line"><span class="comment">//新建文件夹images，导入图片文件img_1.jpg</span></span><br><span class="line"><span class="comment">//编写文件test.jsp文件</span></span><br><span class="line">&lt;%<span class="meta">@page</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">	String contextpath = request.getContextPath();</span><br><span class="line">%&gt;</span><br><span class="line"><span class="comment">//输出项目根路径</span></span><br><span class="line">&lt;h1&gt;&lt;%=contextpath%&gt;&lt;/h1&gt;</span><br><span class="line"><span class="comment">//实现资源定位</span></span><br><span class="line">&lt;img src=<span class="string">&quot;&lt;%=contextpath%&gt;/images/img_1.jpg&quot;</span> height=<span class="string">&quot;40%&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>​    注意：此时不管test.jsp放在什么位置，图片都可以正常的显示出来，<strong>在实际开发中都会使用这种方式来引用资源</strong></p>
<h4 id="7-通过request对象取得基础信息"><a href="#7-通过request对象取得基础信息" class="headerlink" title="7. 通过request对象取得基础信息"></a>7. 通过request对象取得基础信息</h4><p>​    在<code>javax.servlet.http.HttpServletRequest</code>接口的父接口<code>javax.servlet.ServletRequest</code>中提供有取得其他基本信息的方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public String getRemoteAddr()</td>
<td align="center">方法</td>
<td align="center">返回发送请求的客户端或最后一个代理的IP地址</td>
</tr>
<tr>
<td align="center">public String getScheme()</td>
<td align="center">方法</td>
<td align="center">返回用于发出此请求的协议名称，例如http、https或ftp</td>
</tr>
<tr>
<td align="center">public String getServerName()</td>
<td align="center">方法</td>
<td align="center">返回请求发送到的服务器的主机名</td>
</tr>
<tr>
<td align="center">public int getServerPort()</td>
<td align="center">方法</td>
<td align="center">返回请求发送到的端口号</td>
</tr>
</tbody></table>
<p>​    范例：上述方法的使用以及获取项目的基本路径</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写文件path.jsp</span></span><br><span class="line">&lt;%<span class="meta">@page</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">	String ip = request.getRemoteAddr();</span><br><span class="line">	String scheme = request.getScheme();</span><br><span class="line">	String name = request.getServerName();</span><br><span class="line">	<span class="keyword">int</span> port = request.getServerPort();</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;ip地址：&lt;%=ip%&gt;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;协议：&lt;%=scheme%&gt;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;主机名：&lt;%=name%&gt;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;端口号：&lt;%=port%&gt;&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">	String path = request.getScheme()+<span class="string">&quot;://&quot;</span>+ request.getServerName()+<span class="string">&quot;:&quot;</span>+request.getServerPort()+request.getContextPath();</span><br><span class="line">%&gt;</span><br><span class="line">&lt;h1&gt;访问路径：&lt;%=path%&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>####8. getAttribute()和getParameter()的区别</p>
<p>​    1、getAttribute是返回(object)对象,getParameter返回字符串。</p>
<p>​    2、getAttribute可以返回格式化任意类型，getParameter只能返回字符串</p>
<p>​    3、与getAttribute()方法对应的有setAttribute()方法，但是没有与getParameter()相对的setParameter()</p>
<p>​    4、request.getAttribute获取的是服务器设置的数据，request.getParameter获取的是客户端比如浏览器的数据(获取http提交过来的数据)</p>
<p>​    5、getParameter方法就是服务器端接受客户端传递过来的数据时使用；getAttribute方法是在服务器端内部使用，数据通过getParameter获取进来之后，在另一个页面还想继续使用这个数据就要把这个数据通过setAttribute保存起来，想用时再用getAttribute取出来即可使用<br>​    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/31/JavaEE05/" data-id="clh1gtw7j001390wcg13d2kjm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaEE/" rel="tag">JavaEE</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 nature<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>