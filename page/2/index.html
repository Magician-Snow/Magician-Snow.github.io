<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Blog of ChiFun</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(/assets/blog.png)">
        </div>
    </section>
    <section class='menu'>
        <div>Blog of ChiFun</div>
        
            <div>Road is walked by me</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>  
          
            <a href="/about/" class="Btn">
              <li>About</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
            
                <a target="_blank" rel="noopener" href="https://github.com/Magician-Snow">
                    <img src="/assets/github.svg" />
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/12/08/MyBirthday-do2/">MyBirthday-do2</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-12-08T13:41:58.000Z" itemprop="datePublished">
    2021-12-08
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="送给自己生日的代码"><a href="#送给自己生日的代码" class="headerlink" title="送给自己生日的代码"></a>送给自己生日的代码</h2><h4 id="送给自己的话"><a href="#送给自己的话" class="headerlink" title="送给自己的话"></a>送给自己的话</h4><p>​    在新的一年，希望可以更加独立一些，就在本学期，我经历了低谷，感受到了许多–冷淡与不屑还有嘲讽。希望在新的一年里，可以自由控制自己的时间，而不是被时间撵着走，依靠自己的力量，完成许多看似不可能的事情，<strong>做自己的主人</strong></p>
<h4 id="生日代码-回望2021，致敬2022"><a href="#生日代码-回望2021，致敬2022" class="headerlink" title="生日代码(回望2021，致敬2022)"></a>生日代码(回望2021，致敬2022)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">              Thread game1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(<span class="string">&quot;王者&quot;</span>));</span><br><span class="line">              Thread game2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(<span class="string">&quot;哈利&quot;</span>));</span><br><span class="line">              Thread game3= <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(<span class="string">&quot;吃鸡&quot;</span>));</span><br><span class="line">              Thread game4 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(<span class="string">&quot;第五&quot;</span>));</span><br><span class="line"></span><br><span class="line">              System.out.println(<span class="string">&quot;每月游戏，每周一轮转&quot;</span>);</span><br><span class="line">              game1.start();</span><br><span class="line">              game2.start();</span><br><span class="line">              game3.start();</span><br><span class="line">              game4.start();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> game_num = <span class="number">4</span>;</span><br><span class="line">       <span class="keyword">private</span>  String name;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">              <span class="keyword">this</span>.name = name;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                     Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (game_num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                     game_num--;</span><br><span class="line">                     System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">                     Thread.currentThread().interrupt();</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/12/08/JavaEE-02-md/">JavaEE-02.md</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-12-08T05:23:50.000Z" itemprop="datePublished">
    2021-12-08
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/JavaEE/">JavaEE</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="JSP基础语法"><a href="#JSP基础语法" class="headerlink" title="JSP基础语法"></a>JSP基础语法</h2><h4 id="1-JSP注释"><a href="#1-JSP注释" class="headerlink" title="1. JSP注释"></a>1. JSP注释</h4><p>​    JSP中一共支持两种注释</p>
<ul>
<li><p>显式注释</p>
<p>使用的是HTML风格的注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注释--&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式注释</p>
<ul>
<li><p>使用Java语言提供的注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单行注释(&#x2F;&#x2F;)</span><br><span class="line">多行注释(&#x2F;* ... *&#x2F;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSP提供的注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%-- 注释 --%&gt;</span><br></pre></td></tr></table></figure>




</li>
</ul>
</li>
</ul>
<p>​    <strong>注释的区别</strong></p>
<p>​    运行之后只有显式注释的内容会发送到客户端上，即通过查看网页源代码可以看见</p>
<h4 id="2-三种Scriptlet"><a href="#2-三种Scriptlet" class="headerlink" title="2. 三种Scriptlet"></a>2. 三种Scriptlet</h4><p>​    <strong>Scriptlet指的是脚本小程序</strong>，在之前只要编写Java程序的语句都需要在”&lt;%%&gt;”之中进行编写，而这样的操作形式就称为Scriptlet，根据其作用不同，Scriptlet分为三类：&lt;%%&gt;、&lt;%!%&gt;、&lt;%=%&gt;</p>
<p>​    <strong>注意：一个JSP文件里面可以同时编写多个Scriptlet，且相互关联</strong></p>
<h5 id="第一种Scriptlet：-lt-gt"><a href="#第一种Scriptlet：-lt-gt" class="headerlink" title="第一种Scriptlet：&lt;%%&gt;"></a>第一种Scriptlet：&lt;%%&gt;</h5><p>​    在这种Scriptlet里面只能够编写局部变量、程序语句</p>
<p>​    范例：观察&lt;%%&gt;</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	<span class="comment">//局部变量，每次页面刷新(执行)都要重新执行(重复声明)</span></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">	out.println(<span class="string">&quot;&lt;h1&gt;&quot;</span>+num+<span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>​    一般，在一个JSP文件中使用的最多的就是“&lt;%%&gt;”，里面就定义一些基础的局部变量</p>
<h5 id="第二种Scriptlet：-lt-gt"><a href="#第二种Scriptlet：-lt-gt" class="headerlink" title="第二种Scriptlet：&lt;%!%&gt;"></a>第二种Scriptlet：&lt;%!%&gt;</h5><p>​    这种Scriptlet可以定义全局变量、全局常量、方法、类</p>
<p>​    范例：定义全局变量</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!        <span class="comment">//全局变量，只在第一次使用的时候声明</span></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">	out.println(<span class="string">&quot;&lt;h1&gt;&quot;</span>+num+++<span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>​    此时，随着页面刷新，显示的数字也会不断增加，重新打开界面仍为之前退出去前的数字</p>
<p>​    <strong>注意：一般不会这样使用代码来编写程序</strong></p>
<p>​    范例：定义全局常量</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!        </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="string">&quot;HELLO&quot;</span>;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">	out.println(<span class="string">&quot;&lt;h1&gt;&quot;</span>+str+<span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>​    <strong>基本上在“&lt;%!%&gt;”唯一能用到的只是用它定义全局常量(常量)</strong></p>
<p>​    范例：定义类和方法</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!        </span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">fish</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line">		<span class="keyword">private</span> String color;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">fish</span><span class="params">(String name,String color)</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">			<span class="keyword">this</span>.color = color;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getfish</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;name: &quot;</span>+<span class="keyword">this</span>.name +<span class="string">&quot; color : &quot;</span>+<span class="keyword">this</span>.color;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">buy</span><span class="params">(<span class="keyword">double</span> ... args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">double</span> x: args)&#123;</span><br><span class="line">			sum = sum+x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">	out.println(<span class="string">&quot;&lt;h1&gt;&quot;</span>+<span class="keyword">new</span> fish(<span class="string">&quot;red fish&quot;</span>,<span class="string">&quot;red&quot;</span>).getfish()+<span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">	out.println(<span class="string">&quot;&lt;h1&gt;&quot;</span>+buy(<span class="number">11.1</span>,<span class="number">56.3</span>)+<span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>​    一般也不会这样写代码，只有业余的那部分人会在JSP里面直接编写一堆的Java类或者是方法。</p>
<h5 id="第三种Scriptlet：-lt-gt"><a href="#第三种Scriptlet：-lt-gt" class="headerlink" title="第三种Scriptlet：&lt;%=%&gt;"></a>第三种Scriptlet：&lt;%=%&gt;</h5><p>​    out.println()是向页面中进行内容显示输出，但是在JSP里面，<strong>如果要想输出某个变量或者常量，以及方法的返回值，可以使用表达式输出的Scriptlet完成：&lt;%=%&gt;</strong></p>
<p>​    范例：观察表达式输出</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!        </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="string">&quot;HELLO&quot;</span>;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;&lt;%=str%&gt;&lt;h1&gt;</span><br></pre></td></tr></table></figure>

<p>​    这种Scriptlet可以很好的代替out.println()</p>
<p>​    <strong>那么这两种输出方式选哪种</strong></p>
<p>​    范例：使用两种形式打印乘法口诀表</p>
<p>1.使用out.println()打印</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	out.println(<span class="string">&quot;&lt;table&gt;&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span> ; x &lt;= <span class="number">9</span> ; x++)&#123;</span><br><span class="line">		out.println(<span class="string">&quot;&lt;tr&gt;&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">1</span> ; y&lt;=x ;y++)&#123;</span><br><span class="line">			out.println(<span class="string">&quot;&lt;td&gt;&quot;</span>+x+<span class="string">&quot;*&quot;</span>+ y+<span class="string">&quot;=&quot;</span>+x*y+<span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		out.println(<span class="string">&quot;&lt;/tr&gt;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">	out.println(<span class="string">&quot;&lt;/table&gt;&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>​    以上代码完成了开发需要，但是存在如下问题</p>
<ul>
<li><p>不方便使用任何的网页设计工具进行调试</p>
<ul>
<li>代码没有缩进，输出的代码格式不适合浏览</li>
</ul>
</li>
</ul>
<p>2.使用表达式输出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">&lt;%</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span> ; x &lt;= <span class="number">9</span> ; x++)&#123;</span><br><span class="line">%&gt;</span><br><span class="line">	&lt;tr&gt;</span><br><span class="line">&lt;%</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">1</span> ; y&lt;x ;y++)&#123;</span><br><span class="line">%&gt;</span><br><span class="line">		&lt;td&gt;&lt;%=x%&gt;*&lt;%=y%&gt;=&lt;%=x*y%&gt;&lt;/td&gt;</span><br><span class="line">&lt;%</span><br><span class="line">		&#125;</span><br><span class="line">%&gt;</span><br><span class="line">	&lt;/tr&gt;</span><br><span class="line">&lt;%</span><br><span class="line">	&#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<p>​    此时的程序与out.println()相比最大的好处在于代码简化，而且功能又相同</p>
<p>​    <strong>注意：在以后的所有开发中，只要是JSP页面不允许使用out.println()输出，JSP的内容输出永远都依靠表达式输出完成</strong></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>​    如果把JSP页面当成一个Java类的话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class xxx.jsp&#123;</span><br><span class="line">	全局变量; &lt;%!%&gt;</span><br><span class="line">	全局常量; &lt;%!%&gt;</span><br><span class="line">	public void 方法()&#123;</span><br><span class="line">		局部变量;&lt;%%&gt;</span><br><span class="line">		语句;&lt;%%&gt;</span><br><span class="line">		输出;&lt;%&#x3D;%&gt;</span><br><span class="line">	&#125;</span><br><span class="line">	class 内部类&#123;&#125;&lt;%!%&gt;</span><br><span class="line">	方法;&lt;%!%&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-page指令"><a href="#3-page指令" class="headerlink" title="3. page指令"></a>3. page指令</h4><p>​    page是JSP页面开发中用到的最多的一个操作</p>
<p>​    <strong>page指令的语法格式</strong></p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page attr1 = <span class="string">&quot;value1&quot;</span> attr2 = <span class="string">&quot;value2&quot;</span> ... %&gt;</span><br></pre></td></tr></table></figure>



<p>​    page主要功能是定义一个页面中的全部属性，里面会包含很多的选项</p>
<h5 id="1-解决显示乱码"><a href="#1-解决显示乱码" class="headerlink" title="1. 解决显示乱码"></a>1. 解决显示乱码</h5><p>​    (1).如果是一个HTML文件，对于乱码可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meta charset &#x3D; &#39;UTF-8&#39;</span><br></pre></td></tr></table></figure>

<p>的方式解决，<strong>此举为指定了页面的编码</strong>，浏览器在解析的时候已经知道了编码，就可以准确的使用特定的解码方式进行显示</p>
<p>​    (2).<strong>如果要设置浏览器支持的编码(浏览器会有默认的解码格式)，可以使用pageEncoding属性完成</strong></p>
<p>​    范例：设置浏览器的编码(.jsp文件)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> pageEncoding = <span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;h1&gt;中文&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>​    <strong>注意：pageEncoding的编码设置只能一次，多次会报错</strong></p>
<p>​    (3).设置MIME类型</p>
<p>​    MIME指的是多路Internet媒体访问协议。相当于通过MIME类型定义出当前页面的执行方式</p>
<p>​    所有支持的MIME类型都在Tomcat安装目录中/conf/web.xml文件里面定义，<strong>里面定义了各种文件的执行方式</strong></p>
<p>​    范例：设置MIME类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;%&gt;</span><br><span class="line">&lt;h1&gt;中文&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>

<p>​    <strong>注意：不要乱加空格，尤其是等号那里</strong></p>
<p>​    这个设置与上面的第二种不冲突</p>
<p>​    <strong>contentType为MIME类型，设置文件运行方式，可以更改为其他形式，如更改为word形式</strong></p>
<p>​    范例：使用word运行程序</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;application/msword&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;h1&gt;中文&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>​    此时运行会弹出下载框，下载word文件，<strong>这个在ie中才明显，一般浏览器感受不到</strong></p>
<h5 id="2-导入系统开发包"><a href="#2-导入系统开发包" class="headerlink" title="2. 导入系统开发包"></a>2. 导入系统开发包</h5><p>​     在page指令里面几乎所有的指令都只能够设置一次，但是import指令可以使用多次，表示导入开发包</p>
<p>​    范例：导入开发包(可以一行导入也可以多行导入)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.*,java.text.*&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span>%&gt;</span><br><span class="line">&lt;h1&gt;&lt;%=new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date())%&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>​    只要能导包，那么所有的系统类都可以调用</p>
<h5 id="3-数据库操作"><a href="#3-数据库操作" class="headerlink" title="3. 数据库操作"></a>3. 数据库操作</h5><p>​    因为可以进行导包操作，所以意味着可以在JSP页面上进行数据库的数据操作</p>
<p>​    对于要进行数据库操作的驱动程序，都需要拷贝到TomcatHOME/lib目录下即可(Tomcat需要重新启动才能加载新的包)</p>
<p>​    <strong>实际上，所有在JSP中的显示的内容永远都不是固定的，都是由程序动态生成的，在WebContainer中负责生成要显示的代码</strong></p>
<h4 id="4-包含指令"><a href="#4-包含指令" class="headerlink" title="4. 包含指令"></a>4. 包含指令</h4><p>​    一般要进行页面开发时都需要包含如下结构：菜单栏、头部信息、<strong>中间显示信息</strong>、尾部信息</p>
<p>​    一般都是中间显示信息发生变化，为实现这个有两种显示方式</p>
<ul>
<li>在每一个显示的页面里面重复包含有“菜单栏”、“头部信息”、“尾部信息”，这三个重复内容</li>
<li>将“菜单栏”、“头部信息”、“尾部信息”分别定义为三个文件，在需要的地方进行引用</li>
</ul>
<p>​    很明显第二种更加适合代码维护，所以此处就需要使用包含指令，但<strong>在JSP中对于包含指令有两种提供形式</strong></p>
<h5 id="1-静态包含：-lt-include-gt"><a href="#1-静态包含：-lt-include-gt" class="headerlink" title="1. 静态包含：&lt;%@include%&gt;"></a>1. 静态包含：&lt;%@include%&gt;</h5><p>​    静态包含的语法：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">&quot;包含文件路径&quot;</span>%&gt;</span><br></pre></td></tr></table></figure>

<p>​    <strong>它可以包含任意的文件内容</strong></p>
<p>​    范例：实现静态包含操作(定义几个被包含的页面)   </p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.jsp页面</span></span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">&#x27;UTF-8&#x27;</span>%&gt;</span><br><span class="line">&lt;% String str = <span class="string">&quot;这是页面一&quot;</span>;%&gt;</span><br><span class="line">&lt;%=str%&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.html页面</span></span><br><span class="line">&lt;meta charset = <span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">&#x27;UTF-8&#x27;</span>%&gt; <span class="comment">//保证引用后页面中文不会乱码</span></span><br><span class="line">&lt;h1&gt;这是页面2&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//all.jsp</span></span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">&quot;2.html&quot;</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">&quot;1.jsp&quot;</span>%&gt;</span><br></pre></td></tr></table></figure>

<p>​    <strong>注意：使用jsp包含html页面时，会一起编译为java代码进行处理，此时就需要对html页面进行设置防止乱码</strong></p>
<p>​    在这个程序中文件名为中文不影响结果</p>
<p>​    此时所有的页面都被包含显示在all.jsp中</p>
<h5 id="2-动态包含：jsp-include"><a href="#2-动态包含：jsp-include" class="headerlink" title="2. 动态包含：jsp:include"></a>2. 动态包含：<a href="jsp:include">jsp:include</a></h5><p>​    静态包含只是简单的将文件进行包含，而动态包含可以分为两种情况处理</p>
<ul>
<li><p>情况一：被包含的页面属于静态文件，那么就行静态包含一样直接将内容导入进去</p>
</li>
<li><p>情况二：被包含的页面属于动态页面，则要分别处理后再进行包含</p>
</li>
</ul>
<p>​    注意：动态包含给出的指令形式属于标签指令，标签指令最后必须完结</p>
<p>​    动态包含的语法格式定义：</p>
<ul>
<li><p>定义一：包含的时候不传递参数</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">&quot;路径&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>定义二：包含的时候传递参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page&#x3D;&quot;路径&quot;&gt;</span><br><span class="line">	&lt;jsp:param name&#x3D;&quot;参数名称&quot; value&#x3D;&quot;参数内容&quot;&#x2F;&gt;</span><br><span class="line">	&lt;jsp:param name&#x3D;&quot;参数名称&quot; value&#x3D;&quot;参数内容&quot;&#x2F;&gt;</span><br><span class="line">	&lt;jsp:param name&#x3D;&quot;参数名称&quot; value&#x3D;&quot;参数内容&quot;&#x2F;&gt;</span><br><span class="line">	...</span><br><span class="line">&lt;&#x2F;jsp:include&gt;</span><br></pre></td></tr></table></figure>

<p><strong>这里是指向那个页面传参再显示那个页面</strong></p>
</li>
</ul>
<p>​    对于所有参数的接收方式为使用request.getParameter()完成</p>
<p>​    范例：实现参数的发送和接收</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;send.jsp,发送并显示receive.jsp界面</span><br><span class="line">&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;jsp:include page&#x3D;&quot;receive.jsp&quot;&gt;</span><br><span class="line">	&lt;jsp:param name&#x3D;&quot;a&quot; value&#x3D;&quot;刘旭晟&quot;&#x2F;&gt;</span><br><span class="line">	&lt;jsp:param name&#x3D;&quot;do&quot; value&#x3D;&quot;说&quot;&#x2F;&gt;</span><br><span class="line">	&lt;jsp:param name&#x3D;&quot;proclaim&quot; value&#x3D;&quot;共产党万岁&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;jsp:include&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;receive.jsp,接收传过来的数据</span><br><span class="line">&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%&#x3D;request.getParameter(&quot;a&quot;)%&gt;</span><br><span class="line">&lt;%&#x3D;request.getParameter(&quot;do&quot;)%&gt;</span><br><span class="line">&lt;%&#x3D;request.getParameter(&quot;proclaim&quot;)%&gt;</span><br></pre></td></tr></table></figure>

<p>​    <strong>注意：标签指令不能够写在scriptlet代码里面，只能够像HTML代码那样写</strong>，如果要传参需要在value的值里面使用Scriptlet</p>
<h5 id="3-动态包含和静态包含的区别"><a href="#3-动态包含和静态包含的区别" class="headerlink" title="3. 动态包含和静态包含的区别"></a>3. 动态包含和静态包含的区别</h5><p>​    在静态导入时，如果导入的页面定义了Scriptlet变量且本页面也定义了一个一模一样名字的变量，则<strong>页面显示报错，如果执行报错后依然再次刷新会把错误给刷新没</strong></p>
<p>​    <strong>静态包含的最大特点为：先把内容包含到一起，而后一起进行处理</strong></p>
<p>​    在动态导入时，如果导入的页面定义了Scriptlet变量且本页面也定义了一个一模一样名字的变量，页面照常显示没有影响</p>
<p>​    <strong>动态包含的特点：</strong></p>
<ul>
<li>如果被包含页面是动态页面(*.jsp)，那么先分别处理两个页面的操作，而后将结果包含进来</li>
<li>如果被包含的页面是静态页面(*.txt)，那么只是将文件内容简单的导入进来</li>
</ul>
<p>​    动态包含相比静态包含可以在不同页面重复定义变量，更加安全</p>
<h4 id="5-跳转指令"><a href="#5-跳转指令" class="headerlink" title="5. 跳转指令"></a>5. 跳转指令</h4><p>​    跳转：从一个JSP页面可以跳转到另外一个JSP或其他页面</p>
<p>​    <strong>跳转指令依然输入标签指令形式，所以在跳转指令完成操作后依然要进行标签完结</strong></p>
<p>​    跳转指令的两种定义形式：</p>
<ul>
<li><p>定义一：不向跳转页面传递参数：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page=<span class="string">&quot;路径&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>定义二：向跳转页面传递参数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page=<span class="string">&quot;路径&quot;</span>&gt;</span><br><span class="line">	&lt;jsp:param name=<span class="string">&quot;参数名称&quot;</span> value=<span class="string">&quot;参数内容&quot;</span>/&gt;</span><br><span class="line">	&lt;jsp:param name=<span class="string">&quot;参数名称&quot;</span> value=<span class="string">&quot;参数内容&quot;</span>/&gt;</span><br><span class="line">	&lt;jsp:param name=<span class="string">&quot;参数名称&quot;</span> value=<span class="string">&quot;参数内容&quot;</span>/&gt;</span><br><span class="line">	...</span><br><span class="line">&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>​    范例：实现跳转</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要跳转到的界面</span></span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;h1&gt;&lt;%=request.getParameter(&quot;paramA&quot;)%&gt;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;&lt;%=request.getParameter(&quot;paramB&quot;)%&gt;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳转界面</span></span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;jsp:forward page=<span class="string">&quot;param.jsp&quot;</span>&gt;</span><br><span class="line">	&lt;jsp:param name=<span class="string">&quot;paramA&quot;</span> value=<span class="string">&quot;int&quot;</span>/&gt;</span><br><span class="line">	&lt;jsp:param name=<span class="string">&quot;paramB&quot;</span> value=<span class="string">&quot;double&quot;</span>/&gt;</span><br><span class="line">&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure>

<p>​    跳转之后地址栏不发生改变，但页面内容发生改变，<strong>这种跳转称为服务器端跳转</strong></p>
<p>​    <strong>还有一种跳转会连地址栏一起跳转的叫客户端跳转</strong>，实现方式是使用Javascript，或者可以使用超链接跳转也是一样的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="built_in">window</span>.location = <span class="string">&quot;param.jsp&quot;</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​    <strong>结论</strong>    </p>
<p>​    地址栏不改变的跳转称为服务器跳转</p>
<p>​    地址栏改变的跳转称为客户端跳转</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/11/15/JavaEE-01/">JavaEE-01</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-11-15T12:12:39.000Z" itemprop="datePublished">
    2021-11-15
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/JavaEE/">JavaEE</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="Web与Tomcat"><a href="#Web与Tomcat" class="headerlink" title="Web与Tomcat"></a>Web与Tomcat</h2><h4 id="1-Web的简介"><a href="#1-Web的简介" class="headerlink" title="1. Web的简介"></a>1. Web的简介</h4><p>​    WEB最早出现是为了展示科研产品，到现在其发展超过预期，从WEB开始整个互联网的行业发生了变化</p>
<p>​    不管怎么改变WEB的处理流程永远都只有两种形式：<strong>静态WEB和动态WEB</strong></p>
<p>​    (1).静态WEB</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IcNA3T"><img src="https://z3.ax1x.com/2021/11/14/IcNA3T.png" alt="IcNA3T.png"></a></p>
<p>​    在WEB中分为客户端与服务器端，而客户端主要通过WEB浏览器访问服务器端，并且使用的是HTTP协议</p>
<p>​    静态WEB的实现主要技术是：HTML、CSS、Javascript</p>
<p>​    <strong>静态WEB的缺点：无法操作数据库</strong></p>
<p>​    (2).动态WEB</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Icaq41"><img src="https://z3.ax1x.com/2021/11/14/Icaq41.png" alt="Icaq41.png"></a></p>
<p>​    动态WEB与静态WEB一样，客户端上依然使用普通的WEB浏览器进行访问，但是服务器端的操作发生了变化</p>
<p>​    用户发送来的请求将由WEB服务插件进行接收，插件的主要功能是区分用户发送过来的是动态的还是静态的请求( * .htm为静态请求、 * .jsp为动态请求)，如果是静态请求，则由Web Server调用文件系统中的指定文件内容并发回给客户端(与静态Web相同)，但是如果发送为动态请求，则所有的请求交由Web容器进行处理。Web容器负责拼凑代码，拼凑完后交由Web Server返回给用户进行展示</p>
<p>​    <strong>动态Web的最大特征：交互性</strong></p>
<p>​    由于有Web容器的支持，所以动态Web可以进行数据库的连接访问</p>
<p>​    动态Web需要进行拼凑，所以总体上静态Web会快于动态Web</p>
<p>​    <strong>动态Web的实现可以使用的技术</strong></p>
<p>​    CGI，ASP，PHP，Servlet/JSP(Java做前台太费钱，也费劲)，RUBY，<strong>Node.JS</strong>，<strong>Python</strong></p>
<p>​    没有加粗的不用看，都是夕阳</p>
<p>​    核心本质没有变，还是Java处理整个后端业务(大脑)</p>
<p>​    <strong>注意：Web Container（Web容器）是决定整个动态Web的核心，所有的代码一定是拼凑而成，拼凑完后还是HTML代码</strong></p>
<h4 id="2-Tomcat的安装与配置"><a href="#2-Tomcat的安装与配置" class="headerlink" title="2. Tomcat的安装与配置"></a>2. Tomcat的安装与配置</h4><p>​    Tomcat是符合JavaEE标准的最小的Web容器</p>
<p>​    <strong>服务器与容器的区别</strong></p>
<p>​    服务器中会包含容器，除了容器之外服务器中还可能包含一些组件，例如：事务处理</p>
<p>​    <strong>Tomcat的下载</strong></p>
<p>​    去官网下载安装版，Tomcat本身很小，所以电脑上需要有额外的JDK</p>
<p>​    安装完成后会自动在Windows的服务里面进行服务的注册，但是不可以在这里启动</p>
<p>​    <strong>Tomcat的安装目录</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Apache Software Foundation\Tomcat 10.0</span><br></pre></td></tr></table></figure>

<ul>
<li><p>bin：包含了所有的可执行的程序命令，使用“Tomcat10.exe”命令可以启动Tomcat服务器，<strong>打开服务器之后，就可以利用浏览器访问，输入：<a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a></strong></p>
</li>
<li><p>conf：包含了所有的配置文件路径信息</p>
</li>
<li><p>lib：这是一个Tomcat自己的CLASSPATH，可以在里面配置第三方的jar文件</p>
</li>
<li><p>logs：负责所有日志文件的保存目录</p>
</li>
<li><p>webapps：为项目的自动部署目录</p>
</li>
<li><p>work：保存所有的临时生成文件，如果程序则么都运行不了，但又没有错，可以考虑将此目录清空</p>
</li>
</ul>
<p>​    <strong>Tomcat的使用（配置虚拟目录）</strong></p>
<p>​    如果要在项目中使用Tomcat必须配置虚拟目录（核心）</p>
<p>​    虚拟目录指的就是工作目录，即，如果进行Web项目的开发，需要有一个指定结构的目录进行内容的保存，并且要在Tomcat中配置此目录</p>
<ol>
<li><p>在D盘建立一个lxsWeb的目录，这个目录作为虚拟目录存在</p>
</li>
<li><p>这个目录是有建立要求的，在这个目录中必须存在有一个WEB-INF/web.xml(大小写不能错)文件（从Tomcat的安装目录webapps-&gt;ROOT可以拷贝出来）</p>
</li>
<li><p>此时Tomcat不知道硬盘存在此目录，所以需要修改Tomcat的配置文件(conf/server.xml),在“</Host>”之上编写，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context path &#x3D; &quot;&#x2F;lxs&quot; docBase &#x3D; &quot;D:\lxsweb&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>配置意义：</p>
<ul>
<li><Context>：表示配置一个新的上下文</li>
<li>path：为浏览器上的输入路径(<a target="_blank" rel="noopener" href="http://lacalhost:8080/lxs)%EF%BC%8C%E5%90%8D%E7%A7%B0%E4%B8%8D%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D%EF%BC%8C%E4%B8%94%E5%BF%85%E9%A1%BB%E6%9C%89/">http://lacalhost:8080/lxs)，名称不允许重复，且必须有/</a></li>
<li>docBase：配置项目的磁盘路径，此目录下必须存在WEB-INF</li>
</ul>
</li>
<li><p>在默认情况下，如果直接输入路径那么会出现404(HTTP状态码，表示路径不可使用)错误，是因为没有输入里面的具体执行文件名称，从Tomca6.5开始关闭了页面列表功能，此时通过修改conf/web.xml文件打开列表，查找文件中listings，把其值改为true，此时就可以进行列表显示</p>
</li>
<li><p>默认情况下，所有的网络服务器都是有监听端口的，Tomcat默认的端口为8080端口，但是如果不想输入端口，则可以将监听端口设置为80这个默认端口，直接修改conf/server.xml文件即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot; &#x2F;&#x2F;8080改为80</span><br></pre></td></tr></table></figure>

<p>此时访问时就不需要使用端口了：<a target="_blank" rel="noopener" href="http://localhost/lxs/%EF%BC%8C%E6%AD%A4%E6%97%B6%E5%A6%82%E6%9E%9C%E5%8A%A0%E4%BA%868080%E5%8F%8D%E8%80%8C%E8%BF%9B%E4%B8%8D%E5%8E%BB">http://localhost/lxs/，此时如果加了8080反而进不去</a></p>
</li>
<li><p>也可以不使用localhost改用本机ip，通过cmd输入ipconfig，其中的IPv4地址，为本机ip地址</p>
</li>
</ol>
<p><strong>注意：所有的配置文件修改后，Tomcat需要重新启动才可以加载到新的内容</strong></p>
<h4 id="3-第一个JSP程序"><a href="#3-第一个JSP程序" class="headerlink" title="3. 第一个JSP程序"></a>3. 第一个JSP程序</h4><p>​    范例：在页面上输出”hello world”</p>
<p>​    此时需要定义一个JSP文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello JSP<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		&lt;%	//此处为JSP代码</span><br><span class="line">			out.println(&quot;hello world&quot;); //页面输出</span><br><span class="line">		%&gt;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    程序要想正常执行，必须将其保存在服务器工作区内(虚拟目录)，随后打开浏览器输入访问地址执行<a target="_blank" rel="noopener" href="http://localhost/lxs/Hello.jsp">http://localhost/lxs/Hello.jsp</a></p>
<p>​    <strong>一般第一次会比第二次慢</strong></p>
<p>​    图示：Tomcat的原理</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/I24uXF"><img src="https://z3.ax1x.com/2021/11/15/I24uXF.png" alt="I24uXF.png"></a></p>
<ol>
<li><p>如果用户要访问服务器端的程序将通过浏览器输入访问地址</p>
</li>
<li><p>而后服务器端要读取hello.jsp文件，但这个时候并不是直接将这个文件发送给客户端</p>
</li>
<li><p>服务器端把hello.jsp文件变为*.java的文件，并且会自动将这个 *.java文件自动编译为 *.class文件</p>
</li>
<li><p>随后将执行生成的*.class文件，并且通过服务器端解析生成为HTML代码后发送给客户端浏览器</p>
<p>也就是说第一次执行*.jsp文件的时候需要将其转换和编译后才可以执行，而第二次访问由于 *.class文件已经存在，不会再执行上面操作所以速度就快，但是如果文件发生变化，那么就会重新转换、编译</p>
</li>
</ol>
<p><strong>注意：所有转换和编译后的文件都保存在work目录下</strong></p>
<p>​    <strong>如果电脑变慢可能导致这个流程异常，即怎样修改文件都执行无变化，此时将Tomcat关上，而后将work目录清空即可</strong></p>
<p>​    范例：输出更多内容</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello JSP<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		&lt;%	//此处为JSP代码</span><br><span class="line">			out.println(&quot;hello world&quot;); //页面输出</span><br><span class="line">			out.println(&quot;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&quot;); </span><br><span class="line">			out.println(&quot;<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span> = <span class="string">&#x27;text/javascript&#x27;</span>&gt;</span><span class="javascript">alert(<span class="string">&#x27;hello world&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;); </span><br><span class="line">		%&gt;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    <strong>关系</strong></p>
<p>​        <strong>JavaScript可以控制HTML代码的输出</strong></p>
<p>​        <strong>JSP可以控制JavaScript与HTML代码的输出</strong></p>
<h4 id="4-接收客户端请求参数"><a href="#4-接收客户端请求参数" class="headerlink" title="4. 接收客户端请求参数"></a>4. 接收客户端请求参数</h4><p>​    动态Web最大的特征就是交互性，而交互性的关键是必须由用户输入数据，在HTML中已经提供了表单给用户进行输入数据的空间，而所有的输入数据应由服务器端进行接收</p>
<p>​    <strong>如果要在服务器端接收数据可以使用操作：request.getParameter(String 参数名称name)，该操作返回的是String型数据(可以通过正则验证且可以向任意数据类型转换)</strong></p>
<p>​    范例：编写表单–input.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span> = <span class="string">&quot;input.jsp&quot;</span> <span class="attr">method</span> = <span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">	请输入信息：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;text&quot;</span> <span class="attr">name</span> = <span class="string">&quot;msg&quot;</span> <span class="attr">id</span> = <span class="string">&quot;msg&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;submit&quot;</span> <span class="attr">value</span> = <span class="string">&quot;send&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    当点击提交按钮之后会自动的将表单的输入参数内容发送给服务器端，服务器端可以进行接收</p>
<p>​    范例：接收参数–input.jsp</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	String str = request.getParameter(&quot;msg&quot;);</span><br><span class="line">	out.println(&quot;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>&quot;+str+&quot;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&quot;);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>​    此时用客户端输入的内容都可以接收到</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/11/11/Java15/">Java15</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-11-11T06:25:01.000Z" itemprop="datePublished">
    2021-11-11
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h2><h4 id="1-多线程编程的本质就是并发编程"><a href="#1-多线程编程的本质就是并发编程" class="headerlink" title="1. 多线程编程的本质就是并发编程"></a>1. 多线程编程的本质就是并发编程</h4><p>​    并发编程的本质是指的发挥出所有硬件的最大性能</p>
<p>​    Java是为数不多的真正支持有多线程并发编程的开发语言，所以在整体的处理性能上是最高的</p>
<p>​    而python是多进程编程的注意区分</p>
<h4 id="2-进程"><a href="#2-进程" class="headerlink" title="2. 进程"></a>2. 进程</h4><p>​    传统硬件只有一个CPU(单核CPU)，为了发挥硬件的全部性能，引入了多进程编程模式</p>
<ul>
<li>进程指的是一个具有一定独立功能的程序关于某个数据集合的一次运行活动</li>
<li>进程是系统进行资源分配和调度运行的基本单位</li>
<li>进程实体中包含有三个组成部分：“程序”、“数据”、“PCB(进程控制块)”</li>
</ul>
<h4 id="3-单进程运行与多进程运行的区别"><a href="#3-单进程运行与多进程运行的区别" class="headerlink" title="3. 单进程运行与多进程运行的区别"></a>3. 单进程运行与多进程运行的区别</h4><p>​    单进程运行<br>​    所有的系统资源都为一个进程服务，该进程资源独享</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5oHkGR"><img src="https://z3.ax1x.com/2021/10/26/5oHkGR.png" alt="5oHkGR.png"></a></p>
<p>​    多进程运行<br>​    在没有拓展原始系统硬件资源的前提下，利用一些算法，实现多个进程的并行执行</p>
<p>​    在每个进程执行时要独享全部资源，即在同一个时间点上只会有一个进程执行</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5o7LPs"><img src="https://z3.ax1x.com/2021/10/26/5o7LPs.png" alt="5o7LPs.png"></a></p>
<h4 id="4-线程"><a href="#4-线程" class="headerlink" title="4. 线程"></a>4. 线程</h4><p>​    线程是在进程基础上的进一步划分，可以达到更快的处理性能，任何一个进程的启动都是非常缓慢的，线程性能上远高于进程，但是线程不可以离开进程存活</p>
<p>​    进程与线程图示</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5oqIr6"><img src="https://z3.ax1x.com/2021/10/26/5oqIr6.png" alt="5oqIr6.png"></a></p>
<p>​    每一个进程都只有一个自己的重要处理单元，如果要想实现CPU(变量信息等)的共享，则必须利用线程来描述</p>
<p>​    一般来说，每一块CPU只会有一个线程执行，但有一些CPU可以使用超线程技术，设计出若干个多线程的执行状态，这叫<strong>超线程</strong></p>
<h4 id="5-并行编程"><a href="#5-并行编程" class="headerlink" title="5. 并行编程"></a>5. 并行编程</h4><p>​    随着硬件和软件技术的发展，硬件中的CPU出现了多核状态，理论上多核CPU的多进程执行称为并行编程</p>
<h4 id="6-纤-协-程"><a href="#6-纤-协-程" class="headerlink" title="6. 纤(协)程"></a>6. 纤(协)程</h4><p>​    在进程和线程的概念之上还有一个叫纤(协)程，是在线程基础上进一步划分，并不是像进程和线程一样由硬件支持，协程用的是由程序控制的<br>​    Java并没有支持有多协程编程（不代表以后没有），像python是支持多协程的</p>
<h4 id="7-多线程编程起步"><a href="#7-多线程编程起步" class="headerlink" title="7. 多线程编程起步"></a>7. 多线程编程起步</h4><p>​    所有的Java程序是通过主方法完成的，主方法作为程序的起点。而要进行多线程的编程也需要一个线程的起点结构，此结构称为线程类，所有的线程类是有继承要求的，可以有三种实现模式：<strong>继承Thread类、实现Runnable接口、实现Callable接口(两个接口更重要)</strong></p>
<h5 id="1-继承Thread类的实现多线程"><a href="#1-继承Thread类的实现多线程" class="headerlink" title="1. 继承Thread类的实现多线程"></a>1. 继承Thread类的实现多线程</h5><p>​    java.lang.Thread是由系统定义的一个线程处理类，<em>任何的子类只需要继承此类就可以得到一个线程处理的能力，在使用时一定要覆写Thread类中的run()方法</em>，<strong>这个方法将作为一个线程启动的主方法存在</strong></p>
<p>​    范例：定义一个<strong>线程主体类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread&#123; &#x2F;&#x2F;得到了一个线程主体类</span><br><span class="line">	private String name;</span><br><span class="line">	public MyThread(String name) &#123; &#x2F;&#x2F;保存线程名称</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public void run() &#123; &#x2F;&#x2F;覆写run()方法</span><br><span class="line">		for(int x &#x3D; 0; x &lt; 30 ; x++) &#123;</span><br><span class="line">			System.out.println(&quot;【&quot;+this.name+&quot;线程】运行，x &#x3D; &quot;+x);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>线程中主方法类和线程类的关系</strong><br>​    要在主类的主方法中启动线程<br>​    线程一般会多个交替执行，所以无法通过调用run()方法来调用线程<br>​    通过start()方法来开启线程<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/IpE5DS"><img src="https://z3.ax1x.com/2021/10/31/IpE5DS.png" alt="IpE5DS.png"></a></p>
<p>​    <strong>如果想要进行多线程的并发执行，则需要调用机器上操作系统提供的底层函数支持，所有多线程启动并不是依靠调用run()方法完成的，它需要通过start()方法进行启动，所有start()方法启动之后将调用run()方法中定义的方法体</strong></p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public void start()</td>
<td align="center">方法</td>
<td align="center">使线程开始执行，不能重复启动同一个进程，会造成异常</td>
</tr>
</tbody></table>
<p>​    <strong>注意：所有线程的启动只能依靠Thread.start()方法</strong></p>
<p>​    范例：启动多线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread a = <span class="keyword">new</span> MyThread();</span><br><span class="line">		Thread b = <span class="keyword">new</span> MyThread();</span><br><span class="line">		Thread c = <span class="keyword">new</span> MyThread();</span><br><span class="line">		a.start();</span><br><span class="line">		b.start();</span><br><span class="line">		c.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span> ; i++)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;线程&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    所有线程对象交替执行run()方法中的内容</p>
<p>​    <strong>在start()方法里面调用了一个start0()方法，该方法没有方法体，但由关键字native来定义，此关键字的作用在于表示此操作交由底层实现</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IpeYNQ"><img src="https://z3.ax1x.com/2021/10/31/IpeYNQ.png" alt="IpeYNQ.png"></a></p>
<h5 id="2-实现Runnable接口实现多线程"><a href="#2-实现Runnable接口实现多线程" class="headerlink" title="2. 实现Runnable接口实现多线程"></a>2. 实现Runnable接口实现多线程</h5><p>​    可以通过java.lang.Runnable接口来实现多线程</p>
<table>
<thead>
<tr>
<th align="center">接口名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@FunctionalInterface public interface <strong>Runnable</strong></td>
<td align="center">函数式接口，里面可以使用nameda表达式</td>
</tr>
</tbody></table>
<p>​    在Runnable接口中只有唯一一个方法–run()方法，此方法作为线程主方法</p>
<p>​    **注意：之前Thread类中有提供start()方法启动线程，但是Runnable接口中不提供这个方法，此时需要Thread类提供的构造方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Thread(Runnable target)</span><br></pre></td></tr></table></figure>

<p>​    <strong>这个构造方法里面需要接收Runnable接口对象的实例（子类对象实例）</strong></p>
<p>​    范例：使用Runnable接口实现多线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread a = <span class="keyword">new</span> MyThread();</span><br><span class="line">		MyThread b = <span class="keyword">new</span> MyThread();</span><br><span class="line">		MyThread c = <span class="keyword">new</span> MyThread();</span><br><span class="line">		<span class="keyword">new</span> Thread(a).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(b).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(c).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span> ; i++)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;线程&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    使用Runnable接口实现可以避免单继承局限(在Java中一个类只能使用extends继承一个父类),更加适合项目编写</p>
<p>​    在JDK1.8之后Runnable成为了函数式接口,所以此时的代码可以使用Lambda进行定义</p>
<p>​    <strong>Lambda表达式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()-&gt;&#123;&#125;  &#x2F;&#x2F;()表输入参数,&#123;&#125;里面是表达式或者返回值</span><br></pre></td></tr></table></figure>

<p>​    范例：使用Lambda表达式修改Runnable接口程序实现多线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;个线程&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    此时Lambda表达式本质上还是Runnable接口的实例</p>
<p>​    <strong>Thread类与Runnable接口关系</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ICrjVP"><img src="https://z3.ax1x.com/2021/11/01/ICrjVP.png" alt="ICrjVP.png"></a></p>
<ol>
<li><p>为什么Thread接收Runnable接口对象之后，会去调用真实线程类中的run()方法呢？</p>
<p>因为当Runnable接口传递到Thread类中之后，会自动利用Thread类中的target属性保存Runnable的接口实例</p>
</li>
<li><p>观察Thread类中的run()方法（调用start()就调用Thread类中的run()方法）</p>
<p>Thread.run()方法定义的时候会判断是否有target实例，如果有此实例，则调用相应的run()方法</p>
</li>
</ol>
<p>​    <strong>多个线程并行操作同一个资源</strong></p>
<p>​    Runnable接口相比较Thread类更容易描述</p>
<p>​    范例：观察资源共享</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread a = <span class="keyword">new</span> MyThread();</span><br><span class="line">		<span class="keyword">new</span> Thread(a).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(a).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(a).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">30</span> ; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;票数&quot;</span>+ ticket--);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    代码理解图示</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IC5xIJ"><img src="https://z3.ax1x.com/2021/11/01/IC5xIJ.png" alt="IC5xIJ.png"></a></p>
<p>​    <strong>核心结论</strong></p>
<p>​    <strong>多线程的实现主要依靠Runnable来定义核心的业务处理功能，但是所有关于线程的控制都通过Thread类定义</strong></p>
<h5 id="3-Callable实现多线程"><a href="#3-Callable实现多线程" class="headerlink" title="3. Callable实现多线程"></a>3. Callable实现多线程</h5><p>​    Java多线程最初依靠Runnable接口来定义线程核心功能类，<strong>但是Runnable接口的run()方法没有返回值</strong></p>
<p>​    从JDk1.5开始，Java提供一个新的多线程实现接口：Callable，<strong>该接口定义在java.util.concurrent(JUC)，一共提供了三个JUC包</strong></p>
<p>​    </p>
<table>
<thead>
<tr>
<th align="center">接口名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@FunctionalInterface public interface Callable&lt; V &gt;</td>
<td align="center">(函数式接口)在java.util.concurrent包中提供的Callable接口</td>
</tr>
</tbody></table>
<p>​    Callable接口中提供的方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">V <strong>call()</strong> throws Exception</td>
<td align="center">方法</td>
<td align="center">描述线程的主体方法，与上面的run()方法相同但提供返回值</td>
</tr>
</tbody></table>
<p>​    使用call()方法定义线程主体，线程执行完毕后会将处理结果进行返回</p>
<p>​    范例：用callable定义线程核心业务类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">300</span> ; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;票数&quot;</span>+ ticket--);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;执行完成&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>Callable接口与Thread类的关系图</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IuYocT"><img src="https://z3.ax1x.com/2021/11/05/IuYocT.png" alt="IuYocT.png"></a></p>
<p>​    要充分理解这个关系，通过与Thread类相联系才可以用start()方法启动线程</p>
<p>​    范例：启动Callable的多线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xpath.internal.objects.XString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Callable&lt;String&gt; callA = <span class="keyword">new</span> MyThread();</span><br><span class="line">		Callable&lt;String&gt; callB = <span class="keyword">new</span> MyThread();</span><br><span class="line">		FutureTask&lt;String&gt; futurecallA = <span class="keyword">new</span> FutureTask&lt;String&gt;(callA);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(futurecallA).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(futurecallA).start();</span><br><span class="line">		System.out.println(futurecallA.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">30</span> ; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;票数&quot;</span>+ ticket--);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;执行完成&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    Callable和Runnable两个多线程接口的差别在于是否有返回值</p>
<p>​    <strong>多线程的几种状态</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IQEGtg"><img src="https://z3.ax1x.com/2021/11/06/IQEGtg.png" alt="IQEGtg.png"></a></p>
<p>​    </p>
<p>​    所有的系统的资源是有限的，不管多线程还是多进程都必须在执行一段时间之后让出资源，交由其他的线程继续执行</p>
<ol>
<li>创建过程：开发者定义好了相应的线程类对象(每一个Thread类的实例)</li>
<li>就绪状态：多线程的启动依靠的是start()方法，当调用start()方法的时候所有的线程不是立即执行，而是将进入到等待状态，等待CPU进行调度</li>
<li>执行状态：当CPU执行调度到了某个线程对象之后，该线程对象开始执行run()方法或call()方法，此时不是持续占用资源，而是在一段时间之后(一共时间片时间)，该线程就需要暂停执行</li>
<li>阻塞状态：当某个线程不再执行时(中断、休眠或调度失败)，那么所有的线程将进入到阻塞状态，如果此时线程没有执行完毕，则由阻塞状态切换到就绪状态，重新等待CPU执行调度</li>
<li>终止状态：如果多线程的执行体执行完毕或者被强制性的结束，那么就将进入到终止状态，终止状态不会再进入到就绪状态，即该线程对象将不会被继续执行</li>
</ol>
<h4 id="8-多线程操作方法-Thread类"><a href="#8-多线程操作方法-Thread类" class="headerlink" title="8. 多线程操作方法(Thread类)"></a>8. 多线程操作方法(Thread类)</h4><p>​    Thread类是实现线程的控制，所以除了有启动多线程的方法之外，也包含一些其他方法</p>
<h5 id="1-线程的命名与获取"><a href="#1-线程的命名与获取" class="headerlink" title="1. 线程的命名与获取"></a>1. 线程的命名与获取</h5><p>​     对于所有的线程对象而言，只能通过名称来进行线程的唯一标记</p>
<p>​    Thread类提供有方法实现线程名称的操作</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public Thread(Runnable target, String name)</td>
<td align="center">构造方法</td>
<td align="center">接收Runnable以及线程的名字</td>
</tr>
<tr>
<td align="center">public final void setName(String name)</td>
<td align="center">方法</td>
<td align="center">设置&amp;修改线程名字（一般不要去改）</td>
</tr>
<tr>
<td align="center">public final String getName()</td>
<td align="center">方法</td>
<td align="center">返回线程的名字</td>
</tr>
<tr>
<td align="center">public <strong>static</strong> Thread currentThread()</td>
<td align="center">方法</td>
<td align="center">返回对当前执行的线程对象的引用(因为线程不可控，你不知道执行到哪一个线程了)</td>
</tr>
</tbody></table>
<p>​    范例：线程名字的获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Thread th = <span class="keyword">new</span> MyThread();  <span class="comment">//等同于创造一个Runnable实例</span></span><br><span class="line">		<span class="keyword">new</span> Thread(th,<span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(th).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(th,<span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(th).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程运行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    注意：如果没有为线程设置名称，线程会自动生成线程名称</p>
<p>​    如果不使用start()启动run方法，而是直接类名.run()，<strong>此时是main()线程运行，即main方法本身就是一个线程，主线程</strong></p>
<p>​    当用户使用java命令解释一个类的时候，实际上会启动一共JVM的进程，<strong>即所有JVM程序运行时都会默认启动一个新的进程，所有的线程都是在这个进程产生的，该进程执行时默认启动一共主线程，又由主线程创建若干个子线程，所有线程并行执行</strong></p>
<h5 id="2-线程的休眠"><a href="#2-线程的休眠" class="headerlink" title="2. 线程的休眠"></a>2. 线程的休眠</h5><p>​    一般情况下线程对象只要启动了，那么就会持续的运行，一直到其运行完毕为止，<strong>如果想减慢线程的执行速度，就可以对其使用休眠处理</strong></p>
<p>​    Thread类中提供线程休眠操作的方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public <strong>static</strong> void sleep(long millis) throws InterruptedException</td>
<td align="center">方法</td>
<td align="center">休眠，单位毫秒</td>
</tr>
<tr>
<td align="center">public static void sleep(long millis, int nanos) throws InterruptedException</td>
<td align="center">方法</td>
<td align="center">休眠，单位毫秒，纳秒</td>
</tr>
</tbody></table>
<p>​    以第一个方法为主，<strong>sleep()方法为静态方法，静态调用即可</strong></p>
<p>​    <strong>InterruptedException为中断异常，所有的休眠都会有中断的问题</strong></p>
<h5 id="3-线程的中断"><a href="#3-线程的中断" class="headerlink" title="3. 线程的中断"></a>3. 线程的中断</h5><p>​    所有线程的执行都是可以被中断的</p>
<p>​    Thread类中提供有中断处理的方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public void interrupt()</td>
<td align="center">方法</td>
<td align="center">中断线程</td>
</tr>
<tr>
<td align="center">public boolean isInterrupted()</td>
<td align="center">方法</td>
<td align="center">判断线程的中断状态</td>
</tr>
</tbody></table>
<p>​    范例：线程中断处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Thread my = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName() +<span class="string">&quot;执行中&quot;</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">				System.out.println(<span class="string">&quot;线程执行完毕&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">				System.out.println(<span class="string">&quot;线程被中断&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		my.start();</span><br><span class="line">		Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;线程的是否中断&quot;</span>+my.isInterrupted());</span><br><span class="line">		my.interrupt();<span class="comment">//主线程打断my线程</span></span><br><span class="line">		System.out.println(<span class="string">&quot;线程的是否中断&quot;</span>+my.isInterrupted());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    <strong>线程中断的本质：一个线程被另外一个线程打断执行</strong></p>
<p>​    线程一旦被中断之后会引发中断异常</p>
<h5 id="4-线程的强制执行-强制让出资源"><a href="#4-线程的强制执行-强制让出资源" class="headerlink" title="4. 线程的强制执行(强制让出资源)"></a>4. 线程的强制执行(强制让出资源)</h5><p>​    当一个程序有若干个线程时，那么这若干个线程一定是交替执行的状态。但如果某个线程特别急，需要优先处理完成，则可以使用线程的强制执行</p>
<p>​    Thread类中提供了强制执行的方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public final void join() throws InterruptedException</td>
<td align="center">方法</td>
<td align="center">程序会等待调用join方法的线程运行完，再执行当前线程</td>
</tr>
<tr>
<td align="center">public final void join(long millis) throws InterruptedException</td>
<td align="center">方法</td>
<td align="center">程序会等待调用join方法的线程运行若干毫秒，再执行当前线程</td>
</tr>
<tr>
<td align="center">public final void join(long millis, int nanos) throws InterruptedException</td>
<td align="center">方法</td>
<td align="center">程序会等待调用join方法的线程运行若干毫秒以及纳秒，再执行当前线程</td>
</tr>
</tbody></table>
<p>​    范例：线程的强制执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Thread my = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (i == <span class="number">10</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.currentThread().join(); <span class="comment">//这里应当调主线程实例，让主线程先执行，而不是自己让自己执行</span></span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">&quot;执行，x =&quot;</span> + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		my.start();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;执行，x =&quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    <strong>注意：像这样自己让自己先执行的话，这个线程之间就不会继续运行了</strong></p>
<h5 id="5-线程的礼让"><a href="#5-线程的礼让" class="headerlink" title="5. 线程的礼让"></a>5. 线程的礼让</h5><p>​    礼让指让出当前执行操作，类似让座，多线程并行执行时，礼让一次其他线程让它优于礼让的线程先执行</p>
<p>​    Thread类中提供礼让操作的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public <strong>static</strong> void yield()</td>
<td align="center">方法</td>
<td align="center">让当前线程让出一次，让其他线程优先执行一次</td>
</tr>
</tbody></table>
<p>​    范例：线程的礼让</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Thread a = Thread.currentThread();</span><br><span class="line">		Thread my = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName()+<span class="string">&quot;礼让&quot;</span>);</span><br><span class="line">					Thread.yield();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">&quot;执行，x =&quot;</span> + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;子线程&quot;</span>);</span><br><span class="line">		my.start();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">100</span> ; j++)&#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;执行 , j =&quot;</span> + j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    <strong>注意：线程礼让不一定会成功，可能失败</strong></p>
<h5 id="6-线程的优先级"><a href="#6-线程的优先级" class="headerlink" title="6. 线程的优先级"></a>6. 线程的优先级</h5><p>​    理论上线程的优先级越高，越有<strong>可能先执行</strong></p>
<p>​    在Thread类中提供有优先级的操作方法：</p>
<table>
<thead>
<tr>
<th align="center">方法及常量</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public final void setPriority(int newPriority)</td>
<td align="center">方法</td>
<td align="center">设置优先级，int newPriority的范围为[MIN_PRIORITY ~ MAX_PRIORITY]</td>
</tr>
<tr>
<td align="center">public final int getPriority()</td>
<td align="center">方法</td>
<td align="center">获取当前线程优先级</td>
</tr>
<tr>
<td align="center">public static final int MIN_PRIORITY</td>
<td align="center">常量</td>
<td align="center">最低优先级（整型数值为1）</td>
</tr>
<tr>
<td align="center">public static final int NORM_PRIORITY</td>
<td align="center">常量</td>
<td align="center">中等优先级（整型数值为5）</td>
</tr>
<tr>
<td align="center">public static final int MAX_PRIORITY</td>
<td align="center">常量</td>
<td align="center">最高优先级（整型数值为10）</td>
</tr>
</tbody></table>
<p>​    范例：设置线程优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Thread my = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">&quot;执行 , x =&quot;</span> + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Thread a = <span class="keyword">new</span> Thread(my,<span class="string">&quot;线程A&quot;</span>);</span><br><span class="line">		Thread b = <span class="keyword">new</span> Thread(my,<span class="string">&quot;线程B&quot;</span>);</span><br><span class="line">		Thread c = <span class="keyword">new</span> Thread(my,<span class="string">&quot;线程C&quot;</span>);</span><br><span class="line"></span><br><span class="line">		a.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">		b.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">		c.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line"></span><br><span class="line">		a.start();</span><br><span class="line">		b.start();</span><br><span class="line">		c.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    <strong>注意：一般未设置优先级时，子线程优先级为NORM_PRIORITY，主线程优先级为NORM_PRIORITY</strong></p>
<h4 id="9-多线程的同步与死锁"><a href="#9-多线程的同步与死锁" class="headerlink" title="9. 多线程的同步与死锁"></a>9. 多线程的同步与死锁</h4><p>​    多线程的优势在于，可以使用多个并行的程序处理同一个操作业务，这样可以实现业务功能的快速处理，但是<strong>在进行多个线程并发资源访问的时候也会造成不同步的因素</strong></p>
<h5 id="1-同步问题引出"><a href="#1-同步问题引出" class="headerlink" title="1. 同步问题引出"></a>1. 同步问题引出</h5><p>​    设计一个多线程买票程序，一共一百张票，要五个线程进行售票处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TicketThread th = <span class="keyword">new</span> TicketThread();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(th,<span class="string">&quot;售票&quot;</span>+i).start();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">120</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">100</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖票，剩余票数为：&quot;</span>+ x--);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    会发现运行结果的问题</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IaYMUs"><img src="https://z3.ax1x.com/2021/11/10/IaYMUs.png" alt="IaYMUs.png"></a></p>
<p>​    这就是线程不同步</p>
<p>​    <strong>图示：</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IaNHEQ"><img src="https://z3.ax1x.com/2021/11/10/IaNHEQ.png" alt="IaNHEQ.png"></a></p>
<p>​    <strong>注意：线程的休眠只是放大问题，不是问题的本因</strong></p>
<p>​    <strong><em>不同步问题核心的本质：多个线程并行执行操作</em></strong></p>
<h5 id="2-线程同步处理"><a href="#2-线程同步处理" class="headerlink" title="2. 线程同步处理"></a>2. 线程同步处理</h5><p>​    要解决上面的问题，需要使用同步，而<strong>同步就是指：多个操作在同一个时间段内只能有一个线程进行，其他线程要等待此线程完成之后才可以继续执行</strong></p>
<p>​    线程的同步处理通过<strong>synchronized</strong>关键字来实现</p>
<p>​    <strong>synchronized的使用有两种模式：同步代码块和同步方法</strong></p>
<ul>
<li><p>同步代码块</p>
<p>指使用synchronized关键字定义的代码块，在进行使用时<strong>必须要设置一个同步的对象</strong>，这个对象往往为当前资源的对象，<strong>可以使用this描述</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步对象)&#123;</span><br><span class="line">	<span class="comment">//所有的同步处理操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>范例：更改上面售票代码，实现同步处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TicketThread th = <span class="keyword">new</span> TicketThread();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(th,<span class="string">&quot;售票&quot;</span>+i).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">120</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span> (x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">100</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖票，剩余票数为：&quot;</span>+ x--);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用了同步代码块之后，所有的线程一个一个的执行，所以这个时候就解决了数据并发访问的安全问题，<strong>但是会带来执行性能过慢的性能问题</strong></p>
</li>
</ul>
<ul>
<li><p>同步方法</p>
<p>指的是使用了“synchronized”关键字定义的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值 方法名()&#123;</span><br><span class="line">	<span class="comment">//需要同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  <strong>注意：同步方法比同步代码块更常见</strong></p>
<h5 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3. 死锁"></a>3. 死锁</h5><p>​    <em>同步的本质：一个线程要等待其他线程执行完毕</em></p>
<p>​    <strong>synchronized关键字</strong></p>
<p>​    <strong>synchronized的作用域默认是当前对象，这时锁就是对象，谁拿到这个锁谁就可以运行它所控制的那段代码。如果这个对象有多个synchronized方法，其它线程就不能同时访问这个对象中任何一个synchronized方法</strong></p>
<p>​    在项目中，不正当的同步处理有可能造成死锁，<strong>即两个线程彼此相互等待</strong></p>
<pre><code>  范例：死锁的产生情况**（本身无意义）**</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span>  Play play = <span class="keyword">new</span> Play();</span><br><span class="line">	<span class="keyword">private</span>  Learn learn = <span class="keyword">new</span> Learn();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> First();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		play.said(learn);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">First</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">this</span>).start();</span><br><span class="line">		learn.said(play);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Play</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">said</span><span class="params">(Learn learn)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;玩完就学习&quot;</span>);</span><br><span class="line">		learn.get();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;学完了，这就去玩&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Learn</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">said</span><span class="params">(Play play)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;学完才能玩&quot;</span>);</span><br><span class="line">		play.get();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;玩完了，这就去学习&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在实际的项目中，死锁是通过大量的程序测试得出来的，上述代码只是死锁的表现，不具有真实开发意义</p>
<p>​    </p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03/">操作系统03</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-11-11T06:23:52.000Z" itemprop="datePublished">
    2021-11-11
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="CPU与多进程"><a href="#CPU与多进程" class="headerlink" title="CPU与多进程"></a>CPU与多进程</h2><h4 id="1-多进程是管理CPU提出来的，通过管理明白CPU而后会管理其他硬件，所以说多进程是操作系统的核心"><a href="#1-多进程是管理CPU提出来的，通过管理明白CPU而后会管理其他硬件，所以说多进程是操作系统的核心" class="headerlink" title="1. 多进程是管理CPU提出来的，通过管理明白CPU而后会管理其他硬件，所以说多进程是操作系统的核心"></a>1. 多进程是管理CPU提出来的，通过管理明白CPU而后会管理其他硬件，所以说多进程是操作系统的核心</h4><h4 id="2-CPU的工作原理"><a href="#2-CPU的工作原理" class="headerlink" title="2. CPU的工作原理"></a>2. CPU的工作原理</h4><p>​    把一个程序存放在内存中，设置一个地址，CPU根据这个地址发出一条取址的命令，即把这个地址从地址总线上由内存发给CPU，CPU得到程序后开始解释执行</p>
<p>​    <strong>CPU的工作就是不断的自动取址执行</strong></p>
<h4 id="3-CPU的管理"><a href="#3-CPU的管理" class="headerlink" title="3. CPU的管理"></a>3. CPU的管理</h4><p>​    设置好PC初值就行（<strong>PC是寄存器</strong>），把PC初值设置在一段程序的开始地址</p>
<p>​    <strong>问题</strong><br>​    但是如果只是设置好PC初值就等待程序执行会出现一个问题，当程序开始磁盘读写(I/O)时(很慢)，CPU不工作进入等待，而一般一个程序计算时间远比磁盘读写时间少，则造成CPU利用率很低，甚至为0</p>
<p>​    <strong>解决方式：多到程序、交替执行(让CPU更好的工作)</strong><br>​    当CPU执行程序执行不下去时，就切出换到另外的程序去执行。等再执行不下去再切出，由此使得CPU忙碌，但<strong>所有程序终会在来回切换中执行完</strong></p>
<p>​    一个CPU上交替的执行多个程序叫做<strong>并发</strong></p>
<h4 id="4-怎么让CPU并发的工作"><a href="#4-怎么让CPU并发的工作" class="headerlink" title="4. 怎么让CPU并发的工作"></a>4. 怎么让CPU并发的工作</h4><ul>
<li>控制PC进行切换</li>
<li>记录程序切出去时的程序执行到的地址，样子（运行的程序和静态程序不一样）</li>
</ul>
<h4 id="5-刻画运行程序的样子：进程"><a href="#5-刻画运行程序的样子：进程" class="headerlink" title="5. 刻画运行程序的样子：进程"></a>5. 刻画运行程序的样子：进程</h4><p>​    一个运行中的程序就是一个进程<br>​    所有程序的不一样都存在PCB中</p>
<h4 id="6-用进程描述CPU管理"><a href="#6-用进程描述CPU管理" class="headerlink" title="6. 用进程描述CPU管理"></a>6. 用进程描述CPU管理</h4><p>​    启动一个进程让CPU去执行这个进程，此时CPU工作；而让CPU更好的工作则是操作系统启动多个进程，让CPU去跑这多个进程，提升CPU利用率。</p>
<h4 id="7-多进程图像从启动开始到关机结束"><a href="#7-多进程图像从启动开始到关机结束" class="headerlink" title="7. 多进程图像从启动开始到关机结束"></a>7. 多进程图像从启动开始到关机结束</h4><p>​    在开机时在main中创建第一个进程（Linux是shell，Windows是桌面）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!fork()&#123;init();&#125;)</span><br></pre></td></tr></table></figure>

<p>​    之后再通过shell启动其他的进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc,char *argv[])&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		scanf(&quot;%s&quot;,cmd);</span><br><span class="line">		if(!fork())&#123;</span><br><span class="line">			exec(cmd);</span><br><span class="line">		&#125;</span><br><span class="line">		wait();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    多进程图示<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/IPnpHx"><img src="https://z3.ax1x.com/2021/11/01/IPnpHx.png" alt="IPnpHx.png"></a></p>
<p>​    通过创建多进程来使用计算机</p>
<p>​    在Windows下任务管理器可以看见多进程，启动一个进程就是开启一个任务</p>
<p>​    <strong>操作系统通过管理多线程来管理计算机，用户使用计算机就是启动一堆进程，用户管理计算机就是管理一堆进程</strong></p>
<h4 id="8-多进程如何组织"><a href="#8-多进程如何组织" class="headerlink" title="8. 多进程如何组织"></a>8. 多进程如何组织</h4><p>​    PCB：用来记录进程信息的数据结构</p>
<p>​    操作系统通过PCB(进程控制块)来感知和组织进程（用PCB形成队列）</p>
<p>​    进程状态转换图<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/IEj5qS"><img src="https://z3.ax1x.com/2021/11/03/IEj5qS.png" alt="IEj5qS.png"></a></p>
<p>​    <strong>状态的转化是操作系统来实现的，通过不断的转化推进进程</strong></p>
<h4 id="9-进程调度"><a href="#9-进程调度" class="headerlink" title="9. 进程调度"></a>9. 进程调度</h4><ol>
<li><p>FIFO</p>
<p>先来先付，最简单的调度，谁第一谁先</p>
<ol start="2">
<li>Priority</li>
</ol>
<p>优先级设定，最短的先做</p>
</li>
</ol>
<h4 id="10-多进程的地址分离"><a href="#10-多进程的地址分离" class="headerlink" title="10. 多进程的地址分离"></a>10. 多进程的地址分离</h4><p>​    阻止两个以上进程在来回切换时访问同一个地址（通过映射表实现），使得地址在逻辑上可以相同但是物理上是不同</p>
<p>​    <strong>所以说进程管理连带内存管理形成多进程图像</strong></p>
<h4 id="11-多进程的合作问题"><a href="#11-多进程的合作问题" class="headerlink" title="11. 多进程的合作问题"></a>11. 多进程的合作问题</h4><p>​    如打印任务，存在一个打印文件队列，有进程往里面放要打印的东西（但是两个进程交替进行但是同时放会产生错误），有进程从中取出进行打印</p>
<p>​    <strong>解决方式上锁（即进程同步(合理的推进方式)）</strong></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/10/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02/">操作系统02</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-10-26T08:26:31.000Z" itemprop="datePublished">
    2021-10-26
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h2><h4 id="1-接口"><a href="#1-接口" class="headerlink" title="1. 接口"></a>1. 接口</h4><p>​    连接两个东西、完成信号转换、屏蔽细节<br>​    接口表现为函数的调用，函数又由系统提供，也称为系统调用</p>
<p>​    上层是调用底层（使用接口），而接口就是通过普通的C语言加上一些重要操作系统函数的调用</p>
<p>​    <strong>操作系统接口表现为函数调用，又由系统提供，所以称为系统调用</strong>，系统调用是操作系统给上层提供的接口</p>
<p>​    shell是一个永不停机的程序</p>
<p>​    Linux 0.11没有图形界面</p>
<h4 id="2-POSIX（统一的接口）"><a href="#2-POSIX（统一的接口）" class="headerlink" title="2. POSIX（统一的接口）"></a>2. POSIX（统一的接口）</h4><p>​    要知道去哪里去查，网上可以下载，如果开发的操作系统满足这个要求，则在Linux上开发的应用程序也可以在你的操作系统上跑</p>
<h4 id="3-系统调用的实现"><a href="#3-系统调用的实现" class="headerlink" title="3. 系统调用的实现"></a>3. 系统调用的实现</h4><p>​    (1).不能随意的调用内核的数据，这样会使得操作系统不安全（像root被获取）</p>
<p>​    (2).通过硬件来保证不能随意的调用内核的数据，即（区分内核态用户态(把内存割成两个区域)），<strong>内核态可以访问任何数据，用户态不能访问内核数据</strong>，0是内核态，3是用户态</p>
<p>​    (3).通过段寄存器来实现(因为内存都是一段一段的)<br>​    DPL&gt;=CPL，只有满足才可以访问<br>​    DPL：(用来描述目标内存段的特权级)，即你要访问的目标段的特权级<br>​    CPL：(CS)，即当前所处在的特权级</p>
<p>​    (4).硬件提供了主动进入内核的方法(中断指令int)<br>​    是计算机提供的唯一方法进入内核<br>​    int指令将使CS中的CPL改成0，进入内核</p>
<h4 id="4-系统调用的核心"><a href="#4-系统调用的核心" class="headerlink" title="4. 系统调用的核心"></a>4. 系统调用的核心</h4><ol>
<li>用户程序中一段包含int指令的代码，进去的话一定是(int 0x80)</li>
<li>操作系统写中断处理，获取想调程序的编号</li>
<li>操作系统根据编号执行相应代码</li>
</ol>
<h4 id="5-int-0x80的具体实现"><a href="#5-int-0x80的具体实现" class="headerlink" title="5. int 0x80的具体实现"></a>5. int 0x80的具体实现</h4><p>​    int指令通过查看idt表来选择中断需要转去哪里进行执行<br>​    idt表和gdt表长的非常相似<br>​    在系统进行初始化时，就已经对int 0x80进行处理定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">set_system_gate(<span class="number">0x80</span>,&amp;system_call) <span class="comment">//每次要调用时就取中断函数地址system_call调用0x80</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    int 0x80进入后将DPL制成3，CS为8，IP=system_call，CPL为CS的后两位为0</p>
<p>​    从int 0x80返回后就一切恢复之前</p>
<h4 id="6-操作系统历史"><a href="#6-操作系统历史" class="headerlink" title="6. 操作系统历史"></a>6. 操作系统历史</h4><h5 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h5><h6 id="1-操作系统的演变"><a href="#1-操作系统的演变" class="headerlink" title="1. 操作系统的演变"></a>1. 操作系统的演变</h6><p>​    随着计算机不断发展后，需要完成多道程序，要使得作业之间进行相互的切换和调度成为核心，如果不切换一定要一个一个等，计算机的速度就会非常的慢，<strong>此时多进程结构和进程管理概念萌芽</strong>，这时制作了OS/360</p>
<p>​    在之后，任务不可以等到做不下去再进行切换，而是需要主动的进行切换，此时引入了<strong>分时系统</strong>的概念，此时一个计算机可以多个人进行使用，这时制作的是MULTICS</p>
<p>​    再之后由MULTICS发明了UNIX</p>
<h6 id="2-PC与DOS"><a href="#2-PC与DOS" class="headerlink" title="2. PC与DOS"></a>2. PC与DOS</h6><p>​    由DOS演变为Windows，Windows主要是磁盘、文件、命令令人使用方便</p>
<p>​    再之后在Windows3.0加入图形界面</p>
<p>​    </p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><h6 id="1-操作系统的演变-1"><a href="#1-操作系统的演变-1" class="headerlink" title="1. 操作系统的演变"></a>1. 操作系统的演变</h6><p>​    <strong>多进程结构是操作系统基本图谱，要掌握，并且实现它</strong></p>
<p>​    多进程结构图示：**(当一个系统进入打印或其他操作使得CPU等待时，跳转到下一个作业，之后再转回来)**</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/54jP0O"><img src="https://z3.ax1x.com/2021/10/25/54jP0O.png" alt="54jP0O.png"></a></p>
<p>​    对于操作系统实现概念远比理解概念重要</p>
<h6 id="2-PC与DOS-1"><a href="#2-PC与DOS-1" class="headerlink" title="2. PC与DOS"></a>2. PC与DOS</h6><p>​    文件、开发环境、图形界面对于OS的重要性，<strong>要掌握、实现操作系统的文件操作视图</strong></p>
<h5 id="核心思想，技术"><a href="#核心思想，技术" class="headerlink" title="核心思想，技术"></a>核心思想，技术</h5><ul>
<li>程序执行、多线程、程序执行带动其他设备使用的基本结构</li>
<li>对用户的使用感觉：各种文件、编程环境、图形界面</li>
</ul>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/10/25/Java14/">Java14</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-10-25T11:25:55.000Z" itemprop="datePublished">
    2021-10-25
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h4 id="1-泛型是在JDK1-5之后主要引入的一项技术，其主要的目的是为了解决类对象的安全隐患问题"><a href="#1-泛型是在JDK1-5之后主要引入的一项技术，其主要的目的是为了解决类对象的安全隐患问题" class="headerlink" title="1. 泛型是在JDK1.5之后主要引入的一项技术，其主要的目的是为了解决类对象的安全隐患问题"></a>1. 泛型是在JDK1.5之后主要引入的一项技术，其主要的目的是为了解决类对象的安全隐患问题</h4><h4 id="2-泛型问题的引出"><a href="#2-泛型问题的引出" class="headerlink" title="2. 泛型问题的引出"></a>2. 泛型问题的引出</h4><p>​    在Java中，最方便的参数统一使用Object类型，但是并不是意味所有的Object都可以解决实际问题</p>
<p>​    现在假设需要一个描述坐标点的信息类(Point)，该类中可以保存三种坐标类型</p>
<ul>
<li><p>保存整型</p>
</li>
<li><p>保存浮点型</p>
</li>
<li><p>保存字符串</p>
</li>
</ul>
<p>​    此时，要保证三类数据的保存，只有通过Object类型可以解决</p>
<p>​    <strong>Point类的设计</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object x;</span><br><span class="line">	<span class="keyword">private</span> Object y;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(Object x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.x = x;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(Object y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在使用这个类时，需要进行向上转型输入和向下转型输出。但是，由于Object所能描述的范围太广泛了，所以<strong>可能传入了字符串类型任何转型时不小心转为了int(其他)类型</strong>，此时代码在<strong>编译时可以通过，执行时出现”ClassCastException“异常</strong>，<strong>由此可以看出Object提供的解决方案实际上会存在安全隐患</strong>，所以Object类作为参数是项目中最大的败笔</p>
<h4 id="3-泛型基本定义"><a href="#3-泛型基本定义" class="headerlink" title="3. 泛型基本定义"></a>3. 泛型基本定义</h4><p>​    通过分析Object作为参数的优缺点，<strong>要想解决对象转型安全隐患问题，最简单的方式就是不转型</strong><br>​    JDk1.5后提供了泛型的概念，泛型&lt; T &gt;最大的特点为，类中的属性类型或方法的参数，可以在类的使用时，动态决定<br>​    <strong>范例：修改Point类的设计</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="comment">//T表示Type的意思，不一定要T写其他的也可以</span></span><br><span class="line">	<span class="keyword">private</span> T x;</span><br><span class="line">	<span class="keyword">private</span> T y;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.x = x;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(T y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在Point类上定义的泛型T实际上只是一个随机设置的名称，表示的是，该类型由使用的时候来决定，<strong>泛型使用时只能使用引用数据类型，不能使用基本类型</strong></p>
<p>​    范例：使用泛型声明的类Point</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		Point&lt;Integer&gt; a &#x3D; new Point&lt;Integer&gt;();</span><br><span class="line">		a.setX(10);</span><br><span class="line">		a.setY(20);</span><br><span class="line">		System.out.println(&quot;x &#x3D; &quot;+a.getX()+ &quot;,y &#x3D; &quot;+a.getY());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​    注意：使用泛型后，所有程序之中具有泛型标记的部分都会更换为相应的类型标记，这个标记在类对象实例化的时候进行动态的配置，此时就不需要转型了，而且编译时会帮助检测错误</p>
<p>​    <strong>注意：如果使用了泛型设计类但是使用这个类并没有给泛型，那么会把泛型中所有的T变成Object类型，Object的使用就需要转型了</strong></p>
<h4 id="4-泛型通配符"><a href="#4-泛型通配符" class="headerlink" title="4. 泛型通配符"></a>4. 泛型通配符</h4><p>​    泛型的出现解决了数据类型的转换安全问题，但是随之而来也会带来引用传递的麻烦。<strong>为解决该问题则用通配符对形参进行约束</strong></p>
<p>​    范例：泛型的引用传递</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">class Message&lt;T&gt;&#123;</span><br><span class="line">	private T info;</span><br><span class="line">	public void setMessage(T info) &#123;</span><br><span class="line">		this.info &#x3D; info;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public T getMessage() &#123;</span><br><span class="line">		return this.info;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class First&#123;</span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		Message&lt;String&gt; msg &#x3D; new Message&lt;String&gt;();</span><br><span class="line">		msg.setMessage(&quot;篮球&quot;);</span><br><span class="line">		print(msg);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void print(Message&lt;String&gt; msg) &#123;</span><br><span class="line">		System.out.println(msg.getMessage());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>注意：</strong></p>
<ol>
<li>泛型作为形参不可以作为重载标识，重载的参数类型名以类名作为标识与泛型无关</li>
<li>泛型在作为形参时需要注明泛型的类型</li>
<li>如果没有声明泛型类型，传过来则使用Object类型来代替未设置的泛型标记，也就说传过来后的泛型可以设置成任意类型</li>
</ol>
<p>​    <em>为了解决3这个问题，泛型里提供了通配符”?“</em><br>​    使用通配符”?“会限制程序不可以修改传过来的对象，此时对象仍然为object类型(可以描述一切的泛型类型)，但无法进行修改(取和改)</p>
<p>​    在通配符?的基础之上，又产生了两个通配符的应用：</p>
<ul>
<li>设置泛型的下限：? super类;<br>​    例如：”? super String“，表示可以设置的泛型类只能够是String以及其父类(Object)</li>
<li>设置泛型的上限：? extands 类;<br>​    例如：”? extends Number“：表示所设置的泛型类型只能够是Number或者其子类<br>​    <strong>注意：泛型的上限可以对类进行修饰(类&lt; T extends 类(界限)&gt;)</strong></li>
</ul>
<h4 id="5-泛型接口"><a href="#5-泛型接口" class="headerlink" title="5. 泛型接口"></a>5. 泛型接口</h4><p>​    泛型也可以应用在接口上，此类接口称为泛型接口</p>
<p>​    泛型接口的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IMessage&lt;T&gt;&#123;</span><br><span class="line">	public void send(T content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    所有的接口在使用的时候都必须依靠子类，那么在此时子类有两种实现泛型接口的方式</p>
<ul>
<li>方式一：在子类中继续指定泛型标记<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(T content)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IMessage</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(T content)</span> </span>&#123;</span><br><span class="line">		System.out.println(content);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		IMessage&lt;String&gt; a = <span class="keyword">new</span> MessageImpl&lt;String&gt;();<span class="comment">//后面的String可以省略，尖括号还是需要</span></span><br><span class="line">		a.send(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>​    上面代码的注释中，在JDK1.8出现了一个自动推导泛型的概念，因为每一次前后都需要编写泛型类型，过于复杂，所以现在前面定义了泛型类型，那么后面就可以不需要重复定义了</p>
<ul>
<li>方式二：子类不再设置泛型类型，而为父类指派好类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">interface IMessage&lt;T&gt;&#123;</span><br><span class="line">	public void send(T content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MessageImpl implements IMessage&lt;String&gt;&#123;</span><br><span class="line">	public void send(String content) &#123;</span><br><span class="line">		 System.out.println(content);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class First&#123;</span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		IMessage&lt;String&gt; a &#x3D; new MessageImpl();</span><br><span class="line">		a.send(&quot;hello&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-泛型方法"><a href="#6-泛型方法" class="headerlink" title="6. 泛型方法"></a>6. 泛型方法</h4><p>​    所有泛型方法不一定非要定义在泛型的类或泛型接口之中，这也就是说任意一个方法都可以定义为泛型方法，但是需要对泛型标记（&lt;  T &gt;）加以声明</p>
<p>​    范例：定义泛型方法<br>​    此时对于传入的参数类型就由调用方法的语句来外部定义了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] init(T ... args)&#123; <span class="comment">//T[]表示T类型数组</span></span><br><span class="line"><span class="keyword">return</span> args; <span class="comment">//返回是类对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    知道一个方法如何去定义一个泛型就行了</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/10/25/%E5%8F%8D%E5%B0%84%E5%AE%9E%E4%BE%8B/">反射实例</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-10-25T11:24:45.000Z" itemprop="datePublished">
    2021-10-25
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java%E5%AE%9E%E4%BE%8B/">Java实例</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h3 id="1-静态工厂"><a href="#1-静态工厂" class="headerlink" title="1. 静态工厂"></a>1. 静态工厂</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">public class First&#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		Message msg &#x3D; factory.getMessage(&quot;PaperMessage&quot;);</span><br><span class="line">		msg.send(&quot;静态工厂&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Message&#123;</span><br><span class="line">	public void send(String msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PaperMessage implements Message&#123;</span><br><span class="line">	public void send(String msg) &#123;</span><br><span class="line">		System.out.println(&quot;【报纸报道】：&quot;+ msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class InternalMessage implements Message&#123;</span><br><span class="line">	public void send(String msg) &#123;</span><br><span class="line">		System.out.println(&quot;【网络报道】：&quot;+ msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;工厂类，隐藏构造方法，提供分发的方法</span><br><span class="line">class factory&#123;</span><br><span class="line">	private factory() &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	public static Message getMessage(String className) &#123;</span><br><span class="line">		if(&quot;PaperMessage&quot;.equals(className)) &#123;</span><br><span class="line">			return new PaperMessage();</span><br><span class="line">		&#125;else if(&quot;InternalMessage&quot;.equals(className)) &#123;</span><br><span class="line">			return new InternalMessage();</span><br><span class="line">		&#125;else</span><br><span class="line">			return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-使用反射修改后的静态工厂"><a href="#2-使用反射修改后的静态工厂" class="headerlink" title="2. 使用反射修改后的静态工厂"></a>2. 使用反射修改后的静态工厂</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">public class First&#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		Message msg &#x3D; factory.getMessage(&quot;hello.PaperMessage&quot;);</span><br><span class="line">		msg.send(&quot;静态工厂&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Message&#123;</span><br><span class="line">	public void send(String msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PaperMessage implements Message&#123;</span><br><span class="line">	public void send(String msg) &#123;</span><br><span class="line">		System.out.println(&quot;【报纸报道】：&quot;+ msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class InternalMessage implements Message&#123;</span><br><span class="line">	public void send(String msg) &#123;</span><br><span class="line">		System.out.println(&quot;【网络报道】：&quot;+ msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用反射修改了工厂类</span><br><span class="line">class factory&#123;</span><br><span class="line">	private factory() &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	public static Message getMessage(String className) &#123;</span><br><span class="line">		Message msg &#x3D; null;</span><br><span class="line">		try &#123;</span><br><span class="line">			msg &#x3D; (Message)Class.forName(className).getDeclaredConstructor().newInstance();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		return msg;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-反射获取类结构"><a href="#3-反射获取类结构" class="headerlink" title="3. 反射获取类结构"></a>3. 反射获取类结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class First&#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Class&lt;?&gt; clazz &#x3D; D.class;</span><br><span class="line">		System.out.println(&quot;【包名称：】&quot;+clazz.getPackageName());</span><br><span class="line">		System.out.println(&quot;【继承的父类：】&quot;+clazz.getSuperclass());</span><br><span class="line">		System.out.println(&quot;【继承的接口：】&quot;+Arrays.toString(clazz.getInterfaces()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface A&#123;&#125;</span><br><span class="line"></span><br><span class="line">interface B&#123;&#125;</span><br><span class="line"></span><br><span class="line">abstract class C implements A,B&#123;&#125;</span><br><span class="line"></span><br><span class="line">abstract class D extends C implements A,B&#123;&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/10/24/Java13/">Java13</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-10-24T05:56:24.000Z" itemprop="datePublished">
    2021-10-24
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="反射-Class-lt-gt"><a href="#反射-Class-lt-gt" class="headerlink" title="反射(Class&lt; ? &gt;)"></a>反射(Class&lt; ? &gt;)</h2><h4 id="1-Java的反射机制"><a href="#1-Java的反射机制" class="headerlink" title="1. Java的反射机制"></a>1. Java的反射机制</h4><p>​    Java语言最为重要的特性之一就是反射机制的存在，这个机制使得Java设计更加的灵活<br>​    要写出高复用的代码就要去学习Java反射，几乎所有的Java开发框架都为Java的反射应用</p>
<h4 id="2-反射的“反”"><a href="#2-反射的“反”" class="headerlink" title="2. 反射的“反”"></a>2. 反射的“反”</h4><p>​    在常规的做法是明确知道一个类之后，导入此类随后进行对象实例化处理，但反射可以依据实例化对象找到其根源。</p>
<h4 id="3-Object类中的getClass-方法"><a href="#3-Object类中的getClass-方法" class="headerlink" title="3. Object类中的getClass()方法"></a>3. Object类中的getClass()方法</h4><table>
<thead>
<tr>
<th>public final Class&lt;?&gt;  getClass()</th>
</tr>
</thead>
<tbody><tr>
<td>获得该类型详细描述。Class&lt;?&gt;的意思为记录了该类的一切信息</td>
</tr>
</tbody></table>
<p>​    <strong>注意：该方法不能被重写</strong></p>
<h4 id="4-反射的根源是Class类，Java对实例化的操作提供三类支持，实际项目都是混用都重要"><a href="#4-反射的根源是Class类，Java对实例化的操作提供三类支持，实际项目都是混用都重要" class="headerlink" title="4. 反射的根源是Class类，Java对实例化的操作提供三类支持，实际项目都是混用都重要"></a>4. 反射的根源是Class类，Java对实例化的操作提供三类支持，实际项目都是混用都重要</h4><ol>
<li>利用Object类中提供的getClass()方法，通过实例化调用获得</li>
<li>利用“类.class”的Java原生代码操作实现<br>示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clsA &#x3D; java.util.Date.class  &#x2F;&#x2F;这个类必须存在</span><br></pre></td></tr></table></figure></li>
<li>利用Class类中提供的forName()方法进行实例化<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public <strong>static</strong> Class&lt; ? &gt; forName(String className) <strong>throws ClassNotFoundException</strong></td>
<td align="center">此类方法需要将加载反射类型的名称进行定义(通过字符串描述要使用类的名称)，而且定义的时候要求使用类的完整名称“包.类”，如果该类不存在则会出现”ClassNotFoundException”，也就意味着要进行加载的类一定要放在CLASSPATH可以识别</td>
</tr>
</tbody></table>
</li>
</ol>
<p>​    示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clsA &#x3D; Class.forName(&quot;java.util.Date&quot;) &#x2F;&#x2F;需要包.类</span><br></pre></td></tr></table></figure>
<p>这个与第二个的区别是第二个必须要类存在,这个写错的话会报异常</p>
<p>​    <strong>总结：三种形式获取Class类实例的特点</strong></p>
<ul>
<li>**getClass()**：需要明确的获得使用类的实例化对象；</li>
<li><strong>类.class</strong>：需要明确的进行操作类的导入处理；</li>
<li>**Class.forName()**：可以通过字符串描述要使用类的名称(最灵活的)</li>
</ul>
<p>​    <strong>注意：反射可以用来代替“new”操作符进行实例化对象，但其操作和“new”关键字一样受到类的构造方法的约束，如果类构造方法为private，在类外它一样不可以实例化对象</strong></p>
<h4 id="5-反射应用案例"><a href="#5-反射应用案例" class="headerlink" title="5. 反射应用案例"></a>5. 反射应用案例</h4><h5 id="1-反射对象实例化"><a href="#1-反射对象实例化" class="headerlink" title="1. 反射对象实例化"></a>1. 反射对象实例化</h5><p>​    获取Class类对象之后最大用处在于可以直接利用反射提供的方法调用指定类的构造实现对象的实例化，此操作的方法为：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public <strong>T</strong> newInstance() <strong>throws InstantiationException, IllegalAccessException</strong></td>
<td align="center">反射实例化对象，<strong>T表示返回值为Object类型</strong></td>
</tr>
</tbody></table>
<p>注意：由于反射定义中的泛型比较尴尬所以出现“?”居多，“?”的返回为Object</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;clazz表示class的实例化对象</span><br><span class="line">Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;java.util.Date&quot;);</span><br><span class="line">Object obj &#x3D; clazz.newInstance(); &#x2F;&#x2F;反射实例化对象，相当于表示“new java.util.Date()”</span><br></pre></td></tr></table></figure>

<p><strong>注意：上面代码反射为Object类型，如果要使用Date类的对象需要对obj进行向下转型，若只是需要对象则可以直接使用obj</strong></p>
<h5 id="2-反射与工厂设计模式"><a href="#2-反射与工厂设计模式" class="headerlink" title="2. 反射与工厂设计模式"></a>2. 反射与工厂设计模式</h5><p>​    工厂设计模式常用来获取接口实例，属于java面向对象编程的基本模型<br>​    使用工厂模式，在使用new操作符时，也叫做静态工厂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class factory&#123;</span><br><span class="line">	private factory() &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	public static Message getMessage(String className) &#123;</span><br><span class="line">		if(&quot;PaperMessage&quot;.equals(className)) &#123;</span><br><span class="line">			return new PaperMessage();</span><br><span class="line">		&#125;else if(&quot;InternalMessage&quot;.equals(className)) &#123;</span><br><span class="line">			return new InternalMessage();</span><br><span class="line">		&#125;else</span><br><span class="line">			return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>详细完整代码见反射实例例一</strong></p>
<p>​    <strong>静态工厂类的缺点</strong><br>​    当你要添加或者删除接口子类很多时，传统的静态工厂类将无法满足需要，问题产生的原因是关键字“new”，关键字“new”是Java提供的原生对象实例化支持，但需要使用特定的结构使用，一个好的代码new使用的少，所以此时需要使用反射机制来解决</p>
<p>​    <strong>反射机制的思路</strong><br><a target="_blank" rel="noopener" href="https://imgtu.com/i/5ZJDt1"><img src="https://z3.ax1x.com/2021/10/11/5ZJDt1.png" alt="5ZJDt1.png"></a></p>
<p>​     用反射机制修改工厂类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class factory&#123;</span><br><span class="line">	private factory() &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	public static Message getMessage(String className) &#123; </span><br><span class="line">		Message msg &#x3D; null;</span><br><span class="line">		try &#123;</span><br><span class="line">			msg &#x3D; (Message)Class.forName(className).getDeclaredConstructor().newInstance();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		return msg;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>注意：此时由于调用Class.forname()所以方法传字符串(className)必须是完整路径，包+类名</strong></p>
<p>​    <strong>详细完整代码见反射实例例二</strong></p>
<p>​    此时添加子类时就不需要去修改工厂类了</p>
<h5 id="3-反射与单例设计模式"><a href="#3-反射与单例设计模式" class="headerlink" title="3. 反射与单例设计模式"></a>3. 反射与单例设计模式</h5><p>​    单例设计模式的核心：一个类在一个JVM进程之中只允许有一个实例化对象</p>
<p>​    单例设计模式的两种结构：饿汉式单例、懒汉式单例（问题比较麻烦，但找工作用这个可以使得问题表述的更加清晰）</p>
<p>​    懒汉式就是创建对象时比较懒，先不急着创建对象，在需要加载配置文件的时候再去创建。饿汉式就是在系统初始化的时候我们已经把对象创建好了，需要用的时候直接拿过来用就好了</p>
<ul>
<li><p>设计饿汉式单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class SingletonEH &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     *是否 Lazy 初始化：否</span><br><span class="line">     *是否多线程安全：是</span><br><span class="line">     *实现难度：易</span><br><span class="line">     *描述：这种方式比较常用，但容易产生垃圾对象。</span><br><span class="line">     *优点：没有加锁，执行效率会提高。</span><br><span class="line">     *缺点：类加载时就初始化，浪费内存。</span><br><span class="line">     *它基于 classloder 机制避免了多线程的同步问题，</span><br><span class="line">     * 不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，</span><br><span class="line">     * 在单例模式中大多数都是调用 getInstance 方法，</span><br><span class="line">     * 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，</span><br><span class="line">     * 这时候初始化 instance 显然没有达到 lazy loading 的效果。</span><br><span class="line">     * 饿汉就是类一旦加载（ java文件通过编译器变成了.class文件），就把单例初始化完成，保证getInstance的时候，单例是已经存在的了</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static SingletonEH instance &#x3D; new SingletonEH();</span><br><span class="line">    private SingletonEH ()&#123;&#125;</span><br><span class="line">    public static SingletonEH getInstance() &#123;</span><br><span class="line">        System.out.println(&quot;instance:&quot;+instance);</span><br><span class="line">        System.out.println(&quot;加载饿汉式....&quot;);</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设计懒汉式单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">     *是否 Lazy 初始化：是</span><br><span class="line">     *是否多线程安全：否</span><br><span class="line">     *实现难度：易</span><br><span class="line">     *描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</span><br><span class="line">     *这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</span><br><span class="line">	*&#x2F;</span><br><span class="line">	&#x2F;&#x2F;设置单例，保证只有一个单例</span><br><span class="line">	private static Singleton instance;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;私有化构造方法，使之只能在内部调用实例化</span><br><span class="line">	private Singleton()&#123;</span><br><span class="line">		System.out.println(&quot;hello&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;通过公有化方法提供对外部的接口</span><br><span class="line">	public static Singleton getInstance() &#123;</span><br><span class="line">		if(instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">			instance &#x3D; new Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>​    但是一旦使用多线程，并且结合懒汉式设计时会出现对象的多次实例化<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/5mOrjJ"><img src="https://z3.ax1x.com/2021/10/12/5mOrjJ.png" alt="5mOrjJ.png"></a></p>
<p>​    需要解决问题需要增加同步处理<br>​    <strong>同步是否添加的因素：如果读取不要加同步，如果更新要加同步</strong><br>​    如果直接在方法外增加同步，线程若有10w个线程获取Singleton类的对象，则这10w个线程排队等待，性能会下降<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/5mxlan"><img src="https://z3.ax1x.com/2021/10/12/5mxlan.png" alt="5mxlan.png"></a></p>
<p>​    所以应该在方法内增加同步，而同步内用的对象的获取则使用反射机制</p>
<p>​    <strong>解决代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;此时即保证了getInstance()方法的操作性能，同时又保护了Singleton类对象的实例化次数</span><br><span class="line">class Singleton&#123;</span><br><span class="line">	private static Singleton instance;</span><br><span class="line">	</span><br><span class="line">	private Singleton()&#123;</span><br><span class="line">		System.out.println(&quot;hello&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static Singleton getInstance() &#123;</span><br><span class="line">		if(instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">			synchronized(Singleton.class) &#123;</span><br><span class="line">				if(instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">					instance &#x3D; new Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>代码解释图示</strong><br><a target="_blank" rel="noopener" href="https://imgtu.com/i/5nSyuD"><img src="https://z3.ax1x.com/2021/10/12/5nSyuD.png" alt="5nSyuD.png"></a></p>
<h4 id="6-反射与类操作"><a href="#6-反射与类操作" class="headerlink" title="6. 反射与类操作"></a>6. 反射与类操作</h4><p>​    反射可以完整的实现Java允许规定的类的操作形式<br>​    传统的Java二进制文件对其进行操作就是进行类加载(import、CLASSPATH)；实例化类对象并操作，<strong>对于这些二进制文件的分析(Java中允许你做到的)就是反射</strong>，如果要对这个文件进行更深入的分析，需要使用第三方工具包</p>
<h5 id="1-反射获取类结构"><a href="#1-反射获取类结构" class="headerlink" title="1. 反射获取类结构"></a>1. 反射获取类结构</h5><p>​    class作为所有反射操作的源头，于是在Class类里面就可以获取clazz的一些结构上的信息，例如：类所在的包、类所继承的父类、已经类所实现的相关的接口，方法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public Package getPackage()</td>
<td align="center">方法</td>
<td align="center">获取程序所在的包名称</td>
</tr>
<tr>
<td align="center">public <strong>Class</strong>&lt; ? super T&gt; getSuperclass()</td>
<td align="center">方法</td>
<td align="center">获取所继承的父类</td>
</tr>
<tr>
<td align="center">public Class&lt; ? &gt;[] getInterfaces()</td>
<td align="center">方法</td>
<td align="center">获取所有的父接口</td>
</tr>
</tbody></table>
<p>​    之所以通过反射可以获取这些信息，主要是由于Class类拥有了“*.class”二进制数据的分析能力，它实际上是根据二进制的结构文件动态获取的内容。</p>
<p>​    <strong>详细代码见反射实例例三</strong></p>
<h5 id="2-反射调用构造方法"><a href="#2-反射调用构造方法" class="headerlink" title="2. 反射调用构造方法"></a>2. 反射调用构造方法</h5><p>​    所有的构造方法都可以利用反射来进行获取，在Class类中定义如下构造方法获取的操作</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public Constructor&lt; T &gt; getConstructor(Class&lt; ? &gt;… parameterTypes) throws NoSuchMethodException, SecurityException</td>
<td align="center">方法</td>
<td align="center">根据指定的参数类型获取指定 的构造方法(Public)</td>
</tr>
<tr>
<td align="center">public Constructor&lt; ? &gt;[] getConstructors()                                 throws SecurityException</td>
<td align="center">方法</td>
<td align="center">获取类中所有的构造方法(public)</td>
</tr>
<tr>
<td align="center">public Constructor&lt; T &gt; get<strong>Declared</strong>Constructor(Class)&lt; ? &gt;… parameterTypes)                                      throws NoSuchMethodException, SecurityException</td>
<td align="center">方法</td>
<td align="center">获取一个类中指定的构造方法(public、protected、default)</td>
</tr>
<tr>
<td align="center">public Constructor&lt; ? &gt;[] get<strong>Declared</strong>Constructors() throws SecurityException</td>
<td align="center">方法</td>
<td align="center">获取一个类中的全部构造方法(public、protected、default)</td>
</tr>
</tbody></table>
<p>​    在Java中好用的方法为后两个，因为构造方法不一定只使用public来定义，所以获取的方法应该采用“getDeclaredConstructor”</p>
<p>​    <strong>获取构造并不意味着要进行简单的输出，这种获取信息的操作只在开发工具中比较常见，但是获取Constructor最大的意义在于其可以进行反射构造调用，提供有如下方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public T <strong>newInstance(Object… initargs)</strong> throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException</td>
<td align="center">方法</td>
<td align="center">调用指定的构造进行对象实例化处理</td>
</tr>
</tbody></table>
<p>​    范例：利用反射调用指定参数的构造进行实例化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">class Ball&#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private double price;</span><br><span class="line">	</span><br><span class="line">	public Ball(String name,double price) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.price &#x3D; price;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void print() &#123;</span><br><span class="line">		System.out.println(&quot;球的名字为：&quot;+this.name+&quot;、价格为：&quot; + this.price);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class First&#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException&#123;</span><br><span class="line">		Class&lt;?&gt; clazz &#x3D; Ball.class;&#x2F;&#x2F;获取反射对象</span><br><span class="line">		Constructor&lt;?&gt; con &#x3D; clazz.getDeclaredConstructor(String.class,double.class);</span><br><span class="line">		Ball ball &#x3D; (Ball)con.newInstance(&quot;足球&quot;,12.5);</span><br><span class="line">		ball.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    以上操作是JDK1.9之后官方推荐的做法，在JDK1.8及以前的版本里面，关于反射对象的实例化操作实际上提供了两个不同的方法</p>
<ul>
<li><p><strong>Class类：</strong>@Deprecated(since)=”9”) public T newInstance() throws InstantiationException, IllegalAccessException</p>
<p>-默认调用无参构造，如果类中，没有无参构造则将抛出异常；JDK1.9之后就修改为Constructor类调用；</p>
</li>
<li><p><strong>Constructor类：</strong>public T newInstance() throws InstantiationException, IllegalAccessException</p>
</li>
</ul>
<h5 id="3-反射调用方法"><a href="#3-反射调用方法" class="headerlink" title="3. 反射调用方法"></a>3. 反射调用方法</h5><p>​    在class类中定义了可以获取类中方法实例的操作</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public Method[] <strong>getMethods()</strong> throws SecurityException</td>
<td align="center">方法</td>
<td align="center">获取本类和父类中所有的public方法</td>
</tr>
<tr>
<td align="center">public Method getMethod(String name, Class&lt; ? &gt;… parameterTypes) throws NoSuchMethodException, SecurityException</td>
<td align="center">方法</td>
<td align="center">获取一个public的方法，包括父类的方法</td>
</tr>
<tr>
<td align="center">public Method[] <strong>getDeclaredMethods()</strong> throws SecurityException</td>
<td align="center">方法</td>
<td align="center">获取本类中所有的方法</td>
</tr>
<tr>
<td align="center">public Method getDeclaredMethod(<strong>String name</strong>, <strong>Class&lt; ? &gt;… parameterTypes</strong>) throws NoSuchMethodException, SecurityException</td>
<td align="center">方法</td>
<td align="center">获取本类一个指定类型的Method实例；String name表示方法名称，Class&lt; ? &gt;… parameterTypes表示我要操作的参数类型</td>
</tr>
</tbody></table>
<p>​    当获取了一个方法之后将以Method类的实例进行该方法的描述，Method类的定义方式如下：</p>
<p>​    <strong>Method类的定义</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final class Method extends Executable</span><br></pre></td></tr></table></figure>
<p>​    这个类的定义方式和之前Constructor类是完全一样的</p>
<p>​    图示：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5w4OD1"><img src="https://z3.ax1x.com/2021/10/19/5w4OD1.png" alt="5w4OD1.png"></a> </p>
<p>​    在Java里面可以利用Method明确的描述一个可以调用的方法结构，可以利用Method实现类中全部方法的输出</p>
<p>​    范例：获取Ball类中所有的public方法,包括所有父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Balls</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toDo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> <span class="keyword">extends</span> <span class="title">Balls</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException</span>&#123;</span><br><span class="line">		Class&lt;?&gt; clazz = Ball.class;</span><br><span class="line">		Method method[] = clazz.getMethods();</span><br><span class="line">		<span class="keyword">for</span>(Method x:method) &#123;</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    获取method实例后对<strong>该方法</strong>信息获得的方法<strong>（Method类或者其父类（Executable）下的方法）</strong>：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public String getName()</td>
<td align="center">方法</td>
<td align="center">获取方法的名字</td>
</tr>
<tr>
<td align="center">public abstract int getModifiers()</td>
<td align="center">方法</td>
<td align="center">获取方法前的权限修饰符</td>
</tr>
<tr>
<td align="center">public Class&lt; ? &gt; getReturnType()</td>
<td align="center">方法</td>
<td align="center">获取方法的返回值</td>
</tr>
<tr>
<td align="center">public abstract Class&lt; ? &gt;[] getParameterTypes()</td>
<td align="center">方法</td>
<td align="center">获取方法的所有参数,返回值为数组</td>
</tr>
<tr>
<td align="center">public Class&lt; ? &gt;[] getExceptionTypes()</td>
<td align="center"></td>
<td align="center">获取方法的所有异常</td>
</tr>
</tbody></table>
<p>​    <strong>注意：getModifiers()方法的返回值为int类型，因为所有的权限都是数字的组合(相加)，在java.lang.reflect.Modifier类中有static String toString(int mod)方法，将这些数字反推权限修饰符的字符串</strong></p>
<p>​    程序配置了任何的第三方工具包,各个开发工具之所以可以进行代码的检测以及方法的获取,就是由于反射机制的支持(二进制数据流的解析处理),但是对于我们开发人员来讲**,真正有意义的代码在于Method类中提供的反射调用方法(非常重要,使用Method类中最有意义的操作)**:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object obj,Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException</span><br></pre></td></tr></table></figure>

<p>​    <strong>invoke()可以直接依据Object类的实例化对象(不一定是具体类型)实现反射方法调用</strong></p>
<p>​    注意：所有的简单Java类一定要提供有无参构造方法,同时所有的属性必须封装(private),封装后的属性必须编写setter、getter方法</p>
<p>​    <strong>范例：利用反射调用setter、getter方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;hello.Ball&quot;</span>);</span><br><span class="line">		Object obj = clazz.getDeclaredConstructor().newInstance(); <span class="comment">//实例化对象</span></span><br><span class="line">		Method setmethod = clazz.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class); <span class="comment">//参数类型暂时无法动态获取，先固定一个String.class</span></span><br><span class="line">		setmethod.invoke(obj, <span class="string">&quot;篮球&quot;</span>); <span class="comment">//等价于“实例化对象.setName(&quot;篮球&quot;)”</span></span><br><span class="line">		Method getmethod = clazz.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">		Object a = getmethod.invoke(obj);</span><br><span class="line">		System.out.println(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    此时程序实现了方法的反射调用，同时也解释了为什么简单Java类中的命名要有setter、getter规则</p>
<h5 id="4-反射调用成员属性"><a href="#4-反射调用成员属性" class="headerlink" title="4. 反射调用成员属性"></a>4. 反射调用成员属性</h5><p>​    类结构里面包含的三个组成：构造、方法、成员属性，那么对于所有的成员属性也是可以通过反射来实现调用，在class类中提供有如下的与成员有关的操作方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public Field[] getFields() throws SecurityException</td>
<td align="center">方法</td>
<td align="center">获取所有继承来的public成员</td>
</tr>
<tr>
<td align="center">public Field getField(String name) throws NoSuchFieldException, SecurityException</td>
<td align="center">方法</td>
<td align="center">获取一个指定类型的成员</td>
</tr>
<tr>
<td align="center">public Field[] getDeclaredFields() throws SecurityException</td>
<td align="center">方法</td>
<td align="center">获取本类定义的全部的成员</td>
</tr>
<tr>
<td align="center">public Field getDeclaredField(String name) throws NoSuchFieldException, SecurityException</td>
<td align="center">方法</td>
<td align="center">获取一个本类定义成员</td>
</tr>
</tbody></table>
<p>​    代码：获取属性信息，见反射实例-例四</p>
<p>​    在代码中获取了所需要的成员的信息，但是Field类的使用并不是获取成员信息的，这个类有如下几个重要的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>public Class&lt; ? &gt; getType()</strong></td>
<td align="center">方法</td>
<td align="center">获取属性类型，可以与上上面代码中(invoke())结合动态获取参数类型</td>
</tr>
<tr>
<td align="center">public Object get(Object obj) throws IllegalArgumentException, IllegalAccessException</td>
<td align="center">方法</td>
<td align="center">获取对象属性</td>
</tr>
<tr>
<td align="center">public void set(Object obj, Object value) throws IllegalArgumentException, IllegalAccessException</td>
<td align="center">方法</td>
<td align="center">设置属性内容</td>
</tr>
<tr>
<td align="center"><strong>public void setAccessible(boolean flag)</strong></td>
<td align="center">方法</td>
<td align="center">取消封装(private)，即设置可见</td>
</tr>
</tbody></table>
<p>​    <strong>图示：field类的继承图示以及setAccessible(boolean flag)方法的作用区间</strong></p>
<p>​    <a target="_blank" rel="noopener" href="https://imgtu.com/i/5DuKSI"><img src="https://z3.ax1x.com/2021/10/20/5DuKSI.png" alt="5DuKSI.png"></a></p>
<p>​    <strong>注意：setAccessible(boolean flag)方法是在AccessibleObject类中定义的方法，所以下面继承此类的方法都可以进行调用，从而解除封装</strong></p>
<p>​    范例：调用类中的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Class&lt;?&gt; clazz = Ball.class;</span><br><span class="line">		Object obj = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">		Field field = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">		field.setAccessible(<span class="keyword">true</span>); <span class="comment">//解除封装</span></span><br><span class="line">		field.set(obj, <span class="string">&quot;篮球&quot;</span>); <span class="comment">//等价于&quot;对象.name = &quot;篮球&quot;&quot;</span></span><br><span class="line">		System.out.println(field.get(obj)); <span class="comment">//等价于&quot;System.out.println(对象.name)&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>注意：类中所谓的封装只是局限于标准语法的访问的限制，但是如果直接利用反射就可以打破这种封装所带来的影响，只不过大多数情况不会这样操作</strong></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401/">数据结构01</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-10-04T03:58:37.000Z" itemprop="datePublished">
    2021-10-04
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="数据结构概述"><a href="#数据结构概述" class="headerlink" title="数据结构概述"></a>数据结构概述</h2><h4 id="1-数据结构中的堆表示堆栈，数据结构中没有堆这个概念，堆分配内存的方式，不属于存储数据的结构。"><a href="#1-数据结构中的堆表示堆栈，数据结构中没有堆这个概念，堆分配内存的方式，不属于存储数据的结构。" class="headerlink" title="1. 数据结构中的堆表示堆栈，数据结构中没有堆这个概念，堆分配内存的方式，不属于存储数据的结构。"></a>1. 数据结构中的堆表示堆栈，数据结构中没有堆这个概念，堆分配内存的方式，不属于存储数据的结构。</h4><h4 id="2-数据结构的定义"><a href="#2-数据结构的定义" class="headerlink" title="2. 数据结构的定义"></a>2. 数据结构的定义</h4><p>​    <strong>以特定的数据类型(个体如何来存储)和特定的存储结构(个体之间的关系)保存到主存储器（内存）中</strong>（注意不是保存到硬盘），以及在此基础上为实现某个功能（比如查找某个元素，删除某个元素，对所有元素进行排序）而执行的相应操作，这个相应的操作也叫算法</p>
<p>​    数据结构 = 个体 + 个体的关系，即解决存储问题<br>​    算法 = 对存储数据的操作（狭义，存储的方式不同则算法也不同），即解决数据操作的问题</p>
<h4 id="3-算法的定义"><a href="#3-算法的定义" class="headerlink" title="3. 算法的定义"></a>3. 算法的定义</h4><p>​    解题的方法和步骤</p>
<h4 id="4-衡量算法的标准"><a href="#4-衡量算法的标准" class="headerlink" title="4. 衡量算法的标准"></a>4. 衡量算法的标准</h4><p>​    (1).时间复杂度<br>​    大概程序要执行的次数，而非执行的时间</p>
<p>​    (2).空间复杂度<br>​    算法执行过程中大概所占用的最大内存</p>
<p>​    (3).难易程度</p>
<p>​    (4).健壮性</p>
<p>​    (5).正确性（废话）</p>
<h4 id="5-数据结构的地位"><a href="#5-数据结构的地位" class="headerlink" title="5. 数据结构的地位"></a>5. 数据结构的地位</h4><p>​    数据结构是软件最核心的课程</p>
<p>​    程序 = 数据的存储 + 数据的操作 + 可以被计算机执行的语言</p>
<h4 id="6-指针变量"><a href="#6-指针变量" class="headerlink" title="6. 指针变量"></a>6. 指针变量</h4><p>​    指针是C语言的灵魂，指针就是地址(内存单元的编号)，地址就是指针，指针变量是存放内存单元地址的变量</p>
<p>​    若指针变量p指向整型变量i，那么*p就是i</p>
<p>​    指针变量都统一的只占四个字节</p>
<p>​    指针变量的声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p; <span class="comment">//p是个指针变量，int * 表示该p变量只能存储int类型变量的地址</span></span><br></pre></td></tr></table></figure>



<h4 id="7-结构体"><a href="#7-结构体" class="headerlink" title="7. 结构体"></a>7. 结构体</h4><p>​    为了表示一些复杂的数据，而普通的基本类型变量无法满足要求，所以使用结构体来表示</p>
<p>​    结构体适合在以算法为核心程序即面向过程的语言，但在面向对象的语言算法就不是核心了</p>
<p>​    注意：对于C语言中结构体内字符串的赋值需要使用strcpy()来进行赋值，不能像Java一样，Java本身也是C和C++实现，而且java是用String类实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcpy(st.name,&quot;LiHua&quot;);</span><br></pre></td></tr></table></figure>
<p>​    <strong>在结构体中有定义一个结构体然后用成员操作符来使用结构体里的成员，但一般不会这样使用，更多的是定义一个结构体指针，然后通过该指针来访问</strong></p>
<p>​    一般都会使用结构体指针来调用里面的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pst-&gt;sid等价于(*pst).sid &#x2F;&#x2F;pst为指针</span><br></pre></td></tr></table></figure>
<p>​    注意：结构体变量不能加减乘除但可以相互赋值</p>
<p>​    结构体变量和结构体指针作为函数传参的问题<br>​    <strong>注意：一般还是用传指针好，如果单传结构体耗内存、耗时间不推荐(即指针占得内存小，一般一个结构体变量占用内存大)</strong></p>
<h4 id="8-malloc-动态分配内存"><a href="#8-malloc-动态分配内存" class="headerlink" title="8. malloc()动态分配内存"></a>8. malloc()动态分配内存</h4><p>​    通过动态分配内存以实现动态分配数组，这样实现数组是灵活的，<strong>动态数组不够时可以继续增加，多出时可以删除</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int len;</span><br><span class="line">scanf(&quot;%d&quot;,len);</span><br><span class="line">int * pArr &#x3D; (int *)malloc(sizeof(int) * len);</span><br></pre></td></tr></table></figure>
<p>​    注意1：malloc()函数只返回第一个字节的地址，强制转换目的是确定多少个为字节为一个元素</p>
<p>​    注意2：用完malloc()后要用free()释放它，不释放的话只能等程序终止了才能释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(pArr); <span class="comment">//把pArr所分配的动态内存释放</span></span><br></pre></td></tr></table></figure>



<h4 id="9-跨函数内存分配问题"><a href="#9-跨函数内存分配问题" class="headerlink" title="9. 跨函数内存分配问题"></a>9. 跨函数内存分配问题</h4><p>​    如果是使用普通在栈内存的函数(静态)，在调用完之后就会释放掉，而如果是含有动态分配的函数，除非手动的去释放调用不然不会系统自动释放</p>
<p>​    范例：跨函数分配内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *p;</span><br><span class="line">	fun(&amp;p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> ** q)</span></span>&#123;</span><br><span class="line">	*q = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


      
    </div>
</article>

    </li>
  
</ul>

  <section id="nav-wrapper">
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">« prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">next »</a>
    </nav>
  </section>


            <footer>
    <div>© 2022 - nature </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>