<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Blog of ChiFun</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(/assets/blog.png)">
        </div>
    </section>
    <section class='menu'>
        <div>Blog of ChiFun</div>
        
            <div>5</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>  
          
            <a href="/about/" class="Btn">
              <li>About</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
            
                <a target="_blank" rel="noopener" href="https://github.com/Magician-Snow">
                    <img src="/assets/github.svg" />
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/06/15/Java09/">Java09</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-06-15T11:34:04.000Z" itemprop="datePublished">
    2021-06-15
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="类的高级特性"><a href="#类的高级特性" class="headerlink" title="类的高级特性"></a>类的高级特性</h2><h4 id="1-类名冲突与完整路径"><a href="#1-类名冲突与完整路径" class="headerlink" title="1. 类名冲突与完整路径"></a>1. 类名冲突与完整路径</h4><p>​    在Java中，同名的两个类需要放在不同的类包(包)中<br>​    完整的类名为包名和类名的组合<br>​    像指定类时是可以写完整类名的但是由于麻烦和可读性就会使用import关键字来引入</p>
<h4 id="2-同一个包中的类相互访问时，可以不指定包名"><a href="#2-同一个包中的类相互访问时，可以不指定包名" class="headerlink" title="2. 同一个包中的类相互访问时，可以不指定包名"></a>2. 同一个包中的类相互访问时，可以不指定包名</h4><h4 id="3-CLASSPATH"><a href="#3-CLASSPATH" class="headerlink" title="3. CLASSPATH"></a>3. CLASSPATH</h4><p>​    直译的话就是类的路径，配置了classpath后java程序会直接去classpath的路径下去找.class文件运行。这样我们就可以在任意目录下来运行我们的java程序，在连接数据库时我配置了这个的环境变量</p>
<h4 id="4-package关键字"><a href="#4-package关键字" class="headerlink" title="4. package关键字"></a>4. package关键字</h4><p>​    用来定义包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package 包名</span><br></pre></td></tr></table></figure>
<p>​    需要将package表达式放置在第一行，它必须是程序第一行非注释代码<br>​    Java包的命名规则：全部使用小写字母</p>
<h4 id="5-import关键字"><a href="#5-import关键字" class="headerlink" title="5. import关键字"></a>5. import关键字</h4><p>​    (1).用来导入包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import 包名.类名  &#x2F;&#x2F;如果类不在包中则只要类名即可</span><br></pre></td></tr></table></figure>
<p>​    如果需要使用包中的多个类，类名用 * 代替， * 表所有的类<br>​    <strong>注意：<br>​    如果已经用import引入了一个类，如果还要引用一个和这个类同名的类，则必须使用完整路径</strong></p>
<p>​    (2).用来导入静态成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static 静态成员 &#x2F;&#x2F;静态成员应为完整路径，可以为静态变量，也可以是静态方法</span><br></pre></td></tr></table></figure>
<p>​    导入完之后就可以直接使用了，不需要再写完整的路径</p>
<h4 id="6-final关键字"><a href="#6-final关键字" class="headerlink" title="6. final关键字"></a>6. final关键字</h4><p>​    <strong>(1).final变量</strong><br>​    使用final声明的变量，一旦被设定就不可以再改变它的值，<strong>通常使用这个方式来定义常量，final常量定义时需要使用大写字母命名</strong><br>​    注意：final变量定义的时候，可以先声明，而不给初值，这种变量也称为final空白</p>
<p>​    final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量</p>
<p>​    <strong>(2).final对象</strong><br>​    使用final修饰对象，一旦一个对象的引用被修饰，则它只能恒定指向一个对象，不能改变指向，未被指定时可以随便指<br>​    <strong>注意：数组也可以看作是一个对象来使用这个关键字</strong></p>
<p>​    <strong>(3).final方法</strong><br>​    定义为final的方法不能被重写，可以被继承<br>​    定义为final的方法的执行效率高于非final的方法<br>​    定义为private不能被子类方法覆盖，private类型的方法默认是final类型的（这句先不说覆不覆盖就private感觉外部就调用不了了）</p>
<p>​    <strong>(4).final类</strong><br>​    定义为final类不能被继承，没有子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final 类名&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>如果一个类设置为final，则类中所有的方法都被隐式设置为final形式，但final类中的成员变量可以被定义为final或者非final形式</strong></p>
<p>​    <strong>(5).static和final一起使用</strong><br>​    static final用来修饰成员变量和成员方法，可以看作为全局常量</p>
<ul>
<li>对于变量，表示一旦给值就不可修改，并且通过类名可以访问</li>
<li>对于方法，表示不可覆盖，并且可以通过类名直接访问</li>
</ul>
<p>​    <strong>注意：对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象</strong></p>
<h4 id="7-内部类"><a href="#7-内部类" class="headerlink" title="7. 内部类"></a>7. 内部类</h4><p>​    如果在一个类中再定义一个类，则将这个再定义的类称为内部类，<strong>内部类分为成员内部类、局部内部类、匿名类</strong></p>
<p>​    <strong>(1).成员内部类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Outside&#123; &#x2F;&#x2F;外部类</span><br><span class="line">	private class Inside&#123; &#x2F;&#x2F;内部类,是一个私有成员</span><br><span class="line">		&#x2F;&#x2F;something</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>在内部类中可以随意使用外部类的成员方法和成员变量，尽管被修饰为了private</strong><br>​    就像main方法放在类中可以访问该类的私有成员一样<br>​    <strong>但外部类不能直接访问内部类成员，需要先将内部类在外部类中实例化后再使用，内部类为private在外部类实例化后一样也可以使用</strong><br>​    <strong>内部类修饰为private只能外部类访问，其他类没有权限访问（哪怕是继承了外部类的子类）</strong></p>
<p>​    内部类的实例化需要绑定在外部类的实例上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;内部类的实例化，如果在外部类和外部类非静态方法之外实例内部类对象则需要下面的形式</span><br><span class="line">外部类名.内部类名 引用变量名 &#x3D; 外部实例引用变量.内部实例  &#x2F;&#x2F;内部实例可以是new的也可以是其他只要是内部实例就行</span><br></pre></td></tr></table></figure>
<p>​    <strong>类中多次实现接口中同一个方法</strong><br>​    在程序中可以用权限修饰符为private的内部类实现。可以在外部提供一个接口，在接口中声明一个方法。如果在实现该接口的内部类中实现该接口的方法，就可以定义多个内部类以不同的方式实现接口中的同一个方法，而在一般的类中是不能多次实现接口中同一个方法的<br>​    此时通过在外部类中写方法实例化这个private内部类，之后用接口的引用来接这个实现接口的实例<br>​    <strong>详细见《Java实例-内部类的基本作用》例一</strong></p>
<p>​    <strong>外部类中定义的成员变量与内部类的成员变量名称相同，可以使用this关键字</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Outside&#123;</span><br><span class="line">	private int x &#x3D; 0;</span><br><span class="line">	private class Inside&#123;</span><br><span class="line">		private int x &#x3D; 9;</span><br><span class="line">		public void doit(int x)&#123;</span><br><span class="line">			x++;              &#x2F;&#x2F;调用的是形参x</span><br><span class="line">			this.x++          &#x2F;&#x2F;调用的是内部类成员变量x</span><br><span class="line">			Outside.this.x++  &#x2F;&#x2F;调用的是外部类成员变量x</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>(2).局部内部类</strong><br>​    在类的局部进行定义，如在类的方法或任意作用域中定义<br>​    由于内部类在类方法或者任意作用域中，<strong>在方法(作用域)的外部是无法访问该内部类</strong>，而内部类却可以访问当前代码块的常量**(final类型的局部变量)<strong>以及</strong>此外部类的所有成员**<br>​    在方法中的局部变量在内部类中可以访问<br>​    <strong>详细见《Java实例-内部类的基本作用》例二</strong></p>
<p>​    <strong>(3).匿名内部类</strong><br>​    用时再查，和局部内部类一样在方法中，不过去掉类名，在return语句下在描述类体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;语法</span><br><span class="line">return new A()&#123;&#x2F;&#x2F;A为接口名</span><br><span class="line">	&#x2F;&#x2F;类体</span><br><span class="line">&#125;; &#x2F;&#x2F;注意：这里特殊的需要加一个分号，分号代表接口的引用表达式的创建</span><br></pre></td></tr></table></figure>
<p>​    匿名内部类编译后会产生以“外部类名$序号”为名称的.class文件，序号以1<del>n排列，分别代表1</del>n个匿名内部类</p>
<p>​    <strong>(4).静态内部类（少见）</strong><br>​    在内部类前加修饰符static，则为静态内部类，<strong>静态内部类中可以声明static成员，但在非静态内部类中不能声明静态成员</strong><br>​    <strong>静态内部类的特点</strong></p>
<ul>
<li>静态内部类内不可以使用外部类的非静态成员</li>
<li>如果创建静态内部类的对象，不需要其外部类的对象<br>​    在程序测试时需要每个文件设置一个主方法，这会产生许多额外的代码，程序本身不需要这些主方法，所以一般把主方法写到静态内部类中，主要是编译后会产生独立类，测试完后删除即可</li>
</ul>
<h4 id="8-内部类的继承"><a href="#8-内部类的继承" class="headerlink" title="8. 内部类的继承"></a>8. 内部类的继承</h4><p>​    内部类的继承比普通类的继承要复杂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">public class First extends A.B&#123; &#x2F;&#x2F;继承内部类class B</span><br><span class="line">	public First(A a) &#123;</span><br><span class="line">		a.super();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">	class B&#123;</span><br><span class="line">		&#x2F;&#x2F;something</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>在某个类继承内部类时，必须硬性给与这个类一个带参数的构造方法，并且该构造方法的参数为需要继承内部类的外部类的引用，同时在构造方法体中使用a.super()语句，这样才为继承提供了必要的对象引用</strong></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/06/15/Java%E5%AE%9E%E4%BE%8B-%E5%86%85%E9%83%A8%E7%B1%BB/">Java实例-内部类</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-06-15T11:32:57.000Z" itemprop="datePublished">
    2021-06-15
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java%E5%AE%9E%E4%BE%8B/">Java实例</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="Java实例-内部类的基本作用"><a href="#Java实例-内部类的基本作用" class="headerlink" title="Java实例-内部类的基本作用"></a>Java实例-内部类的基本作用</h2><h4 id="1-实例内部类–内部类在外部类中，内部类修饰为private"><a href="#1-实例内部类–内部类在外部类中，内部类修饰为private" class="headerlink" title="1. 实例内部类–内部类在外部类中，内部类修饰为private"></a>1. 实例内部类–内部类在外部类中，内部类修饰为private</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">interface Food&#123;</span><br><span class="line">	public void doing();</span><br><span class="line">&#125;</span><br><span class="line">public class First&#123;	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Outside o &#x3D; new Outside();</span><br><span class="line">		Food i &#x3D; o.create(); &#x2F;&#x2F;用接口引用类型来接内部类实现接口的实例</span><br><span class="line">		i.doing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Outside&#123;</span><br><span class="line">	private class Inside implements Food&#123; &#x2F;&#x2F;private只能在外部类访问</span><br><span class="line">		public void doing() &#123;</span><br><span class="line">			System.out.println(&quot;eat egg&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Inside create() &#123;</span><br><span class="line">		return new Inside();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-局部内部类–内部类在外部类的方法中，内部类无修饰符"><a href="#2-局部内部类–内部类在外部类的方法中，内部类无修饰符" class="headerlink" title="2. 局部内部类–内部类在外部类的方法中，内部类无修饰符"></a>2. 局部内部类–内部类在外部类的方法中，内部类无修饰符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">interface Food&#123;</span><br><span class="line">	public void doing();</span><br><span class="line">&#125;</span><br><span class="line">public class First&#123;	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Outside b &#x3D; new Outside();</span><br><span class="line">		Food c &#x3D; b.a();</span><br><span class="line">		c.doing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Outside&#123;</span><br><span class="line">	public Food a() &#123; &#x2F;&#x2F;方法返回值类型为接口类型</span><br><span class="line">		class Inside implements Food&#123;</span><br><span class="line">			public void doing() &#123;</span><br><span class="line">				System.out.println(&quot;hello&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return new Inside();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/06/05/Java08/">Java08</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-06-05T11:46:05.000Z" itemprop="datePublished">
    2021-06-05
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h4 id="1-抽象类的引入"><a href="#1-抽象类的引入" class="headerlink" title="1. 抽象类的引入"></a>1. 抽象类的引入</h4><p>​    一般将父类定义为抽象类，然后对这个父类进行继承与多态处理，在继承树中越上方的类越抽象<br>​    在多态机制中，一般不需要将父类初始化对象，只需要子类对象，<strong>在Java中设置的抽象类不能实例化为对象</strong></p>
<h4 id="2-abstract关键字"><a href="#2-abstract关键字" class="headerlink" title="2. abstract关键字"></a>2. abstract关键字</h4><p>​    abstract关键字定义的类为抽象类，定义的方法为抽象方法，抽象方法没有方法体，方法本身没有意义，但通过重写来获得意义，承载这个抽象方法的抽象类必须被继承，实际上抽象类除了被继承之外没有任何意义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Test&#123;  &#x2F;&#x2F;定义抽象类</span><br><span class="line">	abstract void textAbstract();  &#x2F;&#x2F;定义抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    声明一个抽象的方法，则必须将承载这个抽象方法的类定义为抽象类，不可能在非抽象类获取抽象方法，只要类中有一个抽象方法，这个类就被标记为抽象类<br>​    抽象类被继承后子类若不是抽象类需要实现其中所有的抽象方法，要保证相同的方法名称、参数列表和相同的返回类型<br>​    abstract无法和final共存修饰类，但是抽象类里面可以用final与static修饰变量和方法，若你创建的类不想被创建对象，变量方法不想被继承，但又要可以直接调用，可以实现抽象类</p>
<h4 id="3-接口的引入"><a href="#3-接口的引入" class="headerlink" title="3. 接口的引入"></a>3. 接口的引入</h4><p>​    当你需要的一系列子类既需要继承重写父类的抽象方法，同时还需要一个共同的方法但实现过程各子类不相同，有些甚至不需要，就可以把这个方法封装在接口中，需要的子类再去实现这个接口，不需要的就不用了<br>​    接口是抽象类的延伸，可以把它看作为一个纯粹的抽象类，接口中的所有方法都没有方法体<br>​    接口用来弥补类无法实现多继承的局限<br>​    由于接口为抽象类，为父类，所以你也可以像之前多态一样去使用接口，具体见<strong>7</strong><br>​    <strong>注意：接口内的方法省略abstract关键字</strong><br>​    如果一个类实现了一个接口中要求的所有的方法，然而没有提供方法体而仅仅只有方法标识，那么这个类一定是一个抽象类</p>
<h4 id="4-interface关键字"><a href="#4-interface关键字" class="headerlink" title="4. interface关键字"></a>4. interface关键字</h4><p>​    接口使用interface关键字进行定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface drawTest&#123;&#x2F;&#x2F;public可以不要，有public类时就不需要了</span><br><span class="line">	void draw(); &#x2F;&#x2F;接口内的方法省略abstract关键字</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-implements关键字"><a href="#5-implements关键字" class="headerlink" title="5. implements关键字"></a>5. implements关键字</h4><p>​    一个类实现一个接口，可以使用implements关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;public可以不要，有public类时就不需要了</span><br><span class="line">public class child extends father implements drawTest&#123;&#x2F;&#x2F;可以不继承直接实现接口的，要实现多个接口每个接口用,隔开</span><br><span class="line">	&#x2F;&#x2F;something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-接口的注意事项"><a href="#6-接口的注意事项" class="headerlink" title="6. 接口的注意事项"></a>6. 接口的注意事项</h4><ul>
<li>在接口中方法必须定义为public或者abstract形式，其他权限修饰符不被Java编译器认可，如果未注明默认就是public and abstract的</li>
<li>在接口中定义的任何字段都自动是static和final和public的</li>
<li>继承一个接口时需要实现接口中所有的方法</li>
<li>一个类可以实现不止一个接口，语法见<strong>5</strong></li>
</ul>
<h4 id="7-接口的进阶"><a href="#7-接口的进阶" class="headerlink" title="7. 接口的进阶"></a>7. 接口的进阶</h4><p>​    <strong>我们不能直接去实例化一个接口，因为接口中的方法都是抽象的，是没有方法体的，这样怎么可能产生具体的实例呢？但是，我们可以使用接口类型的引用指向一个实现了该接口的对象，并且可以调用这个接口中的方法</strong></p>
<p>​    应该优先使用接口而不是类来引用对象。如果有适合的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明。只有当你利用构造器创建某个对象的时候，才真正需要引用这个对象的类。<br>​    如果你养成了用接口作为类型的习惯，你的程序将会更加灵活</p>
<h4 id="8-接口的静态方法"><a href="#8-接口的静态方法" class="headerlink" title="8. 接口的静态方法"></a>8. 接口的静态方法</h4><p>​    Java 8允许静态接口方法<br>​    不能覆盖静态接口方法，只能通过使用接口名+静态接口方法名使用该静态接口方法，实例化后是无法调用的<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/4zrWGD"><img src="https://z3.ax1x.com/2021/10/06/4zrWGD.png" alt="4zrWGD.png"></a></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/06/04/Java07/">Java07</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-06-04T14:37:40.000Z" itemprop="datePublished">
    2021-06-04
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="类的继承，多态"><a href="#类的继承，多态" class="headerlink" title="类的继承，多态"></a>类的继承，多态</h2><h4 id="1-继承的基本思想是基于某个父类进行拓展，得到一个新子类，该子类可以继承父类原有的属性和方法，可以增加父类不具备的属性和方法，可以重写-覆盖-父类中的某些方法"><a href="#1-继承的基本思想是基于某个父类进行拓展，得到一个新子类，该子类可以继承父类原有的属性和方法，可以增加父类不具备的属性和方法，可以重写-覆盖-父类中的某些方法" class="headerlink" title="1. 继承的基本思想是基于某个父类进行拓展，得到一个新子类，该子类可以继承父类原有的属性和方法，可以增加父类不具备的属性和方法，可以重写(覆盖)父类中的某些方法"></a>1. 继承的基本思想是基于某个父类进行拓展，得到一个新子类，该子类可以继承父类原有的属性和方法，可以增加父类不具备的属性和方法，可以重写(覆盖)父类中的某些方法</h4><h4 id="2-extends关键字"><a href="#2-extends关键字" class="headerlink" title="2. extends关键字"></a>2. extends关键字</h4><p>​    用来标识两个类的继承关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;父类</span><br><span class="line">class bookStore&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;子类</span><br><span class="line">class book extends bookStore&#123;</span><br><span class="line">	&#x2F;&#x2F;当子类再次声明与父类一样的成员变量时，就有两个名字一样的成员变量，要使用父类的话需用super()关键字来引用父类(无关键字时，子类中和父类中的属性或方法同名，则父类中的方法或属性将被覆盖或隐藏)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-super关键字"><a href="#3-super关键字" class="headerlink" title="3. super关键字"></a>3. super关键字</h4><p>​    (1).在Java类中使用super关键字来引用父类的成分，它是一个指代变量，用于在子类中指代父类对象<br>​    (2).只能用于子类的构造函数和实例方法中，不能用于子类的类（静态）方法中。原因是super指代的是一个父类的对象，它需要在运行时被创建，而静态方法是类方法，它是类的一部分。当类被加载时，方法已经存在，但是这时候父类对象还没有被初始化</p>
<h4 id="4-子类是父类的派生类，它的实例化依赖于父类的实例化。所以它的任何一个构造函数都必须要初始化父类"><a href="#4-子类是父类的派生类，它的实例化依赖于父类的实例化。所以它的任何一个构造函数都必须要初始化父类" class="headerlink" title="4. 子类是父类的派生类，它的实例化依赖于父类的实例化。所以它的任何一个构造函数都必须要初始化父类"></a>4. 子类是父类的派生类，它的实例化依赖于父类的实例化。所以它的任何一个构造函数都必须要初始化父类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class bookStore&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;子类</span><br><span class="line">class book extends bookStore&#123;</span><br><span class="line">	public book()&#123;</span><br><span class="line">		super();  &#x2F;&#x2F;初始化父类</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>注意：</strong></p>
<ul>
<li>在我们子类的构造函数中，如果我们没有显式调用super来初始化父类的话，那么Java会隐式的调用super();来调用父类无参构造函数并把它放在构造函数的第一行</li>
<li>Java只会隐式的调用无参构造函数，如果父类没有无参构造函数，那么子类中就必须显式的调用super关键字来调用已有的有参构造函数来初始化父类</li>
<li> 子类中的super为什么必须要放在第一行？因为子类的实例化依赖于父类的实例化，在构建子类时，必须要有父类实例，只能有了父类的实例，子类才能够初始化自己</li>
</ul>
<h4 id="5-当实例化子类对象时，父类的对象也相应的被实例化，且Java编译器会在子类的构造方法中自动调用父类的无参构造方法，-一个-多个父类时是从顶级向下调用"><a href="#5-当实例化子类对象时，父类的对象也相应的被实例化，且Java编译器会在子类的构造方法中自动调用父类的无参构造方法，-一个-多个父类时是从顶级向下调用" class="headerlink" title="5. 当实例化子类对象时，父类的对象也相应的被实例化，且Java编译器会在子类的构造方法中自动调用父类的无参构造方法，(一个)多个父类时是从顶级向下调用"></a>5. 当实例化子类对象时，父类的对象也相应的被实例化，且Java编译器会在子类的构造方法中自动调用父类的无参构造方法，(一个)多个父类时是从顶级向下调用</h4><h4 id="6-方法的重写"><a href="#6-方法的重写" class="headerlink" title="6. 方法的重写"></a>6. 方法的重写</h4><p>​    重写也可以称为覆盖，是保留父类成员方法的名字，可以重写成员方法实现的内容、成员方法的修饰符权限、成员方法的返回值类型<br><strong>注意：修改成员方法修饰符权限只能从小范围向大范围改变</strong><br><strong>注意：不可以被重写，可以被继承</strong></p>
<p>​    重构：特殊的重写方法，子类与父类的返回值、方法名称、参数类型以及个数完全相同，唯一不同的是方法的实现内容</p>
<h4 id="7-Object类"><a href="#7-Object类" class="headerlink" title="7. Object类"></a>7. Object类</h4><p>​    在Java中所有的类都继承了Java.lang.Object类，由于所有类都是继承这个类所以定义类时可以省略extends Object</p>
<p>​    Object类中的getClass()，notify()，notifyAll()，wait()等方法不能被重写，这些方法被定义为final类型</p>
<p>​    Object类的重要方法</p>
<ul>
<li><p>getClass()方法<br>​    返回对象执行时的Class实例，该实例通过getName()方法获得类的名称</p>
</li>
<li><p>toString()方法<br>​    将一个对象返回为字符串形式，它会返回一个String实例，在实际运用中经常重写该方法</p>
</li>
<li><p>equals()方法<br>​    按理说是比较两个对象的实际内容是否相等,但类对象的equals方法实现了对象上最有区别的等价关系；也就是说，对于任何非空的引用值x和y，当且仅当x和y引用同一对象（x == y的值为true）时，此方法才返回true，像之前的String比较里面内容是因为重写了这个方法<br>​    <strong>注意：在自定义类中使用equals()方法进行比较时，相同的对象比较会返回false，因为equals()方法的默认实现使用”==”运算符来比较两个对象的引用地址，而不上比较对象的内容，所以要比较内容需要重写equals()方法</strong></p>
</li>
</ul>
<h4 id="8-对象类型的转换"><a href="#8-对象类型的转换" class="headerlink" title="8. 对象类型的转换"></a>8. 对象类型的转换</h4><ul>
<li><p>向上转型(多态)<br>​    把子类对象赋值给父类类型的引用变量<br>​    <strong>父类的引用可以调用子类中重写的父类的方法，但不能调用子类中独有的方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类型 a &#x3D; new 子类型();</span><br></pre></td></tr></table></figure>
</li>
<li><p>向下转型(显式类型转换)<br>​    把父类对象强制转化为子类型，赋值给子类引用变量<br>​    进行向下转型时，如果父类对象不是子类的实例，会产生ClassCastException异常，所以经常使用instanceof操作符来完成判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子类型 b &#x3D; (子类型)父类对象的引用变量;</span><br></pre></td></tr></table></figure>
<p>​    父类中没有的方法和类型必须要向下转型后才能调用</p>
</li>
</ul>
<h4 id="9-instanceof操作符"><a href="#9-instanceof操作符" class="headerlink" title="9. instanceof操作符"></a>9. instanceof操作符</h4><p>​    用来判断是否一个类实现了某个接口，还可以判断一个实例的对象是否属于一个类(子类一定时属于父类的，不能说父类属于子类，即平行四边形属于四边形，但四边形不属于平行四边形)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子对象 instanceof 父类型; &#x2F;&#x2F;返回true</span><br></pre></td></tr></table></figure>
<p>​    该方式经常与向下转型连用，当不属于时把父类强制转化为子类<br>​    当两个类完全没有关系时使用这个操作符来操作会报错</p>
<p><strong>详细使用请看笔记《Java实例-多态》</strong></p>
<h4 id="10-方法的重载"><a href="#10-方法的重载" class="headerlink" title="10. 方法的重载"></a>10. 方法的重载</h4><p>​    在同一个类中允许存在一个以上的同名方法，只要这些方法的参数个数或类型不同即可<br>​    <strong>注意：方法重载中可以使两个方法的返回值类型不同，但只有返回值类型不同不足以区分两个方法的重载</strong><br>​    编译器是利用方法名、方法各参数类型和参数的个数以及参数的顺序来确定类中的方法是否唯一</p>
<h4 id="11-不定长参数"><a href="#11-不定长参数" class="headerlink" title="11. 不定长参数"></a>11. 不定长参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;定义不定长参数方法</span><br><span class="line"> &#x2F;&#x2F;返回值 方法名(参数数据类型...参数名称)</span><br><span class="line">public static int add(int...a)&#123;不定长参数a为一个数组，a的长度取决于调用时传的参数</span><br><span class="line">	&#x2F;&#x2F;方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    不定长参数方法可以作为一个单独的重载方法</p>
<h4 id="12-多态"><a href="#12-多态" class="headerlink" title="12. 多态"></a>12. 多态</h4><p>​    多态存在的三个前提</p>
<ul>
<li>要有继承关系</li>
<li>子类要重写父类方法</li>
<li>父类引用指向子类对象</li>
</ul>
<p>​    通过定义一个父类，让它的所有子类通过向上转型的原则作为一个方法的参数，再在这个方法中做出一些限定，后可以做出每个子类自己独有的事情。<br>​    这样的处理可以很好解决代码的冗余问题，同时使得程序易于维护，可以随意增加子类，只需要改变传参就可以了</p>
<p><strong>多态的样例代码见请看笔记《Java实例-多态》</strong></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/06/04/Java%E5%AE%9E%E4%BE%8B-%E5%A4%9A%E6%80%81/">Java实例-多态</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-06-04T14:37:32.000Z" itemprop="datePublished">
    2021-06-04
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java%E5%AE%9E%E4%BE%8B/">Java实例</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="多态实例"><a href="#多态实例" class="headerlink" title="多态实例"></a>多态实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">import java.text.DecimalFormat;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.lang.Math;</span><br><span class="line"></span><br><span class="line">public class First&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		choose(new child1());</span><br><span class="line">		choose(new child2());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void choose(father a) &#123;</span><br><span class="line">		a.Todo();</span><br><span class="line">		if(a instanceof child1) &#123;</span><br><span class="line">			((child1) a).eat();&#x2F;&#x2F;父类中没有的方法和类型必须要向下转型后才能调用</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		else if(a instanceof child2) &#123;</span><br><span class="line">			((child2) a).eat();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class father&#123;</span><br><span class="line">	public father() &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void Todo() &#123;</span><br><span class="line">		System.out.println(&quot;work&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class child1 extends father&#123;</span><br><span class="line">	public child1() &#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void Todo() &#123;</span><br><span class="line">		System.out.println(&quot;study&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void eat() &#123;</span><br><span class="line">		System.out.println(&quot;fish&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class child2 extends father&#123;</span><br><span class="line">	public child2() &#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void Todo() &#123;</span><br><span class="line">		System.out.println(&quot;sing&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void eat() &#123;</span><br><span class="line">		System.out.println(&quot;fish&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/06/02/Java06/">Java06</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-06-02T08:41:57.000Z" itemprop="datePublished">
    2021-06-02
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h4 id="1-为什么要有包装类"><a href="#1-为什么要有包装类" class="headerlink" title="1. 为什么要有包装类"></a>1. 为什么要有包装类</h4><ul>
<li>在面向对象中，“一切皆对象”，但基本数据类型的数据不太符合这一理念，基本数据类型不是对象</li>
<li>涉及到类型之间的转化，数据类型之间的基本操作；如果都有我们自己去实现，那么工作量过大</li>
<li>java针对每一个基本数据类型都设计了一个包装类</li>
</ul>
<h4 id="2-java-lang包中的Integer类、Long类、Short类，可以将int、long和short封装成一个类，这些都是Number的子类，他们包含的方法基本相同，之后只以Integer类为例"><a href="#2-java-lang包中的Integer类、Long类、Short类，可以将int、long和short封装成一个类，这些都是Number的子类，他们包含的方法基本相同，之后只以Integer类为例" class="headerlink" title="2. java.lang包中的Integer类、Long类、Short类，可以将int、long和short封装成一个类，这些都是Number的子类，他们包含的方法基本相同，之后只以Integer类为例"></a>2. java.lang包中的Integer类、Long类、Short类，可以将int、long和short封装成一个类，这些都是Number的子类，他们包含的方法基本相同，之后只以Integer类为例</h4><h4 id="3-Integer类"><a href="#3-Integer类" class="headerlink" title="3. Integer类"></a>3. Integer类</h4><p>Integer类将原语类型int的值包装在对象中。integer类型的对象包含一个类型为int的字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		Integer d &#x3D; Integer.valueOf(400); &#x2F;&#x2F;等同于将基本类型装箱，另一种装箱方法已经不允许Integer d &#x3D; new Integer(400);</span><br><span class="line">		int a &#x3D; d.intValue(); &#x2F;&#x2F;将Integer类型拆箱</span><br><span class="line">&#x2F;*</span><br><span class="line">*在Java 5之前的版本中，基本数据类型和包装类之间的转换是需要手动进行的,但Sun公司从Java5开始提供了的自动装箱(Autoboxing)和自动拆箱(AutoUnboxing)操作</span><br><span class="line">*&#x2F;</span><br><span class="line">		Integer i &#x3D; 13; &#x2F;&#x2F;自动装箱</span><br><span class="line">		int c &#x3D; i;      &#x2F;&#x2F;自动拆箱</span><br><span class="line">		System.out.print(a);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;输出400</span><br></pre></td></tr></table></figure>
<p>一般都是使用该类的提供的一些方法，让数据可以在int类型与String类型之间相互转换<br>如，以下为部分静态方法(详细全部方法见API文档)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">toString() &#x2F;&#x2F;返回一个表示该Integer值的String对象，返回值String</span><br><span class="line">parseInt(String str) &#x2F;&#x2F;返回包含在由str指定的字符串中的数字的等价整数值，返回值int</span><br><span class="line">valueOf(String str或者int i) &#x2F;&#x2F;返回保存指定的String值或int值的Integer对象</span><br><span class="line">intValue() &#x2F;&#x2F;以int型返回此Integer对象，返回值int</span><br></pre></td></tr></table></figure>

<h4 id="4-Boolean类，Byte类，Character类，Double类都与上面Integer类类似，需要时自己查阅即可"><a href="#4-Boolean类，Byte类，Character类，Double类都与上面Integer类类似，需要时自己查阅即可" class="headerlink" title="4. Boolean类，Byte类，Character类，Double类都与上面Integer类类似，需要时自己查阅即可"></a>4. Boolean类，Byte类，Character类，Double类都与上面Integer类类似，需要时自己查阅即可</h4><h2 id="数字处理类"><a href="#数字处理类" class="headerlink" title="数字处理类"></a>数字处理类</h2><h4 id="1-Java中未进行格式化的数字遵循以下原则："><a href="#1-Java中未进行格式化的数字遵循以下原则：" class="headerlink" title="1. Java中未进行格式化的数字遵循以下原则："></a>1. Java中未进行格式化的数字遵循以下原则：</h4><ul>
<li>如果数据绝对值大于0.001并且小于10000000，使以常规小数形式表示</li>
<li>如果数据绝对值小于0.001并且大于10000000，使用科学计数法表示</li>
</ul>
<h4 id="2-数字格式化-使用DecimalFormat"><a href="#2-数字格式化-使用DecimalFormat" class="headerlink" title="2. 数字格式化(使用DecimalFormat)"></a>2. 数字格式化(使用DecimalFormat)</h4><p>​    使用这个类时需要用import关键字将java.text.DecimalFormat引入<br>​    DecimalFormat是NumberFormat的一个子类，用于格式化十进制数字，可以在实例化DecimalFormat对象时传递数字格式(以字符串格式表示)，如果未传入的话则可以通过applyPattern方法来传入设置模板(模板是有特殊字符组成的)，该方法参数为空时抛出异常NullPointerException，<strong>注意：小数时若模板小于数字则会四舍五入</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/2V5aR0"><img src="https://z3.ax1x.com/2021/05/30/2V5aR0.png" alt="2V5aR0.png"></a></p>
<hr>
<p><strong>DecimalFormat类中特殊字符的说明</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">代表阿拉伯数字，一个0表示一个阿拉伯数字，如果该位不存在数字，则显示0</td>
</tr>
<tr>
<td align="center">#</td>
<td align="center">代表阿拉伯数字，一个#表示一个阿拉伯数字，如果该位不存在数字，则不显示</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">小数分割符或货币小数分割符</td>
</tr>
</tbody></table>
<p>​    setGroupingSize(int newValue)方法设置格式化数字的分组大小,分组大小是数字整数部分中分组分隔符之间的位数，像分组为2的话，123456.789为12,34,56.789<br>​    setGroupingUsed(boolean newValue)方法设置是否在此格式中使用分组，newValue的值为如果使用分组，则为true；否则为假</p>
<h4 id="3-数学运算"><a href="#3-数学运算" class="headerlink" title="3. 数学运算"></a>3. 数学运算</h4><p>​    Java中提供了一个执行数学基本运算的Math类，在java.lang.Math，里面提供的大多数方法都被定义为static形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.数字方式</span><br></pre></td></tr></table></figure>
<p>​    Math类也提供一些常用数学常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.PI   &#x2F;&#x2F;Π</span><br></pre></td></tr></table></figure>
<p>​    <strong>常用的数学运算方法分为四类，三角函数方法、指数函数方法、取整函数方法、取最大值最小值绝对值函数方法，具体的需要使用时，自行翻阅API文档</strong></p>
<h4 id="4-随机数"><a href="#4-随机数" class="headerlink" title="4. 随机数"></a>4. 随机数</h4><p>​    通过Math类中的random()方法产生伪随机数字，该方法返回一个double型的随机数，小数点后面可以保留15位小数，返回值是从该范围内以（近似）均匀分布伪随机选择的，范围在0&lt;=Math.random()&lt;1.0，通过对于该方法的处理可以产生任意范围内的随机数，这个方法是调用java.util.Random()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;产生其他范围的伪随机数</span><br><span class="line">(int)(Math.random()*n) &#x2F;&#x2F;返回大于等于0且小于n的随机数</span><br><span class="line">m+(int)(Math.random()*n) &#x2F;&#x2F;返回大于等于m且小于m+n的随机数</span><br></pre></td></tr></table></figure>
<p>​    什么是伪随机数？</p>
<ul>
<li>伪随机数是看似随机实质是固定的周期性序列,也就是有规则的随机。</li>
<li>只要这个随机数是由确定算法生成的,那就是伪随机,只能通过不断算法优化,使你的随机数更接近随机。(随机这个属性和算法本身就是矛盾的)</li>
<li>通过真实随机事件取得的随机数才是真随机数</li>
</ul>
<p>​    Random类<br>​    Random类在java.util下，通过实例化Random对象可以创建一个随机数字生成器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random r &#x3D; new Random(); &#x2F;&#x2F;未在初始化器里设置种子</span><br></pre></td></tr></table></figure>
<p>​    当用这个方式实例化对象时(未在初始化器里设置种子)，Java编译器将以系统当前时间作为随机数生成器的种子(每时每刻时间不同)，但如果运行速度太快，也会产生两次运行结果相同的随机数</p>
<p>​    也可以在实例化对象时，设置随机数生成器种子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random r &#x3D; new Random(long seed); &#x2F;&#x2F;设置种子,当种子一样时，产生的随机数是一样的</span><br></pre></td></tr></table></figure>

<p>​    Random类提供的常用方法(部分)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public int nextInt():返回一个随机整数</span><br><span class="line">public int nextInt(int n):返回大于等于0且小于n的随机整数</span><br><span class="line">public boolean nextBoolean():返回一个随机布尔值</span><br><span class="line">public double nextDouble():返回一个随机双精度值</span><br></pre></td></tr></table></figure>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/05/25/Java05/">Java05</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-05-25T13:30:52.000Z" itemprop="datePublished">
    2021-05-25
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h4 id="1-在Java中对象的属性也被称为成员变量，类对象的行为叫做成员方法"><a href="#1-在Java中对象的属性也被称为成员变量，类对象的行为叫做成员方法" class="headerlink" title="1. 在Java中对象的属性也被称为成员变量，类对象的行为叫做成员方法"></a>1. 在Java中对象的属性也被称为成员变量，类对象的行为叫做成员方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;成员方法的语法格式</span><br><span class="line">	权限修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">	&#x2F;&#x2F;方法体</span><br><span class="line">	return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-权限修饰符"><a href="#2-权限修饰符" class="headerlink" title="2. 权限修饰符"></a>2. 权限修饰符</h4><p><strong>类权限(注意：类权限会约束类成员的权限设定，大于类的权限的类成员都会默认为类的权限进行约束)</strong></p>
<table>
<thead>
<tr>
<th align="center">访问包位置</th>
<th align="center">private</th>
<th align="center">protected</th>
<th align="center">public</th>
</tr>
</thead>
<tbody><tr>
<td align="center">本类</td>
<td align="center">可见</td>
<td align="center">可见</td>
<td align="center">可见</td>
</tr>
<tr>
<td align="center">同包其他类或者子类</td>
<td align="center">不可见</td>
<td align="center">可见</td>
<td align="center">可见</td>
</tr>
<tr>
<td align="center">其他包的类或子类</td>
<td align="center">不可见</td>
<td align="center">不可见</td>
<td align="center">可见</td>
</tr>
</tbody></table>
<p><strong>注意：声明类时不使用上述三个修饰符设置权限，则这个类预设为friendly，可以本类，同包其他类但不能子类，其他包即子类也不行</strong></p>
<h4 id="3-局部变量"><a href="#3-局部变量" class="headerlink" title="3. 局部变量"></a>3. 局部变量</h4><p>​    在成员方法内定义的变量叫做局部变量，方法是形参也是局部变量<br>​    <strong>局部变量在方法内使用时必须进行赋值和初始化不然会报错</strong></p>
<h4 id="4-局部变量的作用域-有效范围"><a href="#4-局部变量的作用域-有效范围" class="headerlink" title="4. 局部变量的作用域(有效范围)"></a>4. 局部变量的作用域(有效范围)</h4><p>​    在相互不嵌套使用的作用域中可以同时声明两个名称和类型相同的局部变量<br>​    一个花括号括起来的表示一个作用域</p>
<h4 id="5-this关键字"><a href="#5-this关键字" class="headerlink" title="5. this关键字"></a>5. this关键字</h4><p>​    在Java语言中规定使用this关键字来代表本类对象的引用，即引用对象的成员变量和方法<br>​    <strong>(1).在局部变量与类的成员变量重名时，就需要添加this关键字来明确引用的是类</strong></p>
<p>​    (2).this关键字还可以作为方法的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Book getBook()&#123;</span><br><span class="line">	return this;      &#x2F;&#x2F;返回Book类的对象等同于return Book</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    (3).this关键字还可以调用构造方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123; &#x2F;&#x2F;定义一个类，类的名字为student。  </span><br><span class="line">	public Student() &#123; &#x2F;&#x2F;定义一个方法，名字与类相同故为构造方法</span><br><span class="line">		this(“Hello!”);   &#x2F;&#x2F;this来引用下面的带形参的构造方法，因为this关键字里面带有一个参数</span><br><span class="line">		&#125;</span><br><span class="line">	public Student(String name) &#123;</span><br><span class="line">		&#x2F;&#x2F;定义一个带形式参数的构造方法 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>注意：this()只能出现在构造方法非注释语句的第一行</strong></p>
<p>​    (4). this关键字不能使用在静态方法当中</p>
<h4 id="6-类的构造方法"><a href="#6-类的构造方法" class="headerlink" title="6. 类的构造方法"></a>6. 类的构造方法</h4><p>类中除了成员方法外，还存在着构造方法<br>​    ==构造方法是一个与类同名的方法==，对象的创建就是构造方法完成的，每当实例化对象(new 对象)时，类会自动调用构造方法<br>​    <strong>注意：构造方法没有返回值，但方法前不需要void关键字修饰，类中没有明确定义构造方法时编译器会自动创建一个不带参数的默认构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构造方法的定义格式</span><br><span class="line">public book()&#123; &#x2F;&#x2F;里面可以放参数</span><br><span class="line">	&#x2F;&#x2F;构造方法体; &#x2F;&#x2F;可以初始化成员变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-static关键字"><a href="#7-static关键字" class="headerlink" title="7. static关键字"></a>7. static关键字</h4><p>​    由static修饰的变量、常量和方法被称为静态变量、常量和方法，即静态成员，静态成员属于类所有，使用类名+’.’运算符调用静态成员<br>​    当需要两个或以上的类要在同一个内存区域共享一个数据，可以使用静态变量来存储该数据<br>​    实例化后的对象依然可以调用静态XX，但不建议使用这样的形式，这样容易混淆静态成员和非静态成员<br>​    <strong>注意：静态方法中不可以直接调用非静态方法</strong><br>​    Java中规定不能将方法体内的局部变量声明为static</p>
<p>​    <strong>类加载</strong><br>​    jvm在程序执行的时候，需要用到类中的信息，但jvm只能读取内存的数据，所以需要进一步操作，把类中的信息，从硬盘上.class文件读取出来放在合适的位置<br>​    当一个类首次被使用，对该类加载，加载的同时，执行类的初始化过程<strong>（注意初始化和实例化的区别）</strong><br>​    被<strong>static关键字修饰</strong>的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">	private Test(String s) &#123;</span><br><span class="line">		System.out.println(s);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;通过static关键字在类加载时初始化a</span><br><span class="line">	private static Test a &#x3D; new Test(&quot;这是一个static程序&quot;);</span><br><span class="line">	</span><br><span class="line">	public static Test instance() &#123;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>​    <strong>类的初始化操作</strong><br>​    通过static定义静态区域(静态块)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class example&#123;</span><br><span class="line">	static&#123;</span><br><span class="line">		&#x2F;&#x2F;some;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    当这个类被引用时，首先自动执行static块中的程序，而且只会执行一次</p>
<h4 id="8-类的主方法"><a href="#8-类的主方法" class="headerlink" title="8. 类的主方法"></a>8. 类的主方法</h4><p>​    主方法是类的入口点，Java编译器通过主方法来执行程序<br>​    主方法语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	&#x2F;&#x2F;方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    主方法的特性<br>​    (1).主方法是静态的,在主方法中要直接调用其他方法,该方法也必须是静态的<br>​    (2).主方法没有返回值<br>​    (3).主方法的形参为数组,args[0]~args[n],表示第一到第n个参数,参数个数用args.length来获取</p>
<h4 id="9-对象"><a href="#9-对象" class="headerlink" title="9. 对象"></a>9. 对象</h4><p>​    (1).对象的创建<br>​    对象是由类抽象出来的某一个特例,每一个对象是相互独立的<br>​    Java语言中使用new操作符调用构造方法来创建对象,对象被创建出来时就是对一个对象的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Book a &#x3D; new Book(); &#x2F;&#x2F;对象的创建可以直接new Book()不需要前面的,但操作不了</span><br></pre></td></tr></table></figure>

<p>​    (2).访问对象的属性和方法<br>​    在使用new操作符创建了一个对象后,可以使用”对象.类成员”来获取对象的属性和方法</p>
<p>​    (3).对象的引用<br>​    基本语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;类名 对象引用名称</span><br><span class="line">Book book; &#x2F;&#x2F;引用不需要有一个对象相关联</span><br></pre></td></tr></table></figure>
<p>​    <strong>注意:引用只是存放一个对象的内存地址,并非存放一个对象</strong></p>
<p>​    (4).对象的比较<br>​    Java语言有两种比较对象的方式,”==”运算符和equals()方法(String类中的方法)</p>
<ul>
<li><p>“==”运算符<br>​    比较的是两个对象的引用地址是否相等</p>
</li>
<li><p>equals()方法<br>​    比较两个对象引用所指向的内容是否相等</p>
</li>
</ul>
<p>​    (5).对象的销毁<br>​    在Java中处于两种情况下对象被Java虚拟机视为垃圾</p>
<ul>
<li>对象引用超过其作用范围(作用域)</li>
<li>将对象的赋值为null</li>
</ul>
<p>​    <strong>注意:Java的垃圾回收器只能销毁new操作符创建的对象</strong><br>​    为了回收不通过new操作符来在内存中获取存储空间的对象,Java还提供object类中的finalize()方法被声明为protected,用户可以自己的类中定义这个方法来回收垃圾(不保证一定发生,当Java虚拟机内存耗尽时,则不会执行垃圾回收处理)<br>​    Java还提供了System.gc()方法强制启动垃圾回收器</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/05/23/Java04/">Java04</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-05-23T09:57:45.000Z" itemprop="datePublished">
    2021-05-23
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="1-数组的声明-两种方式"><a href="#1-数组的声明-两种方式" class="headerlink" title="1. 数组的声明(两种方式)"></a>1. 数组的声明(两种方式)</h4><p>​    注意：数组在声明时并没有分配内存空间<br>​    注意：数组声明数组名后的[]里什么都不能写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;符号[]表面变量为一个数组变量，单个[]表示要创建的数组为一维数组</span><br><span class="line">数组元素类型 数组名字[]</span><br><span class="line">数组元素类型[] 数组名字</span><br></pre></td></tr></table></figure>

<h4 id="2-数组内存空间的分配"><a href="#2-数组内存空间的分配" class="headerlink" title="2. 数组内存空间的分配"></a>2. 数组内存空间的分配</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名字 &#x3D; new 数组元素的类型[数组元素的个数]  &#x2F;&#x2F;创建数组后未进行赋值则数组元素都为该类型的初始值</span><br></pre></td></tr></table></figure>

<h4 id="3-一维数组声明并分配内存空间"><a href="#3-一维数组声明并分配内存空间" class="headerlink" title="3. 一维数组声明并分配内存空间"></a>3. 一维数组声明并分配内存空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[] &#x3D; new int[10];  </span><br></pre></td></tr></table></figure>

<h4 id="4-注意：数组一旦进行初始化不可以对数组手动分配内存空间"><a href="#4-注意：数组一旦进行初始化不可以对数组手动分配内存空间" class="headerlink" title="4. 注意：数组一旦进行初始化不可以对数组手动分配内存空间"></a><strong>4. 注意：数组一旦进行初始化不可以对数组手动分配内存空间</strong></h4><h4 id="5-一维数组的初始化"><a href="#5-一维数组的初始化" class="headerlink" title="5. 一维数组的初始化"></a>5. 一维数组的初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a[] &#x3D; new int[]&#123;1,2,3,4&#125;;  &#x2F;&#x2F;第一种初始化方式，注意括号内不能写数字</span><br><span class="line">int a[] &#x3D; &#123;1,2,3,4&#125;;           &#x2F;&#x2F;第二种初始化方式</span><br><span class="line">int a[];                       &#x2F;&#x2F;第三种初始化方式</span><br><span class="line">a &#x3D; new int[]&#123;1,2,3,4&#125;;        </span><br></pre></td></tr></table></figure>

<h4 id="6-二维-高维-数组声明后的内存空间分配-2种"><a href="#6-二维-高维-数组声明后的内存空间分配-2种" class="headerlink" title="6. 二维(高维)数组声明后的内存空间分配(2种)"></a>6. 二维(高维)数组声明后的内存空间分配(2种)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;(1)为每一维分配内存空间</span><br><span class="line">	a &#x3D; new int[2][4];</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;(2)分别为每一维分配内存空间</span><br><span class="line">	a &#x3D; new int[2][];</span><br><span class="line">	a[0] &#x3D; new int[2];</span><br><span class="line">	a[1] &#x3D; new int[3];</span><br></pre></td></tr></table></figure>

<h4 id="7-二维数组的初始化-与一维类似"><a href="#7-二维数组的初始化-与一维类似" class="headerlink" title="7. 二维数组的初始化(与一维类似)"></a>7. 二维数组的初始化(与一维类似)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组数据类型 数组名[][] &#x3D; &#123;&#123;值1,值2&#125;,&#123;..&#125;,&#123;..&#125;&#125;; &#x2F;&#x2F;注意：每一个大的项要用花括号&#123;&#125;起来,不需要每一项元素个数相等</span><br></pre></td></tr></table></figure>

<h4 id="8-数组的基本操作"><a href="#8-数组的基本操作" class="headerlink" title="8. 数组的基本操作"></a>8. 数组的基本操作</h4><p>​    (1).遍历数组<br>​    通过数组的length属性来获得数组的长度<br>​    **注意：数组的元素只取到length-1</p>
<p>​    (2).剩下的都是一些对数组的函数可以自己用算法来完成，到时要用再看看就行，我觉得可能是方法重写的时候用的上</p>
<h4 id="9-数组排序算法"><a href="#9-数组排序算法" class="headerlink" title="9. 数组排序算法"></a>9. 数组排序算法</h4><p>​    (1).冒泡排序法<br>​    <strong>主要思想：把相邻两个元素进行比较，不满足则交换，每次循环将最大或是最小的元素排在最后，下一次循环进行类似操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;外层循环控制排序轮数，一般比数组长度减一因为最后一次只剩一个数组元素了</span><br><span class="line">for(int i &#x3D; 1;i &lt; arr.length;i++) &#123;</span><br><span class="line">	&#x2F;&#x2F;内层循环用于对比临近元素的大小，对比交换次数随着排序轮数减少</span><br><span class="line">	for(int j &#x3D; 0;j &lt; arr.length-i;j++) &#123;</span><br><span class="line">		if(arr[j]&gt;arr[j+1]) &#123;</span><br><span class="line">			int tmp &#x3D; arr[j];</span><br><span class="line">			arr[j] &#x3D; arr[j+1];</span><br><span class="line">			arr[j+1] &#x3D; tmp;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    (2).直接选择排序法(选择排序的一种)<br>​    <strong>主要思想：将指定排序位置与其他数组元素分别对比，如果满足条件就交换元素的值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;index是用来寻找当前数组中最大或最小的值的索引位置</span><br><span class="line">int index &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;外层循环控制排序轮数，一般比数组长度减一因为最后一次只剩一个数组元素了</span><br><span class="line">for(int i &#x3D; 1;i&lt;arr.length;i++) &#123;</span><br><span class="line">	&#x2F;&#x2F;index在每次循环时都应该清零</span><br><span class="line">	index &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F;内循环用来获取当前数组中最大的值，在下一次循环时不计入该数值</span><br><span class="line">	for(int j &#x3D; 1;j&lt;&#x3D;arr.length - i;j++) &#123;</span><br><span class="line">		if(arr[j]&gt;arr[index]) &#123;</span><br><span class="line">			index&#x3D;j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;将数组最左或者最右的值与数组最大值交换</span><br><span class="line">	int tmp &#x3D; arr[arr.length - i];</span><br><span class="line">	arr[arr.length - i] &#x3D; arr[index];</span><br><span class="line">	arr[index] &#x3D; tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/05/17/Java03/">Java03</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-05-17T11:00:52.000Z" itemprop="datePublished">
    2021-05-17
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h4 id="1-前面的char类型只可以表示单个字符"><a href="#1-前面的char类型只可以表示单个字符" class="headerlink" title="1. 前面的char类型只可以表示单个字符"></a>1. 前面的char类型只可以表示单个字符</h4><h4 id="2-java语言将字符串作为对象来处理，可以通过java-lang包中的String类来创建字符串对象"><a href="#2-java语言将字符串作为对象来处理，可以通过java-lang包中的String类来创建字符串对象" class="headerlink" title="2. java语言将字符串作为对象来处理，可以通过java.lang包中的String类来创建字符串对象"></a><strong>2. java语言将字符串作为对象来处理，可以通过java.lang包中的String类来创建字符串对象</strong></h4><h4 id="3-java中由双引号-“”-包围的都是字符串，不能作为其他数据类型来使用"><a href="#3-java中由双引号-“”-包围的都是字符串，不能作为其他数据类型来使用" class="headerlink" title="3. java中由双引号(“”)包围的都是字符串，不能作为其他数据类型来使用"></a>3. java中由双引号(“”)包围的都是字符串，不能作为其他数据类型来使用</h4><h4 id="4-声明字符串"><a href="#4-声明字符串" class="headerlink" title="4. 声明字符串"></a>4. 声明字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s;</span><br></pre></td></tr></table></figure>
<p><strong>注意：声明的字符串变量必须经过初始化才可以使用，否则编译器报错</strong></p>
<h4 id="5-创建字符串对象"><a href="#5-创建字符串对象" class="headerlink" title="5. 创建字符串对象"></a><strong>5. 创建字符串对象</strong></h4><p>由于java是按照对象来处理字符串，所以创建方式和对象一样</p>
<p>==String类常用的构造方法==<br>​    (1).String(char a[])<br>​    用一个字符数组a创建String对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char a[] &#x3D; &#123;&#39;g&#39;,&#39;o&#39;,&#39;o&#39;,&#39;d&#39;&#125;; 等价于    </span><br><span class="line">String s &#x3D; new String(a);	  &#x3D;&#x3D;&#x3D;&#x3D;&gt;   String s &#x3D; new String(&quot;good&quot;);</span><br></pre></td></tr></table></figure>

<p>​    (2).String(char a[],int offset,int length)  <strong>//从第offse个元素向后取length个元素</strong></p>
<p>​    提取字符数组a中的一部分创建一个字符串对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char a[] &#x3D; &#123;&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;d&#39;,&#39;e&#39;,&#39;n&#39;,&#39;t&#39;&#125;; 等价</span><br><span class="line">String s&#x3D;new String(a,2,4)               &#x3D;&#x3D;&#x3D;&gt;String s&#x3D;new String(&quot;uden&quot;)</span><br></pre></td></tr></table></figure>

<p>​    (3).引用字符串常量来创建字符串变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1,str2;</span><br><span class="line">str1 &#x3D; &quot;We are students&quot;;</span><br><span class="line">str2 &#x3D; &quot;We are students&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>注意：str1和str2引用相同的字符串常量，所以指向同一个实体所在的内存</strong></p>
<h4 id="6-连接字符串"><a href="#6-连接字符串" class="headerlink" title="6. 连接字符串"></a>6. 连接字符串</h4><p>使用”+”运算符可以实现连接多个字符串，”+”连接多个字符串后产生一个String对象<br><strong>注意：字符串也可以与其他基本数据类型连接，连接后这些数据将转化为字符串，当基本数据类型与字符串连接时会自动调用toString()方法将其转为字符串形式</strong></p>
<h4 id="7-获取字符串的长度"><a href="#7-获取字符串的长度" class="headerlink" title="7. 获取字符串的长度"></a>7. 获取字符串的长度</h4><p>​    使用String类型下的length()方法可以获取声明的字符串对象的长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.length()      &#x2F;&#x2F;str为字符串对象</span><br></pre></td></tr></table></figure>
<p>​    字符串的下标是0~length()-1</p>
<h4 id="8-字符串查找的方法"><a href="#8-字符串查找的方法" class="headerlink" title="8. 字符串查找的方法"></a>8. 字符串查找的方法</h4><p>(1).indexOf(String s)<br>返回值为int型，在里面填想要查找的字符串，返回整个字符串中第一次出现的这个字符串的第一个元素的数组下标对应的位置(索引位置)，如果没有检索到字符串s，则返回-1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.indexOf(the_str1)  &#x2F;&#x2F;字符用单(双)引号，字符串用双引号</span><br></pre></td></tr></table></figure>
<p>​    (2).lastIndexOf(String str)<br>​    返回值为int型，在里面填想要查找的字符串，返回整个字符串中最后一次出现的这个字符串的第一个元素的数组下标对应的位置(索引位置)，如果没有检索到字符串s，则返回-1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.lastIndexOf(the_str1)</span><br></pre></td></tr></table></figure>

<p>​    <strong>注意：如果lastIndexOf方法中的参数是空字符串””，则返回结果和调用该字符串的length()方法返回结果相同，indexOf方法中的参数是空字符串””，则返回结果为0</strong></p>
<h4 id="9-获取指定索引位置的字符"><a href="#9-获取指定索引位置的字符" class="headerlink" title="9. 获取指定索引位置的字符"></a>9. 获取指定索引位置的字符</h4><p>​    使用charAt()方法，可以将指定索引处的字符返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.charAt(int index)  &#x2F;&#x2F;返回值为char</span><br></pre></td></tr></table></figure>
<p>​    注意：若索引值超出本身字符串的长度则报错</p>
<h4 id="10-字符串操作"><a href="#10-字符串操作" class="headerlink" title="10. 字符串操作"></a>10. 字符串操作</h4><p>​    (1).获取子字符串<br>​    通过String类下的substring()方法（两种方法重载），返回值String类型</p>
<ul>
<li>substring(int beginIndex)<br>​    从指定的索引位置开始截取直到该字符串结尾的子串，beginIndex指指定的索引位置<br>​    </li>
<li>substring(int beginIndex , int endIndex)<br>​      从字符串某一索引位置开始截取至某一索引位置结束的子串<br>​      <strong>注意：取得到第beginIndex这里的字符，取不到第endIndex这里的字符，即在这里结束</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s &#x3D; &quot;hello&quot;;</span><br><span class="line">String s1 &#x3D; s.substring(3);</span><br><span class="line">System.out.print(s1);</span><br><span class="line">&#x2F;&#x2F;输出：lo</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>​    (2).去除空格<br>​    通过trim()方法返回字符串的副本,作用是忽略前导空格和尾部空格,注意:字符串中间的空格不忽略,返回值为String</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.trim()  &#x2F;&#x2F;str为字符串对象</span><br></pre></td></tr></table></figure>
<p>​<br>​    (3).字符串替换<br>​    通过replace()方法来实现将指定的字符或者字符串替换成新的字符或字符串,返回值为String</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str.replace(char oldChar , char newChar)</span><br><span class="line">&#x2F;*</span><br><span class="line">oldChar:要替换的字符或字符串</span><br><span class="line">newChar:用于替换原来字符串的内容</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<p>​    <strong>注意:<br>​    [1].如果字符串oldChar没有出现在原字符串中,则将原字符串返回<br>​    [2].如果要替换的oldChar在原字符串中出现多次,则会被全部替换成newChar<br>​    [3].切记大小写是区分的</strong></p>
<p>​    (4).判断字符串以什么开头与结尾<br>​    [1].startsWith()方法<br>​    该方法用于判断当前字符串是否以指定的前缀开头，返回值为Boolean类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.startsWith(String prefix)  &#x2F;&#x2F;prefix指作为前缀的字符或字符串</span><br></pre></td></tr></table></figure>
<p>​    [2].endsWith()方法<br>​    该方法用于判断当前字符串是否以指定的后缀结束，返回值为Boolean类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.endsWith(String suffix)  &#x2F;&#x2F;suffix指作为后缀的字符或字符串</span><br></pre></td></tr></table></figure>

<p>​    (5).判断字符串是否相等<br>​    对于字符串的比较不可以使用’==’来进行判断，因为比较运算符是比较两个字符串的地址，即使字符串内容相同但地址也是不同的<br>​    通过equals()方法或者equalsIgnoreCase()方法<br>​    [1].equals()方法<br>​    如果两个字符串具有相同的字符和长度，返回值为ture，即返回值为Boolean类型<br>​    <strong>注意：equals()方法严格区分大小写</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.equals(String otherstr)  &#x2F;&#x2F;str和otherstr相比较</span><br></pre></td></tr></table></figure>
<p>​    [2].equalsIgnoreCase()方法<br>​    在忽略字符串大小写的情况下比较字符串是否相等，返回值为Boolean类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.equalsIgnoreCase(String otherstr)  &#x2F;&#x2F;str和otherstr相比较</span><br></pre></td></tr></table></figure>

<p>​    (6).字符串分割<br>​    使用split()方法对给定原字符串指定的分割字符或分割字符串进行分割，将分割后的结果放在字符串数组中，返回值为字符串数组<br>​    [1].split(String sign)<br>​    对给定分隔符对字符串拆分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.split(String sign)  &#x2F;&#x2F;sign为分割符为String类型，即注意必须用&quot;&quot;,不能使用&#39;&#39;</span><br></pre></td></tr></table></figure>

<p>​    [2].split(String sign,int limit)<br>​    对给定分隔符对字符串拆分，并限制拆分次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.split(String sign,int limit)  &#x2F;&#x2F;sign为分割符为String类型，即注意必须用&quot;&quot;,不能使用&#39;&#39;,limit为分割次数</span><br></pre></td></tr></table></figure>
<p>​    **注意：如果想定义多个分割符，可以使用’|’来隔开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;如：</span><br><span class="line">str.split(&quot;+|&#x3D;&quot;)  &#x2F;&#x2F;以+和&#x3D;进行分割</span><br></pre></td></tr></table></figure>

<h4 id="11-格式化字符串"><a href="#11-格式化字符串" class="headerlink" title="11. 格式化字符串"></a>11. 格式化字符串</h4><pre><code>  String类的静态format()方法用于创建格式化字符串，返回值为String类型</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s &#x3D; String.format(&quot;转换符&quot;,变量); &#x2F;&#x2F;对变量进行格式化，变量参数只要是类类型就可以</span><br></pre></td></tr></table></figure>
<p>​    与C语言中printf的转化类似</p>
<h4 id="12-了解"><a href="#12-了解" class="headerlink" title="12. 了解"></a>12. 了解</h4><p>​    (1).Date类来实现获取日期并通过格式化字符串来显示想要的数据<br>​    (2).正则表达式是用来检查某一字符串是否满足某一格式<br>​    (3).字符串生成器StringBuilder类，用来实现对字符串操作提高效率</p>
<h4 id="13-StringBuilder类与String类型的转换"><a href="#13-StringBuilder类与String类型的转换" class="headerlink" title="13. StringBuilder类与String类型的转换"></a>13. StringBuilder类与String类型的转换</h4><ul>
<li><p>将String类转为StringBuilder类(转为StringBuffer类同理)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s &#x3D; “xxxx”;</span><br><span class="line">StringBuilder sb &#x3D; new StringBuilder(s);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将StringBuilder类转为String类(StringBuffer类转String同理)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder s1 &#x3D; new StringBuilder(); &#x2F;&#x2F;初始化器里可以赋值</span><br><span class="line">String s &#x3D; s1.toString();</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/05/05/%E9%9F%B3%E4%B9%90%E5%B0%8F%E7%A8%8B%E5%BA%8F03/">音乐小程序03</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-05-05T09:24:17.000Z" itemprop="datePublished">
    2021-05-05
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E9%9F%B3%E4%B9%90%E5%B0%8F%E7%A8%8B%E5%BA%8F/">音乐小程序</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="首页的编写"><a href="#首页的编写" class="headerlink" title="首页的编写"></a>首页的编写</h2><p><strong>1. 轮播图</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;block&gt;&lt;&#x2F;block&gt;组件</span><br><span class="line">作用：作为一个结点并不会渲染到界面上，一般把wx:for放在里面，循环中每个选项默认的值是item</span><br></pre></td></tr></table></figure>
<p>wxml代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;需要对swiper(大盒子)和image(小盒子)进行wxss大小的限定</span><br><span class="line">&lt;swiper autoplay&#x3D;&quot;true&quot; circular&#x3D;&quot;true&quot; indicator-dots&#x3D;&quot;true&quot; class&#x3D;&quot;head&quot;&gt;</span><br><span class="line">  &lt;block wx:for&#x3D;&quot;&#123;&#123;swiperpictures&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;swiper-item&gt;</span><br><span class="line">      &lt;image src&#x3D;&quot;&#123;&#123;item.url&#125;&#125;&quot; mode&#x3D;&quot;widthFix&quot; class&#x3D;&quot;swiperimg&quot;&gt;&lt;&#x2F;image&gt;  &#x2F;&#x2F;url是在js代码中自己定义的对象名</span><br><span class="line">    &lt;&#x2F;swiper-item&gt;</span><br><span class="line">  &lt;&#x2F;block&gt;</span><br><span class="line">&lt;&#x2F;swiper&gt;</span><br></pre></td></tr></table></figure>

<p>wxss代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.head&#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 544rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.swiperimg&#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在js中data里的数据就是需要展示在页面中的数据</strong><br>js代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">	&#x2F;&#x2F;建立一个数组swiperpictures</span><br><span class="line">    swiperpictures:[  </span><br><span class="line">	  &#x2F;&#x2F;每一个花括号里面是一个对象,对象名自己起</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F;对象里面放的是图片的网络地址</span><br><span class="line">        url:&quot;https:&#x2F;&#x2F;636c-cloud-7gxr9uz450402f24-1305716784.tcb.qcloud.la&#x2F;2020.jpg&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        url:&quot;https:&#x2F;&#x2F;636c-cloud-7gxr9uz450402f24-1305716784.tcb.qcloud.la&#x2F;2020.jpg&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        url:&quot;https:&#x2F;&#x2F;636c-cloud-7gxr9uz450402f24-1305716784.tcb.qcloud.la&#x2F;2020.jpg&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p><strong>2. 组件化开发</strong><br>    (1)组件：在用户界面开发领域，组件是一种面向用户的、独立的、可复用的交互元素的封装<br>    (2)组件的构成<br>    结构-&gt;wxml<br>    逻辑-&gt;js<br>    样式-&gt;wxss<br>    还会有json文件（对当前组件的配置文件）<br>    (3)组件并不一定需要多次使用</p>
<p><strong>3. 自定义歌单组件</strong><br>​    <strong>(1)创建自定义组件</strong><br>​    在miniprogram中新建一个文件夹components(组件)，再在该文件夹下创建playlist(歌单)文件夹，再在该文件夹下创建component名字可以和文件夹相同<br>​    <strong>(2)自定义组件的引用</strong><br>​    首先要完成自定义组件的构成，如只在wxss中写一段话<br>​    在想要引用的页面的文件的json文件中”usingComponents”中写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;usingComponents&quot;: &#123;</span><br><span class="line">   &quot;l-playlist&quot;: &quot;..&#x2F;..&#x2F;components&#x2F;playlist&#x2F;playlist&quot;  &#x2F;&#x2F;前面是自己对组件起名，后面是写组件的路径，这个路径要精确到文件夹下的文件，不需要写后缀</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​    之后就在引用组件的页面的wxml文件夹中引用标签名，标签名为你所起的名字<br>​    如，在home.wxml(首页)中引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;l-playlist&gt;&lt;&#x2F;l-playlist&gt;</span><br></pre></td></tr></table></figure>

<p>​     <strong>(3).从页面向自定义组件传参</strong><br>​     在页面的js文件中的page下新建一个数组playlist_data，再在里面放一些对象(数据)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">playlist_data:[</span><br><span class="line">      &#123;&quot;_id&quot;:&quot;08560c9e5d042a5c0174f1ca26f1d7b2&quot;,&quot;copywrier&quot;:&quot;热门推荐&quot;,&quot;playCount&quot;:1.4641238e+06,&quot;highQuality&quot;:false,&quot;type&quot;:0.0,&quot;canDislike&quot;:true,&quot;name&quot;:&quot;天气转热了，适合听点凉爽的歌。&quot;,&quot;alg&quot;:&quot;cityLevel_unknow&quot;,&quot;createTime&quot;:&#123;&quot;$date&quot;:&quot;2019-06-14T23:14:36.746Z&quot;&#125;,&quot;id&quot;:2.780381322e+09,&quot;picUrl&quot;:&quot;https:&#x2F;&#x2F;p2.music.126.net&#x2F;Biky7TE4CtW6NjGuqoUKZg&#x3D;&#x3D;&#x2F;109951164041827987.jpg&quot;,&quot;trackCount&quot;:53.0&#125;,</span><br><span class="line">      &#123;&quot;_id&quot;:&quot;08560c9e5d042a5c0174f1da7aa357aa&quot;,&quot;highQuality&quot;:false,&quot;copywriter&quot;:&quot;热门推荐&quot;,&quot;canDislike&quot;:true,&quot;playCount&quot;:622822.6,&quot;id&quot;:2.740107647e+09,&quot;name&quot;:&quot;「时空潜行」囿于昼夜的空想主义者&quot;,&quot;type&quot;:0.0,&quot;alg&quot;:&quot;cityLevel_unknow&quot;,&quot;createTime&quot;:&#123;&quot;$date&quot;:&quot;2019-06-14T23:14:36.955Z&quot;&#125;,&quot;picUrl&quot;:&quot;https:&#x2F;&#x2F;p2.music.126.net&#x2F;Q0eS0avwGK04LufWM7qJug&#x3D;&#x3D;&#x2F;109951164116217181.jpg&quot;,&quot;trackCount&quot;:20.0&#125;,</span><br><span class="line">      &#123;&quot;_id&quot;:&quot;08560c9e5d042a5c0174f1de21c7e79e&quot;,&quot;id&quot;:2.828842343e+09,&quot;type&quot;:0.0,&quot;name&quot;:&quot;粤语情诗：与你听风声，观赏过夜星&quot;,&quot;picUrl&quot;:&quot;https:&#x2F;&#x2F;p2.music.126.net&#x2F;K9IcG8cU6v4_SwuQ_x2xMA&#x3D;&#x3D;&#x2F;109951164124604652.jpg&quot;,&quot;highQuality&quot;:false,&quot;alg&quot;:&quot;cityLevel_unknow&quot;,&quot;playCount&quot;:1.785097e+06,&quot;trackCount&quot;:52.0,&quot;copywriter&quot;:&quot;热门推荐&quot;,&quot;canDislike&quot;:true,&quot;createTime&quot;:&#123;&quot;$date&quot;:&quot;2019-06-14T23:14:36.982Z&quot;&#125;&#125;,</span><br><span class="line">      &#123;&quot;_id&quot;:&quot;08560c9e5d042a5d0174f1e67d1bb16f&quot;,&quot;playCount&quot;:7.719329e+06,&quot;highQuality&quot;:false,&quot;trackCount&quot;:950.0,&quot;alg&quot;:&quot;cityLevel_unknow&quot;,&quot;id&quot;:9.17794768e+08,&quot;type&quot;:0.0,&quot;name&quot;:&quot;翻唱简史：日本四百首&quot;,&quot;canDislike&quot;:true,&quot;createTime&quot;:&#123;&quot;$date&quot;:&quot;2019-06-14T23:14:37.037Z&quot;&#125;,&quot;copywriter&quot;:&quot;热门推荐&quot;,&quot;picUrl&quot;:&quot;https:&#x2F;&#x2F;p2.music.126.net&#x2F;NczCuurE5eVvObUjssoGjQ&#x3D;&#x3D;&#x2F;109951163788653124.jpg&quot;&#125;,</span><br><span class="line">      &#123;&quot;_id&quot;:&quot;08560c9e5d042a5d0174f1ea32c4c288&quot;,&quot;type&quot;:0.0,&quot;copywriter&quot;:&quot;热门推荐&quot;,&quot;highQuality&quot;:false,&quot;createTime&quot;:&#123;&quot;$date&quot;:&quot;2019-06-14T23:14:37.097Z&quot;&#125;,&quot;id&quot;:2.201879658e+09,&quot;alg&quot;:&quot;cityLevel_unknow&quot;,&quot;playCount&quot;:1.06749088e+08,&quot;name&quot;:&quot;你的青春里有没有属于你的一首歌？&quot;,&quot;picUrl&quot;:&quot;https:&#x2F;&#x2F;p2.music.126.net&#x2F;wpahk9cQCDtdzJPE52EzJQ&#x3D;&#x3D;&#x2F;109951163271025942.jpg&quot;,&quot;canDislike&quot;:true,&quot;trackCount&quot;:169.0&#125;,</span><br><span class="line">      &#123;&quot;_id&quot;:&quot;08560c9e5d0829820362a79f4b049d2d&quot;,&quot;alg&quot;:&quot;cityLevel_unknow&quot;,&quot;name&quot;:&quot;「乐队的夏天」参赛歌曲合集丨EP04更新&quot;,&quot;highQuality&quot;:false,&quot;picUrl&quot;:&quot;http:&#x2F;&#x2F;p2.music.126.net&#x2F;2WE5C2EypEwLJd2qXFd4cw&#x3D;&#x3D;&#x2F;109951164086686815.jpg&quot;,&quot;trackCount&quot;:158.0,&quot;createTime&quot;:&#123;&quot;$date&quot;:&quot;2019-06-18T00:00:02.553Z&quot;&#125;,&quot;copywriter&quot;:&quot;热门推荐&quot;,&quot;playCount&quot;:1.5742008e+06,&quot;canDislike&quot;:true,&quot;id&quot;:2.79477263e+09,&quot;type&quot;:0.0&#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<p>​      之后在该页面的wxml文件中，循环遍历这个控件的标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;   &#x2F;&#x2F;view标签是之后可以设计一些样式</span><br><span class="line">  &lt;block wx:for&#x3D;&quot;&#123;&#123;playlist_data&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;l-playlist send_data&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;&gt;&lt;&#x2F;l-playlist&gt;  &#x2F;&#x2F;send_data:将数据传出去,名字随便起的</span><br><span class="line">  &lt;&#x2F;block&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>
<p>​    <strong>(4).在自定义组件中接收参数</strong><br>​    在自定义组件的js文件中<br>​    properties:{}是用来接收传过来的参数的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">properties: &#123;</span><br><span class="line">	  &#x2F;&#x2F;冒号前的名字与之前页面自定义控件起的属性名一致</span><br><span class="line">	  send_data:&#123;</span><br><span class="line">        type:Object  &#x2F;&#x2F;指定传入参数的类型，类型给与的是对象用object，其他值后面再定义</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>​    data:{}里面放的是组件内部的数据<br>​    methods:{}里面放组件里对应的一些方法(如点击跳转)</p>
<p>​    <strong>(5).在组件中显示这些传过来的参数</strong><br>​    在组件的wxml文件中引用这些传过来的参数，通过在组件js的属性名来引用对象中具体的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class&#x3D;&quot;playlist-content&quot;&gt;</span><br><span class="line">  &lt;image src&#x3D;&quot;&#123;&#123;send_data.picUrl&#125;&#125;&quot; class&#x3D;&quot;playlist-img&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">  &lt;text class&#x3D;&quot;playlist-playCount&quot;&gt;&#123;&#123;send_data.playCount&#125;&#125;&lt;&#x2F;text&gt;</span><br><span class="line">  &lt;view class&#x3D;&quot;playlist-name&quot;&gt;&#123;&#123;send_data.name&#125;&#125;&lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>
<p>​    之后再通过组件的wxss文件来写一些css样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.playlist-content&#123;</span><br><span class="line">  width: 220rpx;</span><br><span class="line">  position: relative;</span><br><span class="line">  padding-bottom: 20rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.playlist-img&#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 220rpx;</span><br><span class="line">  border-radius: 6rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.playlist-playCount&#123;</span><br><span class="line">  font-size: 24rpx;</span><br><span class="line">  color: white;</span><br><span class="line">  text-shadow: 1px 0px 0px black;</span><br><span class="line">  position: absolute;</span><br><span class="line">  right: 10rpx;</span><br><span class="line">  top: 4rpx;</span><br><span class="line">  padding-left: 26rpx; </span><br><span class="line">  background: ;   &#x2F;&#x2F;自行引入base64的图片</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.playlist-name&#123;</span><br><span class="line">  font-size: 26rpx;</span><br><span class="line">  line-height: 1.2;</span><br><span class="line">  padding: 2px 0px 0px;</span><br><span class="line">  display: -webkit-box;</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">  -webkit-line-clamp: 2;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>注意：小程序中的背景图片是不允许使用网页图片的，只能使用小程序的本地图片，或者base64的图片(百度一下很多网站都可以在线把图片转base64)</strong><br>​    之后对控件在页面的位置再在页面的wxss中写一些布局(css)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.home-playlist&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-wrap: wrap;</span><br><span class="line">  justify-content: space-around;</span><br><span class="line">  margin-top: 10rpx;</span><br><span class="line">  flex-direction: row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>(6).组件化开发的数据监听器</strong><br>​    当数据变化时可以监听到数据的变化<br>​    在组件的js文件中的properties的同级写一个数据监听器observers:{}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 数据监听器</span><br><span class="line">   *&#x2F;</span><br><span class="line">  observers:&#123;</span><br><span class="line">  &#x2F;&#x2F;里面写对谁进行数据监听，对应的是一个方法</span><br><span class="line">    send_data(count)&#123;</span><br><span class="line">      console.log(count) &#x2F;&#x2F;此时打印出整个对象</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    如果要监听对象里的某个具体属性，需要改为</span><br><span class="line">    [&#39;send_data.playCount&#39;](count)&#123;</span><br><span class="line">      console.log(count)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>(7).对组件化开发监听器监听的数据的格式化处理</strong><br>​    在组件的js文件中的methods:{}中自己定义一个方法<br>​    注意：私有方法的命名格式以_开头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    _tranNumber(num,point)&#123;</span><br><span class="line">      let numStr &#x3D; num.toString().split(&#39;.&#39;)[0]   &#x2F;&#x2F;把数字转为字符串类型，并忽略小数点，split表分隔作用，[0]取第一部分</span><br><span class="line">      &#x2F;&#x2F;对数字转化</span><br><span class="line">      if(numStr.length &lt; 6)&#123;</span><br><span class="line">        return numStr</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;substring(start,end)(得到的子字符串不包含end位置的字符)</span><br><span class="line">      else if(numStr.length &gt;&#x3D; 6 &amp;&amp; numStr.length &lt;&#x3D; 8)&#123;</span><br><span class="line">        let decimal &#x3D; numStr.substring(numStr.length - 4 ,numStr.length - 4 + point) </span><br><span class="line">        return parseFloat(parseInt(num &#x2F; 10000) + &quot;.&quot; + decimal) + &quot;万&quot;</span><br><span class="line">      &#125;</span><br><span class="line">      else if(numStr.length &gt; 8)&#123;</span><br><span class="line">        let decimal &#x3D; numStr.substring(numStr.length - 8 , numStr.length - 8 + point)</span><br><span class="line">        return parseFloat(parseInt(num &#x2F; 100000000) + &quot;.&quot; + decimal) + &quot;亿&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>(7).通过this.setData的方式将处理的数据显示在页面上</strong><br>​    <strong>需要引用第二个值来接收处理完的数据，，因为如果继续给[‘send_data.playCount’]，那又会被数据监听器监听到会进入一个死循环,==即不能对当前监听的值进行赋值==</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 数据监听器</span><br><span class="line"> *&#x2F;</span><br><span class="line">observers:&#123;</span><br><span class="line">  [&#39;send_data.playCount&#39;](count)&#123;</span><br><span class="line">    console.log(count)</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      _count:this._tranNumber(count,2)  &#x2F;&#x2F;将处理后的数据赋值给刚刚声明的变量</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 组件的初始数据</span><br><span class="line"> *&#x2F;</span><br><span class="line">data: &#123;</span><br><span class="line">  _count:0   &#x2F;&#x2F;重新声明一个值来接收处理后的值</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>​    页面上应该显示_count的值，所以需要修改控件的wxml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;text class&#x3D;&quot;playlist-playCount&quot;&gt;&#123;&#123;_count&#125;&#125;&lt;&#x2F;text&gt;</span><br></pre></td></tr></table></figure>

<p><strong>4. wx:key的使用</strong><br>​    在使用wx:for时，应该写入一个wx:key来提高程序的性能<br>​    <strong>(1).对于遍历时对于每个对象的重命名，通过wx:for-item来改名</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将每一个对象重命名为data</span><br><span class="line">&lt;block wx:for&#x3D;&quot;&#123;&#123;arr&#125;&#125;&quot; wx:for-item&#x3D;&quot;data&quot;&gt; </span><br><span class="line">	&lt;view&gt;&#123;&#123;data&#125;&#125;&lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;block&gt;</span><br></pre></td></tr></table></figure>
<p>​    <strong>(2).索引的使用</strong><br>​    通过index来引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;block wx:for&#x3D;&quot;&#123;&#123;arr&#125;&#125;&quot; wx:for-item&#x3D;&quot;data&quot;&gt; </span><br><span class="line">	&lt;view&gt;&#123;&#123;index&#125;&#125;:&#123;&#123;data&#125;&#125;&lt;&#x2F;view&gt;   &#x2F;&#x2F;使用索引，从0开始</span><br><span class="line">&lt;&#x2F;block&gt;</span><br></pre></td></tr></table></figure>
<p>​    如果要更改索引的名字，通过wx:for-index来改名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;block wx:for&#x3D;&quot;&#123;&#123;arr&#125;&#125;&quot; wx:for-item&#x3D;&quot;data&quot; wx:for-index&#x3D;&quot;idx&quot;&gt; </span><br><span class="line">	&lt;view&gt;&#123;&#123;idx&#125;&#125;:&#123;&#123;data&#125;&#125;&lt;&#x2F;view&gt;   &#x2F;&#x2F;使用索引，从0开始</span><br><span class="line">&lt;&#x2F;block&gt;</span><br></pre></td></tr></table></figure>
<p>​    <strong>(3).wx:key的作用</strong><br>​    <strong>当遍历的对象会随着一些变化而变化时，当前这些对象要保持自己的一些状态就需要使用wx:key</strong><br>​    小程序中提供*this来指向元素本身</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wx:key&#x3D;&quot;&#123;&#123;*this&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>​    如果指定的是对象的话，只需要指定对象的一个唯一的属性作为wx:key中两个花括号里的参数就行</p>
<p>​    因此，现在把项目中的一些警告修改一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">遍历向组件传参时，此时_id为对象的主键，把他作为wx:key的参数</span><br><span class="line">&lt;block wx:for&#x3D;&quot;&#123;&#123;playlist_data&#125;&#125;&quot; wx:key&#x3D;&quot;_id&quot;&gt;</span><br><span class="line"></span><br><span class="line">遍历轮播图时，把轮播图图片的对象url作为wx:key的参数</span><br><span class="line">&lt;block wx:for&#x3D;&quot;&#123;&#123;swiperpictures&#125;&#125;&quot; wx:key&#x3D;&quot;url&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>此时，警告都会消除</p>

      
    </div>
</article>

    </li>
  
</ul>

  <section id="nav-wrapper">
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">« prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">next »</a>
    </nav>
  </section>


            <footer>
    <div>© 2021 - nature </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>