<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Java15 | 祈雨</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(/assets/blog.png)">
        </div>
    </section>
    <section class='menu'>
        <div>祈雨</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>  
          
            <a href="/about/" class="Btn">
              <li>About</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
            
                <a target="_blank" rel="noopener" href="https://github.com/Magician-Snow">
                    <img src="/assets/github.svg" />
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>Java15</h1>
    </header>

    <section>
      <h2 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h2><h4 id="1-多线程编程的本质就是并发编程"><a href="#1-多线程编程的本质就是并发编程" class="headerlink" title="1. 多线程编程的本质就是并发编程"></a>1. 多线程编程的本质就是并发编程</h4><p>​    并发编程的本质是指的发挥出所有硬件的最大性能</p>
<p>​    Java是为数不多的真正支持有多线程并发编程的开发语言，所以在整体的处理性能上是最高的</p>
<p>​    而python是多进程编程的注意区分</p>
<h4 id="2-进程"><a href="#2-进程" class="headerlink" title="2. 进程"></a>2. 进程</h4><p>​    传统硬件只有一个CPU(单核CPU)，为了发挥硬件的全部性能，引入了多进程编程模式</p>
<ul>
<li>进程指的是一个具有一定独立功能的程序关于某个数据集合的一次运行活动</li>
<li>进程是系统进行资源分配和调度运行的基本单位</li>
<li>进程实体中包含有三个组成部分：“程序”、“数据”、“PCB(进程控制块)”</li>
</ul>
<h4 id="3-单进程运行与多进程运行的区别"><a href="#3-单进程运行与多进程运行的区别" class="headerlink" title="3. 单进程运行与多进程运行的区别"></a>3. 单进程运行与多进程运行的区别</h4><p>​    单进程运行<br>​    所有的系统资源都为一个进程服务，该进程资源独享</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5oHkGR"><img src="https://z3.ax1x.com/2021/10/26/5oHkGR.png" alt="5oHkGR.png"></a></p>
<p>​    多进程运行<br>​    在没有拓展原始系统硬件资源的前提下，利用一些算法，实现多个进程的并行执行</p>
<p>​    在每个进程执行时要独享全部资源，即在同一个时间点上只会有一个进程执行</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5o7LPs"><img src="https://z3.ax1x.com/2021/10/26/5o7LPs.png" alt="5o7LPs.png"></a></p>
<h4 id="4-线程"><a href="#4-线程" class="headerlink" title="4. 线程"></a>4. 线程</h4><p>​    线程是在进程基础上的进一步划分，可以达到更快的处理性能，任何一个进程的启动都是非常缓慢的，线程性能上远高于进程，但是线程不可以离开进程存活</p>
<p>​    进程与线程图示</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5oqIr6"><img src="https://z3.ax1x.com/2021/10/26/5oqIr6.png" alt="5oqIr6.png"></a></p>
<p>​    每一个进程都只有一个自己的重要处理单元，如果要想实现CPU(变量信息等)的共享，则必须利用线程来描述</p>
<p>​    一般来说，每一块CPU只会有一个线程执行，但有一些CPU可以使用超线程技术，设计出若干个多线程的执行状态，这叫<strong>超线程</strong></p>
<h4 id="5-并行编程"><a href="#5-并行编程" class="headerlink" title="5. 并行编程"></a>5. 并行编程</h4><p>​    随着硬件和软件技术的发展，硬件中的CPU出现了多核状态，理论上多核CPU的多进程执行称为并行编程</p>
<h4 id="6-纤-协-程"><a href="#6-纤-协-程" class="headerlink" title="6. 纤(协)程"></a>6. 纤(协)程</h4><p>​    在进程和线程的概念之上还有一个叫纤(协)程，是在线程基础上进一步划分，并不是像进程和线程一样由硬件支持，协程用的是由程序控制的<br>​    Java并没有支持有多协程编程（不代表以后没有），像python是支持多协程的</p>
<h4 id="7-多线程编程起步"><a href="#7-多线程编程起步" class="headerlink" title="7. 多线程编程起步"></a>7. 多线程编程起步</h4><p>​    所有的Java程序是通过主方法完成的，主方法作为程序的起点。而要进行多线程的编程也需要一个线程的起点结构，此结构称为线程类，所有的线程类是有继承要求的，可以有三种实现模式：<strong>继承Thread类、实现Runnable接口、实现Callable接口(两个接口更重要)</strong></p>
<h5 id="1-继承Thread类的实现多线程"><a href="#1-继承Thread类的实现多线程" class="headerlink" title="1. 继承Thread类的实现多线程"></a>1. 继承Thread类的实现多线程</h5><p>​    java.lang.Thread是由系统定义的一个线程处理类，<em>任何的子类只需要继承此类就可以得到一个线程处理的能力，在使用时一定要覆写Thread类中的run()方法</em>，<strong>这个方法将作为一个线程启动的主方法存在</strong></p>
<p>​    范例：定义一个<strong>线程主体类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread&#123; &#x2F;&#x2F;得到了一个线程主体类</span><br><span class="line">	private String name;</span><br><span class="line">	public MyThread(String name) &#123; &#x2F;&#x2F;保存线程名称</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public void run() &#123; &#x2F;&#x2F;覆写run()方法</span><br><span class="line">		for(int x &#x3D; 0; x &lt; 30 ; x++) &#123;</span><br><span class="line">			System.out.println(&quot;【&quot;+this.name+&quot;线程】运行，x &#x3D; &quot;+x);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>线程中主方法类和线程类的关系</strong><br>​    要在主类的主方法中启动线程<br>​    线程一般会多个交替执行，所以无法通过调用run()方法来调用线程<br>​    通过start()方法来开启线程<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/IpE5DS"><img src="https://z3.ax1x.com/2021/10/31/IpE5DS.png" alt="IpE5DS.png"></a></p>
<p>​    <strong>如果想要进行多线程的并发执行，则需要调用机器上操作系统提供的底层函数支持，所有多线程启动并不是依靠调用run()方法完成的，它需要通过start()方法进行启动，所有start()方法启动之后将调用run()方法中定义的方法体</strong></p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public void start()</td>
<td align="center">方法</td>
<td align="center">使线程开始执行，不能重复启动同一个进程，会造成异常</td>
</tr>
</tbody></table>
<p>​    <strong>注意：所有线程的启动只能依靠Thread.start()方法</strong></p>
<p>​    范例：启动多线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread a = <span class="keyword">new</span> MyThread();</span><br><span class="line">		Thread b = <span class="keyword">new</span> MyThread();</span><br><span class="line">		Thread c = <span class="keyword">new</span> MyThread();</span><br><span class="line">		a.start();</span><br><span class="line">		b.start();</span><br><span class="line">		c.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span> ; i++)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;线程&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    所有线程对象交替执行run()方法中的内容</p>
<p>​    <strong>在start()方法里面调用了一个start0()方法，该方法没有方法体，但由关键字native来定义，此关键字的作用在于表示此操作交由底层实现</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IpeYNQ"><img src="https://z3.ax1x.com/2021/10/31/IpeYNQ.png" alt="IpeYNQ.png"></a></p>
<h5 id="2-实现Runnable接口实现多线程"><a href="#2-实现Runnable接口实现多线程" class="headerlink" title="2. 实现Runnable接口实现多线程"></a>2. 实现Runnable接口实现多线程</h5><p>​    可以通过java.lang.Runnable接口来实现多线程</p>
<table>
<thead>
<tr>
<th align="center">接口名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@FunctionalInterface public interface <strong>Runnable</strong></td>
<td align="center">函数式接口，里面可以使用nameda表达式</td>
</tr>
</tbody></table>
<p>​    在Runnable接口中只有唯一一个方法–run()方法，此方法作为线程主方法</p>
<p>​    **注意：之前Thread类中有提供start()方法启动线程，但是Runnable接口中不提供这个方法，此时需要Thread类提供的构造方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Thread(Runnable target)</span><br></pre></td></tr></table></figure>

<p>​    <strong>这个构造方法里面需要接收Runnable接口对象的实例（子类对象实例）</strong></p>
<p>​    范例：使用Runnable接口实现多线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread a = <span class="keyword">new</span> MyThread();</span><br><span class="line">		MyThread b = <span class="keyword">new</span> MyThread();</span><br><span class="line">		MyThread c = <span class="keyword">new</span> MyThread();</span><br><span class="line">		<span class="keyword">new</span> Thread(a).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(b).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(c).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span> ; i++)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;线程&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    使用Runnable接口实现可以避免单继承局限(在Java中一个类只能使用extends继承一个父类),更加适合项目编写</p>
<p>​    在JDK1.8之后Runnable成为了函数式接口,所以此时的代码可以使用Lambda进行定义</p>
<p>​    <strong>Lambda表达式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()-&gt;&#123;&#125;  &#x2F;&#x2F;()表输入参数,&#123;&#125;里面是表达式或者返回值</span><br></pre></td></tr></table></figure>

<p>​    范例：使用Lambda表达式修改Runnable接口程序实现多线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;个线程&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    此时Lambda表达式本质上还是Runnable接口的实例</p>
<p>​    <strong>Thread类与Runnable接口关系</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ICrjVP"><img src="https://z3.ax1x.com/2021/11/01/ICrjVP.png" alt="ICrjVP.png"></a></p>
<ol>
<li><p>为什么Thread接收Runnable接口对象之后，会去调用真实线程类中的run()方法呢？</p>
<p>因为当Runnable接口传递到Thread类中之后，会自动利用Thread类中的target属性保存Runnable的接口实例</p>
</li>
<li><p>观察Thread类中的run()方法（调用start()就调用Thread类中的run()方法）</p>
<p>Thread.run()方法定义的时候会判断是否有target实例，如果有此实例，则调用相应的run()方法</p>
</li>
</ol>
<p>​    <strong>多个线程并行操作同一个资源</strong></p>
<p>​    Runnable接口相比较Thread类更容易描述</p>
<p>​    范例：观察资源共享</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread a = <span class="keyword">new</span> MyThread();</span><br><span class="line">		<span class="keyword">new</span> Thread(a).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(a).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(a).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">30</span> ; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;票数&quot;</span>+ ticket--);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    代码理解图示</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IC5xIJ"><img src="https://z3.ax1x.com/2021/11/01/IC5xIJ.png" alt="IC5xIJ.png"></a></p>
<p>​    <strong>核心结论</strong></p>
<p>​    <strong>多线程的实现主要依靠Runnable来定义核心的业务处理功能，但是所有关于线程的控制都通过Thread类定义</strong></p>
<h5 id="3-Callable实现多线程"><a href="#3-Callable实现多线程" class="headerlink" title="3. Callable实现多线程"></a>3. Callable实现多线程</h5><p>​    Java多线程最初依靠Runnable接口来定义线程核心功能类，<strong>但是Runnable接口的run()方法没有返回值</strong></p>
<p>​    从JDk1.5开始，Java提供一个新的多线程实现接口：Callable，<strong>该接口定义在java.util.concurrent(JUC)，一共提供了三个JUC包</strong></p>
<p>​    </p>
<table>
<thead>
<tr>
<th align="center">接口名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@FunctionalInterface public interface Callable&lt; V &gt;</td>
<td align="center">(函数式接口)在java.util.concurrent包中提供的Callable接口</td>
</tr>
</tbody></table>
<p>​    Callable接口中提供的方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">V <strong>call()</strong> throws Exception</td>
<td align="center">方法</td>
<td align="center">描述线程的主体方法，与上面的run()方法相同但提供返回值</td>
</tr>
</tbody></table>
<p>​    使用call()方法定义线程主体，线程执行完毕后会将处理结果进行返回</p>
<p>​    范例：用callable定义线程核心业务类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">300</span> ; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;票数&quot;</span>+ ticket--);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;执行完成&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>Callable接口与Thread类的关系图</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IuYocT"><img src="https://z3.ax1x.com/2021/11/05/IuYocT.png" alt="IuYocT.png"></a></p>
<p>​    要充分理解这个关系，通过与Thread类相联系才可以用start()方法启动线程</p>
<p>​    范例：启动Callable的多线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xpath.internal.objects.XString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Callable&lt;String&gt; callA = <span class="keyword">new</span> MyThread();</span><br><span class="line">		Callable&lt;String&gt; callB = <span class="keyword">new</span> MyThread();</span><br><span class="line">		FutureTask&lt;String&gt; futurecallA = <span class="keyword">new</span> FutureTask&lt;String&gt;(callA);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(futurecallA).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(futurecallA).start();</span><br><span class="line">		System.out.println(futurecallA.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">30</span> ; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;票数&quot;</span>+ ticket--);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;执行完成&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    Callable和Runnable两个多线程接口的差别在于是否有返回值</p>
<p>​    <strong>多线程的几种状态</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IQEGtg"><img src="https://z3.ax1x.com/2021/11/06/IQEGtg.png" alt="IQEGtg.png"></a></p>
<p>​    </p>
<p>​    所有的系统的资源是有限的，不管多线程还是多进程都必须在执行一段时间之后让出资源，交由其他的线程继续执行</p>
<ol>
<li>创建过程：开发者定义好了相应的线程类对象(每一个Thread类的实例)</li>
<li>就绪状态：多线程的启动依靠的是start()方法，当调用start()方法的时候所有的线程不是立即执行，而是将进入到等待状态，等待CPU进行调度</li>
<li>执行状态：当CPU执行调度到了某个线程对象之后，该线程对象开始执行run()方法或call()方法，此时不是持续占用资源，而是在一段时间之后(一共时间片时间)，该线程就需要暂停执行</li>
<li>阻塞状态：当某个线程不再执行时(中断、休眠或调度失败)，那么所有的线程将进入到阻塞状态，如果此时线程没有执行完毕，则由阻塞状态切换到就绪状态，重新等待CPU执行调度</li>
<li>终止状态：如果多线程的执行体执行完毕或者被强制性的结束，那么就将进入到终止状态，终止状态不会再进入到就绪状态，即该线程对象将不会被继续执行</li>
</ol>
<h4 id="8-多线程操作方法-Thread类"><a href="#8-多线程操作方法-Thread类" class="headerlink" title="8. 多线程操作方法(Thread类)"></a>8. 多线程操作方法(Thread类)</h4><p>​    Thread类是实现线程的控制，所以除了有启动多线程的方法之外，也包含一些其他方法</p>
<h5 id="1-线程的命名与获取"><a href="#1-线程的命名与获取" class="headerlink" title="1. 线程的命名与获取"></a>1. 线程的命名与获取</h5><p>​     对于所有的线程对象而言，只能通过名称来进行线程的唯一标记</p>
<p>​    Thread类提供有方法实现线程名称的操作</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public Thread(Runnable target, String name)</td>
<td align="center">构造方法</td>
<td align="center">接收Runnable以及线程的名字</td>
</tr>
<tr>
<td align="center">public final void setName(String name)</td>
<td align="center">方法</td>
<td align="center">设置&amp;修改线程名字（一般不要去改）</td>
</tr>
<tr>
<td align="center">public final String getName()</td>
<td align="center">方法</td>
<td align="center">返回线程的名字</td>
</tr>
<tr>
<td align="center">public <strong>static</strong> Thread currentThread()</td>
<td align="center">方法</td>
<td align="center">返回对当前执行的线程对象的引用(因为线程不可控，你不知道执行到哪一个线程了)</td>
</tr>
</tbody></table>
<p>​    范例：线程名字的获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Thread th = <span class="keyword">new</span> MyThread();  <span class="comment">//等同于创造一个Runnable实例</span></span><br><span class="line">		<span class="keyword">new</span> Thread(th,<span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(th).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(th,<span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(th).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程运行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    注意：如果没有为线程设置名称，线程会自动生成线程名称</p>
<p>​    如果不使用start()启动run方法，而是直接类名.run()，<strong>此时是main()线程运行，即main方法本身就是一个线程，主线程</strong></p>
<p>​    当用户使用java命令解释一个类的时候，实际上会启动一共JVM的进程，<strong>即所有JVM程序运行时都会默认启动一个新的进程，所有的线程都是在这个进程产生的，该进程执行时默认启动一共主线程，又由主线程创建若干个子线程，所有线程并行执行</strong></p>
<h5 id="2-线程的休眠"><a href="#2-线程的休眠" class="headerlink" title="2. 线程的休眠"></a>2. 线程的休眠</h5><p>​    一般情况下线程对象只要启动了，那么就会持续的运行，一直到其运行完毕为止，<strong>如果想减慢线程的执行速度，就可以对其使用休眠处理</strong></p>
<p>​    Thread类中提供线程休眠操作的方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public <strong>static</strong> void sleep(long millis) throws InterruptedException</td>
<td align="center">方法</td>
<td align="center">休眠，单位毫秒</td>
</tr>
<tr>
<td align="center">public static void sleep(long millis, int nanos) throws InterruptedException</td>
<td align="center">方法</td>
<td align="center">休眠，单位毫秒，纳秒</td>
</tr>
</tbody></table>
<p>​    以第一个方法为主，<strong>sleep()方法为静态方法，静态调用即可</strong></p>
<p>​    <strong>InterruptedException为中断异常，所有的休眠都会有中断的问题</strong></p>
<h5 id="3-线程的中断"><a href="#3-线程的中断" class="headerlink" title="3. 线程的中断"></a>3. 线程的中断</h5><p>​    所有线程的执行都是可以被中断的</p>
<p>​    Thread类中提供有中断处理的方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public void interrupt()</td>
<td align="center">方法</td>
<td align="center">中断线程</td>
</tr>
<tr>
<td align="center">public boolean isInterrupted()</td>
<td align="center">方法</td>
<td align="center">判断线程的中断状态</td>
</tr>
</tbody></table>
<p>​    范例：线程中断处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Thread my = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName() +<span class="string">&quot;执行中&quot;</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">				System.out.println(<span class="string">&quot;线程执行完毕&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">				System.out.println(<span class="string">&quot;线程被中断&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		my.start();</span><br><span class="line">		Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;线程的是否中断&quot;</span>+my.isInterrupted());</span><br><span class="line">		my.interrupt();<span class="comment">//主线程打断my线程</span></span><br><span class="line">		System.out.println(<span class="string">&quot;线程的是否中断&quot;</span>+my.isInterrupted());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    <strong>线程中断的本质：一个线程被另外一个线程打断执行</strong></p>
<p>​    线程一旦被中断之后会引发中断异常</p>
<h5 id="4-线程的强制执行-强制让出资源"><a href="#4-线程的强制执行-强制让出资源" class="headerlink" title="4. 线程的强制执行(强制让出资源)"></a>4. 线程的强制执行(强制让出资源)</h5><p>​    当一个程序有若干个线程时，那么这若干个线程一定是交替执行的状态。但如果某个线程特别急，需要优先处理完成，则可以使用线程的强制执行</p>
<p>​    Thread类中提供了强制执行的方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public final void join() throws InterruptedException</td>
<td align="center">方法</td>
<td align="center">程序会等待调用join方法的线程运行完，再执行当前线程</td>
</tr>
<tr>
<td align="center">public final void join(long millis) throws InterruptedException</td>
<td align="center">方法</td>
<td align="center">程序会等待调用join方法的线程运行若干毫秒，再执行当前线程</td>
</tr>
<tr>
<td align="center">public final void join(long millis, int nanos) throws InterruptedException</td>
<td align="center">方法</td>
<td align="center">程序会等待调用join方法的线程运行若干毫秒以及纳秒，再执行当前线程</td>
</tr>
</tbody></table>
<p>​    范例：线程的强制执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Thread my = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (i == <span class="number">10</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.currentThread().join(); <span class="comment">//这里应当调主线程实例，让主线程先执行，而不是自己让自己执行</span></span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">&quot;执行，x =&quot;</span> + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		my.start();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;执行，x =&quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    <strong>注意：像这样自己让自己先执行的话，这个线程之间就不会继续运行了</strong></p>
<h5 id="5-线程的礼让"><a href="#5-线程的礼让" class="headerlink" title="5. 线程的礼让"></a>5. 线程的礼让</h5><p>​    礼让指让出当前执行操作，类似让座，多线程并行执行时，礼让一次其他线程让它优于礼让的线程先执行</p>
<p>​    Thread类中提供礼让操作的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public <strong>static</strong> void yield()</td>
<td align="center">方法</td>
<td align="center">让当前线程让出一次，让其他线程优先执行一次</td>
</tr>
</tbody></table>
<p>​    范例：线程的礼让</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Thread a = Thread.currentThread();</span><br><span class="line">		Thread my = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName()+<span class="string">&quot;礼让&quot;</span>);</span><br><span class="line">					Thread.yield();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">&quot;执行，x =&quot;</span> + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;子线程&quot;</span>);</span><br><span class="line">		my.start();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">100</span> ; j++)&#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;执行 , j =&quot;</span> + j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    <strong>注意：线程礼让不一定会成功，可能失败</strong></p>
<h5 id="6-线程的优先级"><a href="#6-线程的优先级" class="headerlink" title="6. 线程的优先级"></a>6. 线程的优先级</h5><p>​    理论上线程的优先级越高，越有<strong>可能先执行</strong></p>
<p>​    在Thread类中提供有优先级的操作方法：</p>
<table>
<thead>
<tr>
<th align="center">方法及常量</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public final void setPriority(int newPriority)</td>
<td align="center">方法</td>
<td align="center">设置优先级，int newPriority的范围为[MIN_PRIORITY ~ MAX_PRIORITY]</td>
</tr>
<tr>
<td align="center">public final int getPriority()</td>
<td align="center">方法</td>
<td align="center">获取当前线程优先级</td>
</tr>
<tr>
<td align="center">public static final int MIN_PRIORITY</td>
<td align="center">常量</td>
<td align="center">最低优先级（整型数值为1）</td>
</tr>
<tr>
<td align="center">public static final int NORM_PRIORITY</td>
<td align="center">常量</td>
<td align="center">中等优先级（整型数值为5）</td>
</tr>
<tr>
<td align="center">public static final int MAX_PRIORITY</td>
<td align="center">常量</td>
<td align="center">最高优先级（整型数值为10）</td>
</tr>
</tbody></table>
<p>​    范例：设置线程优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Thread my = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">&quot;执行 , x =&quot;</span> + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Thread a = <span class="keyword">new</span> Thread(my,<span class="string">&quot;线程A&quot;</span>);</span><br><span class="line">		Thread b = <span class="keyword">new</span> Thread(my,<span class="string">&quot;线程B&quot;</span>);</span><br><span class="line">		Thread c = <span class="keyword">new</span> Thread(my,<span class="string">&quot;线程C&quot;</span>);</span><br><span class="line"></span><br><span class="line">		a.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">		b.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">		c.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line"></span><br><span class="line">		a.start();</span><br><span class="line">		b.start();</span><br><span class="line">		c.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    <strong>注意：一般未设置优先级时，子线程优先级为NORM_PRIORITY，主线程优先级为NORM_PRIORITY</strong></p>
<h4 id="9-多线程的同步与死锁"><a href="#9-多线程的同步与死锁" class="headerlink" title="9. 多线程的同步与死锁"></a>9. 多线程的同步与死锁</h4><p>​    多线程的优势在于，可以使用多个并行的程序处理同一个操作业务，这样可以实现业务功能的快速处理，但是<strong>在进行多个线程并发资源访问的时候也会造成不同步的因素</strong></p>
<h5 id="1-同步问题引出"><a href="#1-同步问题引出" class="headerlink" title="1. 同步问题引出"></a>1. 同步问题引出</h5><p>​    设计一个多线程买票程序，一共一百张票，要五个线程进行售票处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TicketThread th = <span class="keyword">new</span> TicketThread();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(th,<span class="string">&quot;售票&quot;</span>+i).start();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">120</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">100</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖票，剩余票数为：&quot;</span>+ x--);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    会发现运行结果的问题</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IaYMUs"><img src="https://z3.ax1x.com/2021/11/10/IaYMUs.png" alt="IaYMUs.png"></a></p>
<p>​    这就是线程不同步</p>
<p>​    <strong>图示：</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/IaNHEQ"><img src="https://z3.ax1x.com/2021/11/10/IaNHEQ.png" alt="IaNHEQ.png"></a></p>
<p>​    <strong>注意：线程的休眠只是放大问题，不是问题的本因</strong></p>
<p>​    <strong><em>不同步问题核心的本质：多个线程并行执行操作</em></strong></p>
<h5 id="2-线程同步处理"><a href="#2-线程同步处理" class="headerlink" title="2. 线程同步处理"></a>2. 线程同步处理</h5><p>​    要解决上面的问题，需要使用同步，而<strong>同步就是指：多个操作在同一个时间段内只能有一个线程进行，其他线程要等待此线程完成之后才可以继续执行</strong></p>
<p>​    线程的同步处理通过<strong>synchronized</strong>关键字来实现</p>
<p>​    <strong>synchronized的使用有两种模式：同步代码块和同步方法</strong></p>
<ul>
<li><p>同步代码块</p>
<p>指使用synchronized关键字定义的代码块，在进行使用时<strong>必须要设置一个同步的对象</strong>，这个对象往往为当前资源的对象，<strong>可以使用this描述</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步对象)&#123;</span><br><span class="line">	<span class="comment">//所有的同步处理操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>范例：更改上面售票代码，实现同步处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TicketThread th = <span class="keyword">new</span> TicketThread();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(th,<span class="string">&quot;售票&quot;</span>+i).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">120</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span> (x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">100</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖票，剩余票数为：&quot;</span>+ x--);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用了同步代码块之后，所有的线程一个一个的执行，所以这个时候就解决了数据并发访问的安全问题，<strong>但是会带来执行性能过慢的性能问题</strong></p>
</li>
</ul>
<ul>
<li><p>同步方法</p>
<p>指的是使用了“synchronized”关键字定义的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值 方法名()&#123;</span><br><span class="line">	<span class="comment">//需要同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  <strong>注意：同步方法比同步代码块更常见</strong></p>
<h5 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3. 死锁"></a>3. 死锁</h5><p>​    <em>同步的本质：一个线程要等待其他线程执行完毕</em></p>
<p>​    <strong>synchronized关键字</strong></p>
<p>​    <strong>synchronized的作用域默认是当前对象，这时锁就是对象，谁拿到这个锁谁就可以运行它所控制的那段代码。如果这个对象有多个synchronized方法，其它线程就不能同时访问这个对象中任何一个synchronized方法</strong></p>
<p>​    在项目中，不正当的同步处理有可能造成死锁，<strong>即两个线程彼此相互等待</strong></p>
<pre><code>  范例：死锁的产生情况**（本身无意义）**</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span>  Play play = <span class="keyword">new</span> Play();</span><br><span class="line">	<span class="keyword">private</span>  Learn learn = <span class="keyword">new</span> Learn();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> First();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		play.said(learn);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">First</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">this</span>).start();</span><br><span class="line">		learn.said(play);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Play</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">said</span><span class="params">(Learn learn)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;玩完就学习&quot;</span>);</span><br><span class="line">		learn.get();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;学完了，这就去玩&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Learn</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">said</span><span class="params">(Play play)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;学完才能玩&quot;</span>);</span><br><span class="line">		play.get();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;玩完了，这就去学习&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在实际的项目中，死锁是通过大量的程序测试得出来的，上述代码只是死锁的表现，不具有真实开发意义</p>
<p>​    </p>


      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2021-11-11T06:25:01.000Z" itemprop="datePublished">
              2021-11-11
            </time>
          </div>
          
            <div>
              tags: 
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


            </div>
          
      </section>
    
    
</article>

  
</div>

            <footer>
    <div>© 2023 - nature </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>