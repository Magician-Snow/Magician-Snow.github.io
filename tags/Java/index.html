<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Blog of ChiFun</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(/assets/blog.png)">
        </div>
    </section>
    <section class='menu'>
        <div>Blog of ChiFun</div>
        
            <div>Updated every 5 days</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>  
          
            <a href="/about/" class="Btn">
              <li>About</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
            
                <a target="_blank" rel="noopener" href="https://github.com/Magician-Snow">
                    <img src="/assets/github.svg" />
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
    <header class='PageTitle'>
        <h1>{ Java }</h1>
    </header>
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/10/25/Java14/">Java14</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-10-25T11:25:55.000Z" itemprop="datePublished">
    2021-10-25
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h4 id="1-泛型是在JDK1-5之后主要引入的一项技术，其主要的目的是为了解决类对象的安全隐患问题"><a href="#1-泛型是在JDK1-5之后主要引入的一项技术，其主要的目的是为了解决类对象的安全隐患问题" class="headerlink" title="1. 泛型是在JDK1.5之后主要引入的一项技术，其主要的目的是为了解决类对象的安全隐患问题"></a>1. 泛型是在JDK1.5之后主要引入的一项技术，其主要的目的是为了解决类对象的安全隐患问题</h4><h4 id="2-泛型问题的引出"><a href="#2-泛型问题的引出" class="headerlink" title="2. 泛型问题的引出"></a>2. 泛型问题的引出</h4><p>​    在Java中，最方便的参数统一使用Object类型，但是并不是意味所有的Object都可以解决实际问题</p>
<p>​    现在假设需要一个描述坐标点的信息类(Point)，该类中可以保存三种坐标类型</p>
<ul>
<li><p>保存整型</p>
</li>
<li><p>保存浮点型</p>
</li>
<li><p>保存字符串</p>
</li>
</ul>
<p>​    此时，要保证三类数据的保存，只有通过Object类型可以解决</p>
<p>​    <strong>Point类的设计</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object x;</span><br><span class="line">	<span class="keyword">private</span> Object y;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(Object x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.x = x;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(Object y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在使用这个类时，需要进行向上转型输入和向下转型输出。但是，由于Object所能描述的范围太广泛了，所以<strong>可能传入了字符串类型任何转型时不小心转为了int(其他)类型</strong>，此时代码在<strong>编译时可以通过，执行时出现”ClassCastException“异常</strong>，<strong>由此可以看出Object提供的解决方案实际上会存在安全隐患</strong>，所以Object类作为参数是项目中最大的败笔</p>
<h4 id="3-泛型基本定义"><a href="#3-泛型基本定义" class="headerlink" title="3. 泛型基本定义"></a>3. 泛型基本定义</h4><p>​    通过分析Object作为参数的优缺点，<strong>要想解决对象转型安全隐患问题，最简单的方式就是不转型</strong><br>​    JDk1.5后提供了泛型的概念，泛型&lt; T &gt;最大的特点为，类中的属性类型或方法的参数，可以在类的使用时，动态决定<br>​    <strong>范例：修改Point类的设计</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="comment">//T表示Type的意思，不一定要T写其他的也可以</span></span><br><span class="line">	<span class="keyword">private</span> T x;</span><br><span class="line">	<span class="keyword">private</span> T y;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.x = x;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(T y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在Point类上定义的泛型T实际上只是一个随机设置的名称，表示的是，该类型由使用的时候来决定，<strong>泛型使用时只能使用引用数据类型，不能使用基本类型</strong></p>
<p>​    范例：使用泛型声明的类Point</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		Point&lt;Integer&gt; a &#x3D; new Point&lt;Integer&gt;();</span><br><span class="line">		a.setX(10);</span><br><span class="line">		a.setY(20);</span><br><span class="line">		System.out.println(&quot;x &#x3D; &quot;+a.getX()+ &quot;,y &#x3D; &quot;+a.getY());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​    注意：使用泛型后，所有程序之中具有泛型标记的部分都会更换为相应的类型标记，这个标记在类对象实例化的时候进行动态的配置，此时就不需要转型了，而且编译时会帮助检测错误</p>
<p>​    <strong>注意：如果使用了泛型设计类但是使用这个类并没有给泛型，那么会把泛型中所有的T变成Object类型，Object的使用就需要转型了</strong></p>
<h4 id="4-泛型通配符"><a href="#4-泛型通配符" class="headerlink" title="4. 泛型通配符"></a>4. 泛型通配符</h4><p>​    泛型的出现解决了数据类型的转换安全问题，但是随之而来也会带来引用传递的麻烦。<strong>为解决该问题则用通配符对形参进行约束</strong></p>
<p>​    范例：泛型的引用传递</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">class Message&lt;T&gt;&#123;</span><br><span class="line">	private T info;</span><br><span class="line">	public void setMessage(T info) &#123;</span><br><span class="line">		this.info &#x3D; info;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public T getMessage() &#123;</span><br><span class="line">		return this.info;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class First&#123;</span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		Message&lt;String&gt; msg &#x3D; new Message&lt;String&gt;();</span><br><span class="line">		msg.setMessage(&quot;篮球&quot;);</span><br><span class="line">		print(msg);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void print(Message&lt;String&gt; msg) &#123;</span><br><span class="line">		System.out.println(msg.getMessage());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>注意：</strong></p>
<ol>
<li>泛型作为形参不可以作为重载标识，重载的参数类型名以类名作为标识与泛型无关</li>
<li>泛型在作为形参时需要注明泛型的类型</li>
<li>如果没有声明泛型类型，传过来则使用Object类型来代替未设置的泛型标记，也就说传过来后的泛型可以设置成任意类型</li>
</ol>
<p>​    <em>为了解决3这个问题，泛型里提供了通配符”?“</em><br>​    使用通配符”?“会限制程序不可以修改传过来的对象，此时对象仍然为object类型(可以描述一切的泛型类型)，但无法进行修改(取和改)</p>
<p>​    在通配符?的基础之上，又产生了两个通配符的应用：</p>
<ul>
<li>设置泛型的下限：? super类;<br>​    例如：”? super String“，表示可以设置的泛型类只能够是String以及其父类(Object)</li>
<li>设置泛型的上限：? extands 类;<br>​    例如：”? extends Number“：表示所设置的泛型类型只能够是Number或者其子类<br>​    <strong>注意：泛型的上限可以对类进行修饰(类&lt; T extends 类(界限)&gt;)</strong></li>
</ul>
<h4 id="5-泛型接口"><a href="#5-泛型接口" class="headerlink" title="5. 泛型接口"></a>5. 泛型接口</h4><p>​    泛型也可以应用在接口上，此类接口称为泛型接口</p>
<p>​    泛型接口的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IMessage&lt;T&gt;&#123;</span><br><span class="line">	public void send(T content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    所有的接口在使用的时候都必须依靠子类，那么在此时子类有两种实现泛型接口的方式</p>
<ul>
<li>方式一：在子类中继续指定泛型标记<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(T content)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IMessage</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(T content)</span> </span>&#123;</span><br><span class="line">		System.out.println(content);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		IMessage&lt;String&gt; a = <span class="keyword">new</span> MessageImpl&lt;String&gt;();<span class="comment">//后面的String可以省略，尖括号还是需要</span></span><br><span class="line">		a.send(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>​    上面代码的注释中，在JDK1.8出现了一个自动推导泛型的概念，因为每一次前后都需要编写泛型类型，过于复杂，所以现在前面定义了泛型类型，那么后面就可以不需要重复定义了</p>
<ul>
<li>方式二：子类不再设置泛型类型，而为父类指派好类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">interface IMessage&lt;T&gt;&#123;</span><br><span class="line">	public void send(T content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MessageImpl implements IMessage&lt;String&gt;&#123;</span><br><span class="line">	public void send(String content) &#123;</span><br><span class="line">		 System.out.println(content);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class First&#123;</span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		IMessage&lt;String&gt; a &#x3D; new MessageImpl();</span><br><span class="line">		a.send(&quot;hello&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-泛型方法"><a href="#6-泛型方法" class="headerlink" title="6. 泛型方法"></a>6. 泛型方法</h4><p>​    所有泛型方法不一定非要定义在泛型的类或泛型接口之中，这也就是说任意一个方法都可以定义为泛型方法，但是需要对泛型标记（&lt;  T &gt;）加以声明</p>
<p>​    范例：定义泛型方法<br>​    此时对于传入的参数类型就由调用方法的语句来外部定义了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] init(T ... args)&#123; <span class="comment">//T[]表示T类型数组</span></span><br><span class="line"><span class="keyword">return</span> args; <span class="comment">//返回是类对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    知道一个方法如何去定义一个泛型就行了</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/10/24/Java13/">Java13</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-10-24T05:56:24.000Z" itemprop="datePublished">
    2021-10-24
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="反射-Class-lt-gt"><a href="#反射-Class-lt-gt" class="headerlink" title="反射(Class&lt; ? &gt;)"></a>反射(Class&lt; ? &gt;)</h2><h4 id="1-Java的反射机制"><a href="#1-Java的反射机制" class="headerlink" title="1. Java的反射机制"></a>1. Java的反射机制</h4><p>​    Java语言最为重要的特性之一就是反射机制的存在，这个机制使得Java设计更加的灵活<br>​    要写出高复用的代码就要去学习Java反射，几乎所有的Java开发框架都为Java的反射应用</p>
<h4 id="2-反射的“反”"><a href="#2-反射的“反”" class="headerlink" title="2. 反射的“反”"></a>2. 反射的“反”</h4><p>​    在常规的做法是明确知道一个类之后，导入此类随后进行对象实例化处理，但反射可以依据实例化对象找到其根源。</p>
<h4 id="3-Object类中的getClass-方法"><a href="#3-Object类中的getClass-方法" class="headerlink" title="3. Object类中的getClass()方法"></a>3. Object类中的getClass()方法</h4><table>
<thead>
<tr>
<th>public final Class&lt;?&gt;  getClass()</th>
</tr>
</thead>
<tbody><tr>
<td>获得该类型详细描述。Class&lt;?&gt;的意思为记录了该类的一切信息</td>
</tr>
</tbody></table>
<p>​    <strong>注意：该方法不能被重写</strong></p>
<h4 id="4-反射的根源是Class类，Java对实例化的操作提供三类支持，实际项目都是混用都重要"><a href="#4-反射的根源是Class类，Java对实例化的操作提供三类支持，实际项目都是混用都重要" class="headerlink" title="4. 反射的根源是Class类，Java对实例化的操作提供三类支持，实际项目都是混用都重要"></a>4. 反射的根源是Class类，Java对实例化的操作提供三类支持，实际项目都是混用都重要</h4><ol>
<li>利用Object类中提供的getClass()方法，通过实例化调用获得</li>
<li>利用“类.class”的Java原生代码操作实现<br>示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clsA &#x3D; java.util.Date.class  &#x2F;&#x2F;这个类必须存在</span><br></pre></td></tr></table></figure></li>
<li>利用Class类中提供的forName()方法进行实例化<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public <strong>static</strong> Class&lt; ? &gt; forName(String className) <strong>throws ClassNotFoundException</strong></td>
<td align="center">此类方法需要将加载反射类型的名称进行定义(通过字符串描述要使用类的名称)，而且定义的时候要求使用类的完整名称“包.类”，如果该类不存在则会出现”ClassNotFoundException”，也就意味着要进行加载的类一定要放在CLASSPATH可以识别</td>
</tr>
</tbody></table>
</li>
</ol>
<p>​    示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clsA &#x3D; Class.forName(&quot;java.util.Date&quot;) &#x2F;&#x2F;需要包.类</span><br></pre></td></tr></table></figure>
<p>这个与第二个的区别是第二个必须要类存在,这个写错的话会报异常</p>
<p>​    <strong>总结：三种形式获取Class类实例的特点</strong></p>
<ul>
<li>**getClass()**：需要明确的获得使用类的实例化对象；</li>
<li><strong>类.class</strong>：需要明确的进行操作类的导入处理；</li>
<li>**Class.forName()**：可以通过字符串描述要使用类的名称(最灵活的)</li>
</ul>
<p>​    <strong>注意：反射可以用来代替“new”操作符进行实例化对象，但其操作和“new”关键字一样受到类的构造方法的约束，如果类构造方法为private，在类外它一样不可以实例化对象</strong></p>
<h4 id="5-反射应用案例"><a href="#5-反射应用案例" class="headerlink" title="5. 反射应用案例"></a>5. 反射应用案例</h4><h5 id="1-反射对象实例化"><a href="#1-反射对象实例化" class="headerlink" title="1. 反射对象实例化"></a>1. 反射对象实例化</h5><p>​    获取Class类对象之后最大用处在于可以直接利用反射提供的方法调用指定类的构造实现对象的实例化，此操作的方法为：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public <strong>T</strong> newInstance() <strong>throws InstantiationException, IllegalAccessException</strong></td>
<td align="center">反射实例化对象，<strong>T表示返回值为Object类型</strong></td>
</tr>
</tbody></table>
<p>注意：由于反射定义中的泛型比较尴尬所以出现“?”居多，“?”的返回为Object</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;clazz表示class的实例化对象</span><br><span class="line">Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;java.util.Date&quot;);</span><br><span class="line">Object obj &#x3D; clazz.newInstance(); &#x2F;&#x2F;反射实例化对象，相当于表示“new java.util.Date()”</span><br></pre></td></tr></table></figure>

<p><strong>注意：上面代码反射为Object类型，如果要使用Date类的对象需要对obj进行向下转型，若只是需要对象则可以直接使用obj</strong></p>
<h5 id="2-反射与工厂设计模式"><a href="#2-反射与工厂设计模式" class="headerlink" title="2. 反射与工厂设计模式"></a>2. 反射与工厂设计模式</h5><p>​    工厂设计模式常用来获取接口实例，属于java面向对象编程的基本模型<br>​    使用工厂模式，在使用new操作符时，也叫做静态工厂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class factory&#123;</span><br><span class="line">	private factory() &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	public static Message getMessage(String className) &#123;</span><br><span class="line">		if(&quot;PaperMessage&quot;.equals(className)) &#123;</span><br><span class="line">			return new PaperMessage();</span><br><span class="line">		&#125;else if(&quot;InternalMessage&quot;.equals(className)) &#123;</span><br><span class="line">			return new InternalMessage();</span><br><span class="line">		&#125;else</span><br><span class="line">			return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>详细完整代码见反射实例例一</strong></p>
<p>​    <strong>静态工厂类的缺点</strong><br>​    当你要添加或者删除接口子类很多时，传统的静态工厂类将无法满足需要，问题产生的原因是关键字“new”，关键字“new”是Java提供的原生对象实例化支持，但需要使用特定的结构使用，一个好的代码new使用的少，所以此时需要使用反射机制来解决</p>
<p>​    <strong>反射机制的思路</strong><br><a target="_blank" rel="noopener" href="https://imgtu.com/i/5ZJDt1"><img src="https://z3.ax1x.com/2021/10/11/5ZJDt1.png" alt="5ZJDt1.png"></a></p>
<p>​     用反射机制修改工厂类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class factory&#123;</span><br><span class="line">	private factory() &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	public static Message getMessage(String className) &#123; </span><br><span class="line">		Message msg &#x3D; null;</span><br><span class="line">		try &#123;</span><br><span class="line">			msg &#x3D; (Message)Class.forName(className).getDeclaredConstructor().newInstance();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		return msg;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>注意：此时由于调用Class.forname()所以方法传字符串(className)必须是完整路径，包+类名</strong></p>
<p>​    <strong>详细完整代码见反射实例例二</strong></p>
<p>​    此时添加子类时就不需要去修改工厂类了</p>
<h5 id="3-反射与单例设计模式"><a href="#3-反射与单例设计模式" class="headerlink" title="3. 反射与单例设计模式"></a>3. 反射与单例设计模式</h5><p>​    单例设计模式的核心：一个类在一个JVM进程之中只允许有一个实例化对象</p>
<p>​    单例设计模式的两种结构：饿汉式单例、懒汉式单例（问题比较麻烦，但找工作用这个可以使得问题表述的更加清晰）</p>
<p>​    懒汉式就是创建对象时比较懒，先不急着创建对象，在需要加载配置文件的时候再去创建。饿汉式就是在系统初始化的时候我们已经把对象创建好了，需要用的时候直接拿过来用就好了</p>
<ul>
<li><p>设计饿汉式单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class SingletonEH &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     *是否 Lazy 初始化：否</span><br><span class="line">     *是否多线程安全：是</span><br><span class="line">     *实现难度：易</span><br><span class="line">     *描述：这种方式比较常用，但容易产生垃圾对象。</span><br><span class="line">     *优点：没有加锁，执行效率会提高。</span><br><span class="line">     *缺点：类加载时就初始化，浪费内存。</span><br><span class="line">     *它基于 classloder 机制避免了多线程的同步问题，</span><br><span class="line">     * 不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，</span><br><span class="line">     * 在单例模式中大多数都是调用 getInstance 方法，</span><br><span class="line">     * 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，</span><br><span class="line">     * 这时候初始化 instance 显然没有达到 lazy loading 的效果。</span><br><span class="line">     * 饿汉就是类一旦加载（ java文件通过编译器变成了.class文件），就把单例初始化完成，保证getInstance的时候，单例是已经存在的了</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static SingletonEH instance &#x3D; new SingletonEH();</span><br><span class="line">    private SingletonEH ()&#123;&#125;</span><br><span class="line">    public static SingletonEH getInstance() &#123;</span><br><span class="line">        System.out.println(&quot;instance:&quot;+instance);</span><br><span class="line">        System.out.println(&quot;加载饿汉式....&quot;);</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设计懒汉式单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">     *是否 Lazy 初始化：是</span><br><span class="line">     *是否多线程安全：否</span><br><span class="line">     *实现难度：易</span><br><span class="line">     *描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</span><br><span class="line">     *这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</span><br><span class="line">	*&#x2F;</span><br><span class="line">	&#x2F;&#x2F;设置单例，保证只有一个单例</span><br><span class="line">	private static Singleton instance;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;私有化构造方法，使之只能在内部调用实例化</span><br><span class="line">	private Singleton()&#123;</span><br><span class="line">		System.out.println(&quot;hello&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;通过公有化方法提供对外部的接口</span><br><span class="line">	public static Singleton getInstance() &#123;</span><br><span class="line">		if(instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">			instance &#x3D; new Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>​    但是一旦使用多线程，并且结合懒汉式设计时会出现对象的多次实例化<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/5mOrjJ"><img src="https://z3.ax1x.com/2021/10/12/5mOrjJ.png" alt="5mOrjJ.png"></a></p>
<p>​    需要解决问题需要增加同步处理<br>​    <strong>同步是否添加的因素：如果读取不要加同步，如果更新要加同步</strong><br>​    如果直接在方法外增加同步，线程若有10w个线程获取Singleton类的对象，则这10w个线程排队等待，性能会下降<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/5mxlan"><img src="https://z3.ax1x.com/2021/10/12/5mxlan.png" alt="5mxlan.png"></a></p>
<p>​    所以应该在方法内增加同步，而同步内用的对象的获取则使用反射机制</p>
<p>​    <strong>解决代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;此时即保证了getInstance()方法的操作性能，同时又保护了Singleton类对象的实例化次数</span><br><span class="line">class Singleton&#123;</span><br><span class="line">	private static Singleton instance;</span><br><span class="line">	</span><br><span class="line">	private Singleton()&#123;</span><br><span class="line">		System.out.println(&quot;hello&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static Singleton getInstance() &#123;</span><br><span class="line">		if(instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">			synchronized(Singleton.class) &#123;</span><br><span class="line">				if(instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">					instance &#x3D; new Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>代码解释图示</strong><br><a target="_blank" rel="noopener" href="https://imgtu.com/i/5nSyuD"><img src="https://z3.ax1x.com/2021/10/12/5nSyuD.png" alt="5nSyuD.png"></a></p>
<h4 id="6-反射与类操作"><a href="#6-反射与类操作" class="headerlink" title="6. 反射与类操作"></a>6. 反射与类操作</h4><p>​    反射可以完整的实现Java允许规定的类的操作形式<br>​    传统的Java二进制文件对其进行操作就是进行类加载(import、CLASSPATH)；实例化类对象并操作，<strong>对于这些二进制文件的分析(Java中允许你做到的)就是反射</strong>，如果要对这个文件进行更深入的分析，需要使用第三方工具包</p>
<h5 id="1-反射获取类结构"><a href="#1-反射获取类结构" class="headerlink" title="1. 反射获取类结构"></a>1. 反射获取类结构</h5><p>​    class作为所有反射操作的源头，于是在Class类里面就可以获取clazz的一些结构上的信息，例如：类所在的包、类所继承的父类、已经类所实现的相关的接口，方法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public Package getPackage()</td>
<td align="center">方法</td>
<td align="center">获取程序所在的包名称</td>
</tr>
<tr>
<td align="center">public <strong>Class</strong>&lt; ? super T&gt; getSuperclass()</td>
<td align="center">方法</td>
<td align="center">获取所继承的父类</td>
</tr>
<tr>
<td align="center">public Class&lt; ? &gt;[] getInterfaces()</td>
<td align="center">方法</td>
<td align="center">获取所有的父接口</td>
</tr>
</tbody></table>
<p>​    之所以通过反射可以获取这些信息，主要是由于Class类拥有了“*.class”二进制数据的分析能力，它实际上是根据二进制的结构文件动态获取的内容。</p>
<p>​    <strong>详细代码见反射实例例三</strong></p>
<h5 id="2-反射调用构造方法"><a href="#2-反射调用构造方法" class="headerlink" title="2. 反射调用构造方法"></a>2. 反射调用构造方法</h5><p>​    所有的构造方法都可以利用反射来进行获取，在Class类中定义如下构造方法获取的操作</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public Constructor&lt; T &gt; getConstructor(Class&lt; ? &gt;… parameterTypes) throws NoSuchMethodException, SecurityException</td>
<td align="center">方法</td>
<td align="center">根据指定的参数类型获取指定 的构造方法(Public)</td>
</tr>
<tr>
<td align="center">public Constructor&lt; ? &gt;[] getConstructors()                                 throws SecurityException</td>
<td align="center">方法</td>
<td align="center">获取类中所有的构造方法(public)</td>
</tr>
<tr>
<td align="center">public Constructor&lt; T &gt; get<strong>Declared</strong>Constructor(Class)&lt; ? &gt;… parameterTypes)                                      throws NoSuchMethodException, SecurityException</td>
<td align="center">方法</td>
<td align="center">获取一个类中指定的构造方法(public、protected、default)</td>
</tr>
<tr>
<td align="center">public Constructor&lt; ? &gt;[] get<strong>Declared</strong>Constructors() throws SecurityException</td>
<td align="center">方法</td>
<td align="center">获取一个类中的全部构造方法(public、protected、default)</td>
</tr>
</tbody></table>
<p>​    在Java中好用的方法为后两个，因为构造方法不一定只使用public来定义，所以获取的方法应该采用“getDeclaredConstructor”</p>
<p>​    <strong>获取构造并不意味着要进行简单的输出，这种获取信息的操作只在开发工具中比较常见，但是获取Constructor最大的意义在于其可以进行反射构造调用，提供有如下方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public T <strong>newInstance(Object… initargs)</strong> throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException</td>
<td align="center">方法</td>
<td align="center">调用指定的构造进行对象实例化处理</td>
</tr>
</tbody></table>
<p>​    范例：利用反射调用指定参数的构造进行实例化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">class Ball&#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private double price;</span><br><span class="line">	</span><br><span class="line">	public Ball(String name,double price) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.price &#x3D; price;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void print() &#123;</span><br><span class="line">		System.out.println(&quot;球的名字为：&quot;+this.name+&quot;、价格为：&quot; + this.price);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class First&#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException&#123;</span><br><span class="line">		Class&lt;?&gt; clazz &#x3D; Ball.class;&#x2F;&#x2F;获取反射对象</span><br><span class="line">		Constructor&lt;?&gt; con &#x3D; clazz.getDeclaredConstructor(String.class,double.class);</span><br><span class="line">		Ball ball &#x3D; (Ball)con.newInstance(&quot;足球&quot;,12.5);</span><br><span class="line">		ball.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    以上操作是JDK1.9之后官方推荐的做法，在JDK1.8及以前的版本里面，关于反射对象的实例化操作实际上提供了两个不同的方法</p>
<ul>
<li><p><strong>Class类：</strong>@Deprecated(since)=”9”) public T newInstance() throws InstantiationException, IllegalAccessException</p>
<p>-默认调用无参构造，如果类中，没有无参构造则将抛出异常；JDK1.9之后就修改为Constructor类调用；</p>
</li>
<li><p><strong>Constructor类：</strong>public T newInstance() throws InstantiationException, IllegalAccessException</p>
</li>
</ul>
<h5 id="3-反射调用方法"><a href="#3-反射调用方法" class="headerlink" title="3. 反射调用方法"></a>3. 反射调用方法</h5><p>​    在class类中定义了可以获取类中方法实例的操作</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public Method[] <strong>getMethods()</strong> throws SecurityException</td>
<td align="center">方法</td>
<td align="center">获取本类和父类中所有的public方法</td>
</tr>
<tr>
<td align="center">public Method getMethod(String name, Class&lt; ? &gt;… parameterTypes) throws NoSuchMethodException, SecurityException</td>
<td align="center">方法</td>
<td align="center">获取一个public的方法，包括父类的方法</td>
</tr>
<tr>
<td align="center">public Method[] <strong>getDeclaredMethods()</strong> throws SecurityException</td>
<td align="center">方法</td>
<td align="center">获取本类中所有的方法</td>
</tr>
<tr>
<td align="center">public Method getDeclaredMethod(<strong>String name</strong>, <strong>Class&lt; ? &gt;… parameterTypes</strong>) throws NoSuchMethodException, SecurityException</td>
<td align="center">方法</td>
<td align="center">获取本类一个指定类型的Method实例；String name表示方法名称，Class&lt; ? &gt;… parameterTypes表示我要操作的参数类型</td>
</tr>
</tbody></table>
<p>​    当获取了一个方法之后将以Method类的实例进行该方法的描述，Method类的定义方式如下：</p>
<p>​    <strong>Method类的定义</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final class Method extends Executable</span><br></pre></td></tr></table></figure>
<p>​    这个类的定义方式和之前Constructor类是完全一样的</p>
<p>​    图示：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/5w4OD1"><img src="https://z3.ax1x.com/2021/10/19/5w4OD1.png" alt="5w4OD1.png"></a> </p>
<p>​    在Java里面可以利用Method明确的描述一个可以调用的方法结构，可以利用Method实现类中全部方法的输出</p>
<p>​    范例：获取Ball类中所有的public方法,包括所有父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Balls</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toDo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> <span class="keyword">extends</span> <span class="title">Balls</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException</span>&#123;</span><br><span class="line">		Class&lt;?&gt; clazz = Ball.class;</span><br><span class="line">		Method method[] = clazz.getMethods();</span><br><span class="line">		<span class="keyword">for</span>(Method x:method) &#123;</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    获取method实例后对<strong>该方法</strong>信息获得的方法<strong>（Method类或者其父类（Executable）下的方法）</strong>：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public String getName()</td>
<td align="center">方法</td>
<td align="center">获取方法的名字</td>
</tr>
<tr>
<td align="center">public abstract int getModifiers()</td>
<td align="center">方法</td>
<td align="center">获取方法前的权限修饰符</td>
</tr>
<tr>
<td align="center">public Class&lt; ? &gt; getReturnType()</td>
<td align="center">方法</td>
<td align="center">获取方法的返回值</td>
</tr>
<tr>
<td align="center">public abstract Class&lt; ? &gt;[] getParameterTypes()</td>
<td align="center">方法</td>
<td align="center">获取方法的所有参数,返回值为数组</td>
</tr>
<tr>
<td align="center">public Class&lt; ? &gt;[] getExceptionTypes()</td>
<td align="center"></td>
<td align="center">获取方法的所有异常</td>
</tr>
</tbody></table>
<p>​    <strong>注意：getModifiers()方法的返回值为int类型，因为所有的权限都是数字的组合(相加)，在java.lang.reflect.Modifier类中有static String toString(int mod)方法，将这些数字反推权限修饰符的字符串</strong></p>
<p>​    程序配置了任何的第三方工具包,各个开发工具之所以可以进行代码的检测以及方法的获取,就是由于反射机制的支持(二进制数据流的解析处理),但是对于我们开发人员来讲**,真正有意义的代码在于Method类中提供的反射调用方法(非常重要,使用Method类中最有意义的操作)**:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object obj,Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException</span><br></pre></td></tr></table></figure>

<p>​    <strong>invoke()可以直接依据Object类的实例化对象(不一定是具体类型)实现反射方法调用</strong></p>
<p>​    注意：所有的简单Java类一定要提供有无参构造方法,同时所有的属性必须封装(private),封装后的属性必须编写setter、getter方法</p>
<p>​    <strong>范例：利用反射调用setter、getter方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;hello.Ball&quot;</span>);</span><br><span class="line">		Object obj = clazz.getDeclaredConstructor().newInstance(); <span class="comment">//实例化对象</span></span><br><span class="line">		Method setmethod = clazz.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class); <span class="comment">//参数类型暂时无法动态获取，先固定一个String.class</span></span><br><span class="line">		setmethod.invoke(obj, <span class="string">&quot;篮球&quot;</span>); <span class="comment">//等价于“实例化对象.setName(&quot;篮球&quot;)”</span></span><br><span class="line">		Method getmethod = clazz.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">		Object a = getmethod.invoke(obj);</span><br><span class="line">		System.out.println(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    此时程序实现了方法的反射调用，同时也解释了为什么简单Java类中的命名要有setter、getter规则</p>
<h5 id="4-反射调用成员属性"><a href="#4-反射调用成员属性" class="headerlink" title="4. 反射调用成员属性"></a>4. 反射调用成员属性</h5><p>​    类结构里面包含的三个组成：构造、方法、成员属性，那么对于所有的成员属性也是可以通过反射来实现调用，在class类中提供有如下的与成员有关的操作方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public Field[] getFields() throws SecurityException</td>
<td align="center">方法</td>
<td align="center">获取所有继承来的public成员</td>
</tr>
<tr>
<td align="center">public Field getField(String name) throws NoSuchFieldException, SecurityException</td>
<td align="center">方法</td>
<td align="center">获取一个指定类型的成员</td>
</tr>
<tr>
<td align="center">public Field[] getDeclaredFields() throws SecurityException</td>
<td align="center">方法</td>
<td align="center">获取本类定义的全部的成员</td>
</tr>
<tr>
<td align="center">public Field getDeclaredField(String name) throws NoSuchFieldException, SecurityException</td>
<td align="center">方法</td>
<td align="center">获取一个本类定义成员</td>
</tr>
</tbody></table>
<p>​    代码：获取属性信息，见反射实例-例四</p>
<p>​    在代码中获取了所需要的成员的信息，但是Field类的使用并不是获取成员信息的，这个类有如下几个重要的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>public Class&lt; ? &gt; getType()</strong></td>
<td align="center">方法</td>
<td align="center">获取属性类型，可以与上上面代码中(invoke())结合动态获取参数类型</td>
</tr>
<tr>
<td align="center">public Object get(Object obj) throws IllegalArgumentException, IllegalAccessException</td>
<td align="center">方法</td>
<td align="center">获取对象属性</td>
</tr>
<tr>
<td align="center">public void set(Object obj, Object value) throws IllegalArgumentException, IllegalAccessException</td>
<td align="center">方法</td>
<td align="center">设置属性内容</td>
</tr>
<tr>
<td align="center"><strong>public void setAccessible(boolean flag)</strong></td>
<td align="center">方法</td>
<td align="center">取消封装(private)，即设置可见</td>
</tr>
</tbody></table>
<p>​    <strong>图示：field类的继承图示以及setAccessible(boolean flag)方法的作用区间</strong></p>
<p>​    <a target="_blank" rel="noopener" href="https://imgtu.com/i/5DuKSI"><img src="https://z3.ax1x.com/2021/10/20/5DuKSI.png" alt="5DuKSI.png"></a></p>
<p>​    <strong>注意：setAccessible(boolean flag)方法是在AccessibleObject类中定义的方法，所以下面继承此类的方法都可以进行调用，从而解除封装</strong></p>
<p>​    范例：调用类中的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Class&lt;?&gt; clazz = Ball.class;</span><br><span class="line">		Object obj = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">		Field field = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">		field.setAccessible(<span class="keyword">true</span>); <span class="comment">//解除封装</span></span><br><span class="line">		field.set(obj, <span class="string">&quot;篮球&quot;</span>); <span class="comment">//等价于&quot;对象.name = &quot;篮球&quot;&quot;</span></span><br><span class="line">		System.out.println(field.get(obj)); <span class="comment">//等价于&quot;System.out.println(对象.name)&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>注意：类中所谓的封装只是局限于标准语法的访问的限制，但是如果直接利用反射就可以打破这种封装所带来的影响，只不过大多数情况不会这样操作</strong></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/09/19/Java12/">Java12</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-09-19T08:19:54.000Z" itemprop="datePublished">
    2021-09-19
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="I-O（Input-amp-Output）"><a href="#I-O（Input-amp-Output）" class="headerlink" title="I/O（Input&amp;Output）"></a>I/O（Input&amp;Output）</h2><h3 id="1-Java中的输入-输出流"><a href="#1-Java中的输入-输出流" class="headerlink" title="1. Java中的输入/输出流"></a>1. Java中的输入/输出流</h3><p>​    Java语言定义了许多类负责各种方式的输入/输出，java的io是所有语言之最，这些类都放在java.io包中。<strong>核心组成：一个类(File)、一个接口(Serializable)、四个抽象类(InputStream，OutputStream，Reader，Writer)</strong></p>
<h3 id="2-File类的简介"><a href="#2-File类的简介" class="headerlink" title="2. File类的简介"></a>2. File类的简介</h3><h4 id="1-File类是整个java-io包中唯一一个与文件本身有关-可以进行操作文档的路径指派，可以创建或者删除文件，以及还可以获取文件的相关信息内容-的操作类"><a href="#1-File类是整个java-io包中唯一一个与文件本身有关-可以进行操作文档的路径指派，可以创建或者删除文件，以及还可以获取文件的相关信息内容-的操作类" class="headerlink" title="(1).File类是整个java.io包中唯一一个与文件本身有关(可以进行操作文档的路径指派，可以创建或者删除文件，以及还可以获取文件的相关信息内容)的操作类"></a>(1).File类是整个java.io包中唯一一个<strong>与文件本身有关</strong>(可以进行操作文档的路径指派，可以创建或者删除文件，以及还可以获取文件的相关信息内容)的操作类</h4><h4 id="2-File类的常用构造方法"><a href="#2-File类的常用构造方法" class="headerlink" title="(2).File类的常用构造方法"></a>(2).File类的常用构造方法</h4><p>​    </p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public File(String pathname)</td>
<td align="center">构造方法</td>
<td align="center">设置要操作文件的完整路径，要考虑分隔符</td>
</tr>
<tr>
<td align="center">public File(String parent, String child)</td>
<td align="center">构造方法</td>
<td align="center">设置要操作文件的父目录和子文件路径</td>
</tr>
<tr>
<td align="center">public boolean createNewFile() throws IOException</td>
<td align="center">方法</td>
<td align="center">创建一个新文件</td>
</tr>
<tr>
<td align="center">public boolean delete()</td>
<td align="center">方法</td>
<td align="center">删除此抽象路径名表示的文件或目录。如果此路径名表示目录，则该目录必须为空才能删除</td>
</tr>
<tr>
<td align="center">public boolean exists()</td>
<td align="center">方法</td>
<td align="center">判断文件是否存在</td>
</tr>
</tbody></table>
<p>​    <strong>注意：在使用File类指派操作文件的时候该文件的路径有可能不存在，只要不进行信息的获取操作不会有报错问题，只是表示一个要操作的文件路径</strong></p>
<p>​    <strong>程序的磁盘操作(解释为什么有延迟)</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hve0eI"><img src="https://z3.ax1x.com/2021/09/10/hve0eI.png" alt="hve0eI.png"></a></p>
<p>​    <strong>跨平台的分隔符问题</strong></p>
<ul>
<li>windows系统的路径分隔符为“\”；</li>
<li>Unix、类Unix（Linux、MacOS、ALX）路径分隔符为“/”；</li>
</ul>
<p>​    java考虑到这个问题所以是互通的，但写大量的杠杠转义处理非常麻烦，所以<strong>一般使用File类中提供的常量(public static final String separator)</strong>,早期命名规范与现在不同所以是小写separator</p>
<p>​    <strong>separator常量的使用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File file &#x3D; new File(&quot;D:&quot;+File.separator+&quot;Hello.txt&quot;);</span><br></pre></td></tr></table></figure>
<p>​    <strong>注意：以后编写代码所有路径分隔符尽量通过常量separator来进行定义</strong></p>
<h4 id="3-File类在父-多-目录下子文件的创建"><a href="#3-File类在父-多-目录下子文件的创建" class="headerlink" title="(3).File类在父(多)目录下子文件的创建"></a>(3).File类在父(多)目录下子文件的创建</h4><p>​    子文件在父目录下创建时必须保证父目录是存在的，不然会产生异常</p>
<p>​    <strong>对目录创建的File类中的方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public boolean mkdir()</td>
<td align="center">方法</td>
<td align="center">只创建单级目录</td>
</tr>
<tr>
<td align="center"><strong>public boolean mkdirs()</strong></td>
<td align="center"><strong>方法</strong></td>
<td align="center"><strong>创建多级目录(多个子目录可以同时创建)</strong></td>
</tr>
<tr>
<td align="center">public String getParent()</td>
<td align="center">方法</td>
<td align="center">获取父目录的信息</td>
</tr>
<tr>
<td align="center"><strong>public File getParentFile()</strong></td>
<td align="center"><strong>方法</strong></td>
<td align="center"><strong>获取父路径的File实例</strong></td>
</tr>
</tbody></table>
<p>​    <strong>在多线程下对文件的操作</strong><br>​    在Java项目中没有多线程，不是Java的风格。在多线程下对于文件是不是在父目录下每个线程都需要进行一个判断，此时程序的性能很低</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hveNSe"><img src="https://z3.ax1x.com/2021/09/10/hveNSe.png" alt="hveNSe.png"></a></p>
<p>​    为了提高程序的性能最好的方法是让判断操作只执行一次，所以<strong>我们可以考虑使用静态代码块的模式来执行，静态代码块的执行优先于主方法执行</strong></p>
<h4 id="4-File类提供的其他操作"><a href="#4-File类提供的其他操作" class="headerlink" title="(4).File类提供的其他操作"></a>(4).File类提供的其他操作</h4><table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public boolean canExecute()</td>
<td align="center">方法</td>
<td align="center">程序是否能执行该文件</td>
</tr>
<tr>
<td align="center">public boolean canRead()</td>
<td align="center">方法</td>
<td align="center">是否能读</td>
</tr>
<tr>
<td align="center">public boolean canWrite()</td>
<td align="center">方法</td>
<td align="center">是否能写</td>
</tr>
<tr>
<td align="center">public File getAbsoluteFile()</td>
<td align="center">方法</td>
<td align="center">显示文件的绝对路径</td>
</tr>
<tr>
<td align="center">public boolean isDirectory()</td>
<td align="center">方法</td>
<td align="center">判断File对象是否是文件夹</td>
</tr>
<tr>
<td align="center">public boolean isFile()</td>
<td align="center">方法</td>
<td align="center">判断当前路径是否为文件</td>
</tr>
<tr>
<td align="center">public long lastModified()</td>
<td align="center">方法</td>
<td align="center">获取最后一次修改日期</td>
</tr>
<tr>
<td align="center">public long length()</td>
<td align="center">方法</td>
<td align="center">获取文件的长度(大小)</td>
</tr>
</tbody></table>
<p>​    <strong>File类之中的返回的日期long就是毫秒数、而文件大小返回的就是字节个数</strong></p>
<h4 id="5-File类获取文件目录信息"><a href="#5-File类获取文件目录信息" class="headerlink" title="(5).File类获取文件目录信息"></a>(5).File类获取文件目录信息</h4><p>​    将一个目录中所有的目录下所有子目录和文件详细的列出<br>​    </p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public String[] list()</td>
<td align="center">方法</td>
<td align="center">列出子路径的信息(不包括父目录)</td>
</tr>
<tr>
<td align="center"><strong>public File[] listFiles()</strong></td>
<td align="center"><strong>方法</strong></td>
<td align="center"><strong>列出子路径的完整信息(不包括父目录)</strong></td>
</tr>
<tr>
<td align="center">​    <strong>可以通过递归查询到目录下所有的文件，通过删除操作，可以实现恶意程序，见文件实例例一</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="6-File类实现文件的更名处理"><a href="#6-File类实现文件的更名处理" class="headerlink" title="(6).File类实现文件的更名处理"></a>(6).File类实现文件的更名处理</h4><table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public boolean renameTo(File dest)</td>
<td align="center">方法</td>
<td align="center">重命名由此抽象路径名表示的文件，即改变文件名</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oldfile.renameTo(newFile); &#x2F;&#x2F;把旧文件名转化为新文件名，这两个都是绝对路径</span><br></pre></td></tr></table></figure>

<p>​    实例：文件的批量更名，见文件实例例二、例三</p>
<h3 id="3-流"><a href="#3-流" class="headerlink" title="3. 流"></a>3. 流</h3><h4 id="1-File类本身实现了文件自身的处理操作，但是并未规定其文件内容的操作，而要想实现文件内容就必须使用流的概念"><a href="#1-File类本身实现了文件自身的处理操作，但是并未规定其文件内容的操作，而要想实现文件内容就必须使用流的概念" class="headerlink" title="(1).File类本身实现了文件自身的处理操作，但是并未规定其文件内容的操作，而要想实现文件内容就必须使用流的概念"></a>(1).File类本身实现了文件自身的处理操作，但是并未规定其文件内容的操作，而要想实现文件内容就必须使用流的概念</h4><h4 id="3-流的简介"><a href="#3-流的简介" class="headerlink" title="(3).流的简介"></a>(3).流的简介</h4><p>​    流指的是数据的处理方式，以及目标的内容的处理机制，所有的流都分为输入流或输出流，Java针对输入流和输出流分为了两种类型：</p>
<ul>
<li>字节操作流：OutputStream（字节输出流）、InputStream（字节输入流）</li>
<li>字符操作流：Write（字符输出流）、Reader（字符输入流）</li>
</ul>
<p>​    字节与字符最大的区别体现在对中文的处理上<br>​    注意：不管使用哪一种操作流，本质上的操作流程都是类似的</p>
<p>​    所谓输入流与输出流是相对的，而Java会提供一组标准的操作形式<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/hveKy9"><img src="https://z3.ax1x.com/2021/09/10/hveKy9.png" alt="hveKy9.png"></a></p>
<h4 id="4-以文件流为例来描述流的表现形式"><a href="#4-以文件流为例来描述流的表现形式" class="headerlink" title="(4).以文件流为例来描述流的表现形式"></a>(4).以文件流为例来描述流的表现形式</h4><ul>
<li>通过File类设定要操作的文件路径</li>
<li>通过字节流或字符流的子类为对象进行对象实例化处理 </li>
<li>进行读、写的流操作</li>
<li>流属于宝贵资源，操作完毕后一定要关闭（close()）</li>
</ul>
<h4 id="5-字节输出流-OutputStream"><a href="#5-字节输出流-OutputStream" class="headerlink" title="(5).字节输出流(OutputStream)"></a>(5).字节输出流(OutputStream)</h4><p>​    java.io.OutputStream是实现字节输出流的操作类，<strong>通过其子类对其实例化后使用</strong></p>
<table>
<thead>
<tr>
<th>OutputStream类的定义</th>
</tr>
</thead>
<tbody><tr>
<td>public <strong>abstract</strong> class OutputStream extends Object <strong>implements Closeable, Flushable</strong></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Closeable接口的定义和它提供的方法</th>
<th>Flushable接口的定义和它提供的方法</th>
</tr>
</thead>
<tbody><tr>
<td>public interface Closeable extends AutoCloseable {void close() throws IOException{}}</td>
<td>public interface Flushable{void flush() throws IOException{}}</td>
</tr>
<tr>
<td>该方法时强制关闭</td>
<td>该方法是强制清空缓存</td>
</tr>
</tbody></table>
<p>​    <strong>缓存的作用</strong><br><a target="_blank" rel="noopener" href="https://imgtu.com/i/hvZBPU"><img src="https://z3.ax1x.com/2021/09/10/hvZBPU.png" alt="hvZBPU.png"></a></p>
<p>​    <strong>OutputStream类提供的三个输出方法（都很重要，加粗的用的多）</strong></p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public abstract void write(int b) throws IOException</td>
<td align="center">方法</td>
<td align="center">输出单个字节数据，<strong>byte和int是可以相互转换的</strong></td>
</tr>
<tr>
<td align="center">public void write(byte[] b) throws IOException</td>
<td align="center">方法</td>
<td align="center">输出全部字节数组的数据</td>
</tr>
<tr>
<td align="center"><strong>public void write(byte[] b, int off, int len) throws IOException</strong></td>
<td align="center"><strong>方法</strong></td>
<td align="center"><strong>输出部分字节数组的数据</strong></td>
</tr>
</tbody></table>
<p>​    <strong>FileOutputStream类（OutputStream类的子类）提供的构造方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public FileOutputStream(File file) throws FileNotFoundException</td>
<td align="center">构造方法</td>
<td align="center">设置文件输出流，每次都对原始内容进行覆盖</td>
</tr>
<tr>
<td align="center">public FileOutputStream(File file,boolean append) throws FileNotFoundException</td>
<td align="center">构造方法</td>
<td align="center">如果将append的内容设置为true，表示进行内容追加</td>
</tr>
</tbody></table>
<p>​    <strong>注意：在创建FileOutputStream需要进行异常处理</strong></p>
<h4 id="6-字节输入流-InputStream"><a href="#6-字节输入流-InputStream" class="headerlink" title="(6).字节输入流(InputStream)"></a>(6).字节输入流(InputStream)</h4><p>​    InputStream是一个提供字节输入流的实现类</p>
<table>
<thead>
<tr>
<th>InputStream类的定义</th>
</tr>
</thead>
<tbody><tr>
<td>public <strong>abstract</strong> class InputStream extends Object implements <strong>Closeable</strong></td>
</tr>
</tbody></table>
<p>​    注意：系统在进行读操作的时候是不会使用到系统的缓冲区的，是为了防止过多的写入才提供写入缓冲区，写入缓冲区才需要清空处理，所以InputStream类不实现Flushable父接口</p>
<p>​    InputStream类提供的输出方法（读取方法）</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public abstract int read() throws IOException</td>
<td align="center">方法</td>
<td align="center">读取单个字节数据，如果没有数据返回-1</td>
</tr>
<tr>
<td align="center"><strong>public int read(byte[] b) throws IOException</strong></td>
<td align="center"><strong>方法</strong></td>
<td align="center"><strong>将内容读取到字节数组之中，返回读取个数，如果没有数据返回-1，不够长就有多长读多长</strong></td>
</tr>
<tr>
<td align="center">public int read(byte[] b,int off,                 int len) throws IOException</td>
<td align="center">方法</td>
<td align="center">读取部分内容到字节数组中，返回读取个数，没有数据返回-1</td>
</tr>
<tr>
<td align="center">public int available() throws IOException</td>
<td align="center">方法</td>
<td align="center">获取可用长度</td>
</tr>
</tbody></table>
<p>​    InputStream是一个抽象类，可以利用FileInputStream子类为其进行实例化</p>
<p>​    <strong>FileInputStream提供的构造方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public FileInputStream(File file) throws FileNotFoundException</td>
<td align="center">构造方法</td>
<td align="center">打开实际文件创建FileInputStream实例，如果命名文件不存在，或是目录而不是常规文件，则会引发FileNotFoundException</td>
</tr>
</tbody></table>
<h4 id="7-字符输出流-Writer"><a href="#7-字符输出流-Writer" class="headerlink" title="(7).字符输出流(Writer)"></a>(7).字符输出流(Writer)</h4><p>​    OutputStream是可以实现输出操作的，但是其在进行输出的时候全部都是字节数组的形式完成的，但在大部分情况下，最方便的处理类型一定是字符串，所以为了简化输出操作，提供了字符输出流</p>
<table>
<thead>
<tr>
<th>Writer类的定义</th>
</tr>
</thead>
<tbody><tr>
<td>public <strong>abstract</strong> class Writer <strong>extends</strong> Object <strong>implements</strong> Appendable, Closeable, Flushable</td>
</tr>
</tbody></table>
<p>​    Writer抽象类与之前的OutputStream类相比，多实现了一个Appendable接口，里面只有一个append方法，<strong>append方法用来追加内容</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Appendable&#123; &#x2F;&#x2F;Appendable接口定义的三种方法</span><br><span class="line">	public Appendable append(CharSequence csq) throws IOException;</span><br><span class="line">	public Appendable append(CharSequence csq,int start,int end) throws IOException;</span><br><span class="line">	public Appendable append(char c) throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在使用Writer类进行输出的时候最大的操作特点在于其可以直接进行字符串的数据处理</p>
<table>
<thead>
<tr>
<th>Writer类的输出方法</th>
</tr>
</thead>
<tbody><tr>
<td>public void write(String str) throws IOException  //它可以直接输出字符串</td>
</tr>
</tbody></table>
<p>​    Writer类在后续的版本中逐步有了CharSequence接口的支持，只要可以接收此接口的实例，就意味可以追加String、StringBuffer、StringBuilder类的实例</p>
<p>​    <strong>与之前一样可以将Writer类实例化为FileWriter</strong></p>
<p>​    使用Writer可以实现与OutputStream类似的功能，但其最大的优势在于可以直接进行字符串数据的输出处理</p>
<h4 id="8-字符输入流-Reader"><a href="#8-字符输入流-Reader" class="headerlink" title="(8).字符输入流(Reader)"></a>(8).字符输入流(Reader)</h4><p>​    Reader是实现字符数据的输入流类</p>
<table>
<thead>
<tr>
<th>Reader类的定义</th>
</tr>
</thead>
<tbody><tr>
<td>public <strong>abstract</strong> class Reader <strong>extends</strong> Object <strong>implements</strong> Readable, Closeable</td>
</tr>
</tbody></table>
<p>​    Readable这个接口与NIO有关，不是IO</p>
<table>
<thead>
<tr>
<th>Reader类的输入方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int read() throws IOException</td>
<td>读取单个字符</td>
</tr>
<tr>
<td>public int read(char[] cbuf) throws IOException</td>
<td>将字符读入数组</td>
</tr>
<tr>
<td>public abstract int read(char[] cbuf, int off, int len) throws IOException</td>
<td>将一部分字符读入数组</td>
</tr>
</tbody></table>
<p>​    <strong>Reader的子类有FileReader</strong></p>
<h4 id="9-AutoCloseable类"><a href="#9-AutoCloseable类" class="headerlink" title="(9).AutoCloseable类"></a>(9).AutoCloseable类</h4><p>​    上面介绍的四个类实际上都属于AutoCloseable子类，所以对于打开和关闭的操作可以使用自动关闭的形式来处理</p>
<h4 id="10-字节流和字符流的区别"><a href="#10-字节流和字符流的区别" class="headerlink" title="(10).字节流和字符流的区别"></a>(10).字节流和字符流的区别</h4><p>​    字节操作属于基础的二进制数据流的操作形式，在网络、文件、图片、音乐等操作之中几乎都是以字节数据为主的，但是字节数据不方便进行中文的处理，所以对于中文的处理应该使用字符流。</p>
<p>​    在进行网络传输或者磁盘数据存储的时候，所有存放的内容都属于字节数据</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4Eka5Q"><img src="https://z3.ax1x.com/2021/09/14/4Eka5Q.png" alt="4Eka5Q.png"></a><br>​    <strong>缓冲区：实现字符与字节的转换</strong></p>
<p>​    实际上如果想要观察出字符流的缓冲区的存在，只需要在输出的时候取消close()方法的调用即可，因为此方法一旦调用实际上会自动清空缓冲区的内容，随后才会将数据写入到目标终端设备之中，如果此时由于某些原因就是无法进行字符输出流的关闭，则可以使用由Flushable接口继承而来的flush()方法进行手工的强制清除。</p>
<p>​    <strong>本质上传递的所有内容只有字节，而字符是程序对字节的包装，通过代码可以发现字节流和字符流的使用非常相似，一般以字节流方式为主，只有进行中文操作时才会考虑字符流处理</strong></p>
<h4 id="11-字节流和字符流的转换（转换流）"><a href="#11-字节流和字符流的转换（转换流）" class="headerlink" title="(11).字节流和字符流的转换（转换流）"></a>(11).字节流和字符流的转换（转换流）</h4><p>​    为了方便实现字节流和字符流的转换处理，提供了两个类：<strong>OutputStreamWriter</strong>和<strong>InputStreamReader</strong></p>
<ol>
<li><p>OutputStreamWriter</p>
<p>在构造方法中，需要接收一个OutputStream的对象，而后再向上转型变为字符流</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4VFHJJ"><img src="https://z3.ax1x.com/2021/09/15/4VFHJJ.png" alt="4VFHJJ.png"></a></p>
</li>
<li><p>InputStreamReader</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4Ve0Ln"><img src="https://z3.ax1x.com/2021/09/15/4Ve0Ln.png" alt="4Ve0Ln.png"></a></p>
<p>通过继承的关系，<strong>InputStreamReader、OutputStreamWriter都是字符流的子类</strong>，同时又可以通过构造方法接收InputStream类和OutputStream类的实例，<strong>再向上转型为字符流</strong></p>
<p>转换流在一些系统类库的操作之中比较常见，有些情况系统只会给用户字节流，但是为了方便处理需要进行字符流转换，这个时候才会使用到这个流</p>
<p>注意：这种转换在类的定义时也有体现，如：OutputStreamWriter是FileWriter的父类，InputStreamReader是FileReader的父类，<strong>即转换流是字符输入输出流的父类</strong></p>
</li>
</ol>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/08/16/Java11/">Java11</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-08-16T04:51:24.000Z" itemprop="datePublished">
    2021-08-16
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><h4 id="1-在java-util包中提供一些集合类，集合类又被称为容器"><a href="#1-在java-util包中提供一些集合类，集合类又被称为容器" class="headerlink" title="1. 在java.util包中提供一些集合类，集合类又被称为容器"></a>1. 在java.util包中提供一些集合类，集合类又被称为容器</h4><h4 id="2-集合类和数组的区别"><a href="#2-集合类和数组的区别" class="headerlink" title="2. 集合类和数组的区别"></a>2. 集合类和数组的区别</h4><ul>
<li>数组的长度是固定的，集合类的长度是可变的</li>
<li>数组用来存放基本数据类型的数据，集合类用来存放对象**(基本数据类型需要用包装类)**的引用</li>
</ul>
<h4 id="3-Collection-lt-E-gt-接口"><a href="#3-Collection-lt-E-gt-接口" class="headerlink" title="3. Collection&lt; E &gt;接口"></a>3. Collection&lt; E &gt;接口</h4><p>​    在Java中，Collection接口是层次结构的根接口（即集合的顶层框架）<br>​    Collection接口通常不能直接使用，但其提供增加、删除、管理数据的方法。List接口与Set接口继承了该接口，这些方法在这两个接口中是通用的</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add(E e)</td>
<td align="center">将指定的对象(元素e)添加到该集合中</td>
</tr>
<tr>
<td align="center">remove(Object o)</td>
<td align="center">将指定的对象从该集合中删除</td>
</tr>
<tr>
<td align="center">isEmpty()</td>
<td align="center">返回值为boolean，判断当前集合是否为空</td>
</tr>
<tr>
<td align="center">iterator()</td>
<td align="center">返回在此Collection的元素的迭代器，用于遍历集合中的对象</td>
</tr>
<tr>
<td align="center">size()</td>
<td align="center">返回值为int，获取该集合中元素的个数</td>
</tr>
</tbody></table>
<h4 id="4-迭代器（Iterator-lt-E-gt-接口，E为元素迭代器返回元素类型）"><a href="#4-迭代器（Iterator-lt-E-gt-接口，E为元素迭代器返回元素类型）" class="headerlink" title="4. 迭代器（Iterator&lt; E &gt;接口，E为元素迭代器返回元素类型）"></a>4. 迭代器（Iterator&lt; E &gt;接口，E为元素迭代器返回元素类型）</h4><p>​    在Java中，有很多的数据容器，对于这些的操作有很多的共性。Java采用了迭代器来为各种容器提供了公共的操作接口。这样使得对容器的遍历操作与其具体的底层实现相隔离，达到解耦的效果，<strong>即：迭代器的作用是用来遍历集合元素</strong>，我们无需关心该序列的底层结构是什么样子的。只要拿到这个对象,使用迭代器就可以遍历这个对象的内部</p>
<p>​    <strong>注意：一般使用增强for也可以遍历元素，但如果是无序的则需要用迭代器了</strong></p>
<p>​    迭代器的创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; a &#x3D; list.iterator();  &#x2F;&#x2F;在集合list下创建它的迭代器</span><br></pre></td></tr></table></figure>

<p>​    迭代器的方法</p>
<ul>
<li><p>hasNext()方法：如果迭代器有下一个元素返回true，否则返回false，这个方法并不移动指针</p>
</li>
<li><p>next()方法：向下移动指针，并且返回指针指向的元素，如果指针指向的内存中没有元素，会报异常，而且指针目前无法反向指，所以只可以一直向下。<strong>注意：返回元素的类型是Object类型</strong></p>
</li>
<li><p>remove()方法：移除iterator.next()方法最后访问的元素</p>
<p><strong>注意：在同一个迭代(循环)中只能使用一次next()方法，不然会产生异常（java.util.NoSuchElementException)</strong></p>
</li>
</ul>
<h4 id="5-List集合"><a href="#5-List集合" class="headerlink" title="5. List集合"></a>5. List集合</h4><p>​    (1).List集合包括List接口和List接口中所有实现类。List集合中元素允许重复，顺序为插入对象时的顺序，类似Java数组，用户可以通过索引来访问集合中的元素</p>
<p>​    (2).List接口继承Collection接口，包含其所有方法，还定义了两个重要方法</p>
<ul>
<li>get(int index)：获得指定索引位置的元素</li>
<li>set(int index , Object obj)：将元素中指定位置的对象修改</li>
</ul>
<p>​    (3).List接口的实现类</p>
<ul>
<li>ArrayList类<br>​    ArrayList类实现了可变的数组，允许保存所有元素，包括null，可以根据索引位置快速访问，缺点为插入和删除对象元素速度较慢，<strong>其操作是移动数组</strong><br>​    <strong>ArrayList是使用动态数组实现的</strong></li>
</ul>
<ul>
<li>LinkedList类<br>​    采用链表结构保存对象，优点便于向集合中插入和删除对象，缺点对于随机访问时效率低，<strong>其操作是定位节点</strong><br>​    <strong>LinkedList是使用双向链表实现的</strong></li>
</ul>
<p>​    (4).List集合的声明<br>​    <strong>通常声明为List类型，然后通过不同的实现类来进行实例化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;E为Java中合法的数据类型</span><br><span class="line">List&lt;E&gt; list &#x3D; new ArrayList&lt;&gt;(); </span><br><span class="line">List&lt;E&gt; list2 &#x3D; new LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><strong>注意1：代码中小括号内是可以设置容量的，如果不写的话JDK 1.8 默认是10且建议初始化容量减少系统初始化容量的耗时</strong><br><strong>注意2：该构造方法并不是将ArrayList()初始化为指定长度，而是指定了其内部的Object数组的长度，也就是其容量。当我们调用size()时，返回的是其实际长度，而非容量大小。对超出ArrayList长度的部分进行访问或赋值操作时也会造成访问越界，尽管它的容量大小足够</strong></p>
<p>​    <strong>注意：集合的索引与数组一样从0开始，而且使用remove方法删除数据时需要注意是否越界，即使用该方法时同时使用try-catch来捕捉异常</strong></p>
<h4 id="5-Set集合"><a href="#5-Set集合" class="headerlink" title="5. Set集合"></a>5. Set集合</h4><p>​    (1).Set集合的对象不按特定的方式排序，只是简单的把对象加入集合中<br>​    <strong>Set的构造有一个约束条件，传入的Collection对象不能有重复值，加入Set的元素必须定义equals()方法以确保对象的唯一性(在上面List中是可以重复的) ，小心操作可变可变对象导致出现问题</strong> </p>
<p>​    (2). Set接口继承Collection接口，包含Collection中所有的方法</p>
<p>​    (3). Set集合的常用的实现类</p>
<ul>
<li>HashSet类<br>​    HashSet类实现Set接口，由哈希表支持，不保证Set的迭代顺序，不保证顺序永恒不变，此类允许使用null元素</li>
<li>TreeSet类<br>​    TreeSet类在实现Set集合时，必须实现Comparable接口，实现接口中的方法compareTo(Object o)方法比较此对象与指定对象的顺序<br>​    TreeSet类不仅实现Set接口，还实现java.util.SortedSet接口，TreeSet类实现的Set集合在遍历集合时按照自然顺序递增排序，也可以按照指定的比较器递增排序，<strong>即TreeSet通过 Comparator&lt;-(这是一个无参方法) 或者 Comparable &lt;-(这是一个接口)维护了一个排序顺序</strong><br>​    <strong>一般使用TreeSet类来实现自定义排序</strong></li>
</ul>
<h4 id="6-Map集合"><a href="#6-Map集合" class="headerlink" title="6. Map集合"></a>6. Map集合</h4><p>​    (1).Map集合没有继承Collection接口，其提供key到value的映射，Map中不能有相同的key，每个key只可以映射一个value，使用的是Map接口</p>
<p>Map接口的常用方法</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">put(K key,V value)</td>
<td align="center">向集合中添加指定的key与value的映射关系</td>
</tr>
<tr>
<td align="center">containsKey(Object key)</td>
<td align="center">如果此映射包含指定key的映射关系，则返回true</td>
</tr>
<tr>
<td align="center">containsValue(Object value)</td>
<td align="center">如果此映射将一个或多个key映射到指定值，则返回true</td>
</tr>
<tr>
<td align="center">get(Object key)</td>
<td align="center">如果存在指定的key对象，则返回该对象对应的值，否则返回null</td>
</tr>
<tr>
<td align="center">keySet()</td>
<td align="center">返回该集合中的所有key对象形成的Set集合</td>
</tr>
<tr>
<td align="center">values()</td>
<td align="center">返回该集合中所有值对象形成的Collection集合</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/f2JSeS"><img src="https://z3.ax1x.com/2021/08/15/f2JSeS.png" alt="f2JSeS.png"></a></p>
<p>​    (2).<strong>注意：Map是双列的,Collection是单列的</strong><br>​    Map集合的实例化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;*,*&gt; map &#x3D; new HashMap&lt;&gt;() &#x2F;&#x2F;*为你要的数据类型</span><br></pre></td></tr></table></figure>

<p>​    <strong>(3).Map和Set和List的关系</strong></p>
<ul>
<li>Map中存放的时键值对，Set中存放的是单个对象，但如果把value看做key的附庸，key在哪里，value就在哪里，这样就可以像对待Set一样来对待Map了。事实上，Map提供了一个Entry内部类来封装key-value对，再计算Entry存储时则只考虑Entry封装的key。</li>
<li>如果把Map集合里的所有value放在一起来看，它们又类似于一个List，元素可以重复，每个元素可以根据索引来找，只是Map中的索引不再是整数值，而是以另一个对象作为索引</li>
</ul>
<p>​    (4).Map集合的内部类Entry<br>​    Map中包括一个内部类Entry,该类封装一个键值对，常用方法：</p>
<ul>
<li>Object getKey():返回该Entry里包含的所有key值；</li>
<li>Object getvalue():返回该Entry里包含的所有value值；</li>
<li>Object setValue(V value):设置该Entry里包含的value值，并设置新的value值。</li>
</ul>
<p>​    (5).Map接口的实现类<br>​    Map接口的常用实现类有HashMap和TreeMap。建议使用HashMap类实现Map集合，HashMap类实现的Map集合添加和删除元素效率更高</p>
<ul>
<li><p>HashMap类<br>​    基于哈希表的Map接口的实现，此实现提供所有可选的映射操作，并允许使用null值和null键，但必须保证键的唯一性，此类不保证映射的顺序，特别是它不保证该顺序永恒不变</p>
</li>
<li><p>TreeMap类<br>​    TreeMap类不仅实现了Map接口，而且实现了java.util.SortedMap接口，集合中的映射关系具有一定的顺序，在添加、删除、定位映射关系时，比HashMap性能稍差，且TreeMap不允许键对象为null</p>
</li>
</ul>
<p>​    <strong>注意：可以通过HashMap类创建Map集合，当需要顺序输出时，再创建一个完成相同映射关系的TreeMap类实例</strong></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/06/20/Java10/">Java10</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-06-20T10:19:20.000Z" itemprop="datePublished">
    2021-06-20
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h4 id="1-异常的概述"><a href="#1-异常的概述" class="headerlink" title="1. 异常的概述"></a>1. 异常的概述</h4><ul>
<li>异常是一个在程序执行期间发生的事件，它中断了正在执行的程序的正常指令流</li>
<li>异常产生后，如果不做任何处理，程序会被终止</li>
<li>异常在Java中也是作为类的实例的形式出现，在某一方法错误时，这个方法会创建一个异常对象，并把他传递给正在运行的系统，通过异常处理机制，可以将非正常情况下的处理代码与程序的主逻辑分离，即在编写代码主流程的同时在其他地方处理异常</li>
</ul>
<h4 id="2-jvm默认处理异常的方式"><a href="#2-jvm默认处理异常的方式" class="headerlink" title="2. jvm默认处理异常的方式"></a>2. jvm默认处理异常的方式</h4><ol>
<li>当某个方法出现异常情况时，会将异常封装成一个异常对象。</li>
<li>异常对象抛出给调用者，一层一层往上抛，最终到达main方法，主方法也没有办法处理，就抛出给jvm虚拟机</li>
<li>jvm虚拟机有没有得到指令处理异常，只能将异常的信息通过标准错误流（System.err）打印到控制台，结束自己。</li>
</ol>
<h4 id="3-异常的结构"><a href="#3-异常的结构" class="headerlink" title="3. 异常的结构"></a>3. 异常的结构</h4><p>​     <strong>在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出类）</strong><br>​     <strong>在java中只有Throwable类型的实例才可以被抛出（throw）或者捕获（catch）</strong><br>​    <strong>Throwable</strong>： 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。异常和错误的区别是：异常能被程序本身可以处理，错误是无法处理（但错误也是异常）<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/2qtZ5Q"><img src="https://z3.ax1x.com/2021/06/15/2qtZ5Q.png" alt="2qtZ5Q.png"></a></p>
<p>​    </p>
<p>**Error（错误）:**一般来说，最常见的错误有程序进入死循环、内存泄漏等。在这种情况下，程序运行时本身无法解决，只能通过其他程序干预，Error类对象由java虚拟机生成并抛弃（通常Java程序不对这类异常进行处理）</p>
<p>​    <strong>Exception（异常）</strong>：分两大类，运行时异常(不检查异常)和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。</p>
<ul>
<li><strong>运行时异常</strong>：都是<strong>RuntimeException类及其子类</strong>异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，<strong>这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理</strong>。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是<strong>Java编译器不会检查它</strong>，也就是说，当程序中可能出现这类异常，<strong>即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过</strong>。</li>
<li><strong>非运行时异常 （编译异常）</strong>：是<strong>RuntimeException以外的异常，类型上都属于Exception类及其子类</strong>。从程序语法角度讲是<strong>必须进行处理的异常，如果不处理，程序就不能编译通过</strong>。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</li>
</ul>
<h4 id="4-异常的处理"><a href="#4-异常的处理" class="headerlink" title="4. 异常的处理"></a>4. 异常的处理</h4><p>​    在Java中如果某个方法抛出异常，可以在当前方法中进行捕捉并处理，也可以将异常向上抛出</p>
<h4 id="5-异常的捕捉"><a href="#5-异常的捕捉" class="headerlink" title="5. 异常的捕捉"></a>5. 异常的捕捉</h4><p>​    Java语言通过try、catch、finally来处理异常</p>
<ul>
<li>try语句块用来存放可能发生异常的Java语句</li>
<li>catch程序块在try语句块之后，当try语句块里抛出异常时执行</li>
<li>finally语句块里的内容无论try语句是否跳出，正常都会执行</li>
</ul>
<p>​    <strong>注意：如果程序跳到了catch块后会继续向下执行，不会再去执行try代码块的内容</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	 	&#x2F;&#x2F;可能出现异常的代码</span><br><span class="line">&#125; catch (Exception e) &#123;&#x2F;&#x2F;可能出现的异常类型 异常的变量名称,e是引用了抛出的实例</span><br><span class="line">		&#x2F;&#x2F;针对该异常类型的处理办法</span><br><span class="line">&#125;</span><br><span class="line">finally&#123;</span><br><span class="line">	&#x2F;&#x2F;语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    获取异常的信息的函数(需要在异常引用变量名称后调用，这是可抛出类(异常最上层父类)的方法)</p>
<ul>
<li>getMessage()函数：输出错误性质</li>
<li>toString()函数：给出异常的类型与性质</li>
<li>printStackTrace()函数：指出异常的类型、性质、栈层次及出现在程序中的位置</li>
</ul>
<h4 id="6-在方法中抛出异常"><a href="#6-在方法中抛出异常" class="headerlink" title="6. 在方法中抛出异常"></a>6. 在方法中抛出异常</h4><p>​    <strong>(1).使用throws关键字抛出异常</strong><br>​    <strong>throws关键字通常被应用在声明方法时，用来指定可能抛出的异常。</strong>多个异常可以使用逗号隔开。当在主函数中调用该方法时，如果发生异常，就会将异常抛给指定异常对象<br>​    <strong>throws关键字声明的方法表示此方法不处理异常，而交给方法调用处进行处理</strong><br>​    <strong>注意：throws不会抛出异常对象只是起通知作用，但是catch块的引用方法按这个通知的来分配异常对象的引用类型，即throws声明了是哪种类型的异常，使它的调用者可以捕获这个异常及其父类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 方法名() throws 异常名&#123; &#x2F;&#x2F;异常名必须是JavaException的子类，不可以自己取</span><br><span class="line">	&#x2F;&#x2F;方法内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>注意：写了throws后，调用这个方法的调用方必须要对可能发生异常进行处理(不管程序是否发生异常)，不写throws的话，就正常使用方法，其出错的话编译器报错，但用了接收的try-catch可以处理。</strong><br>​    <strong>而且抛给调用方后，调用方使用try-catch来处理，如果不想处理可以继续向上抛，但最终还是要有能够处理该异常的代码</strong></p>
<p>​    <strong>(2).使用throw关键字抛出异常</strong><br>​    throw关键字通常用于方法体中，通过throw<strong>抛出一个异常对象</strong>，程序在执行到throw语句时立即终止,必须对该抛出的异常进行处理，要么捕获要么上抛，如果需要该方法上一级代码来捕获处理异常，则需要在方法的声明中使用throws关键字并指明要抛出的异常（是该异常的引用，如果用父类可能会造成问题），捕捉throw抛出的异常用try-catch语句块</p>
<h4 id="7-自定义的异常"><a href="#7-自定义的异常" class="headerlink" title="7. 自定义的异常"></a>7. 自定义的异常</h4><p>​    在Java中用户通过继承Exception类来自定义异常类<br>​    通常使用throw来抛出自定义异常<br>​    父类Exception的主要构造方法，详细见API文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception()</span><br><span class="line">	Constructs a new exception with null as its detail message.</span><br><span class="line">	Exception(String message)</span><br><span class="line">	Constructs a new exception with the specified detail message.</span><br></pre></td></tr></table></figure>

<p>​    使用自定义异常的步骤<br>​    (1). 创建自定义异常类<br>​    (2). 在方法中通过throw关键字抛出异常对象<br>​    (3). 对抛出异常进行处理</p>
<h4 id="7-异常的使用原则"><a href="#7-异常的使用原则" class="headerlink" title="7. 异常的使用原则"></a>7. 异常的使用原则</h4><p>​    异常的处理不应用来控制程序的正常流程，其主要作用是捕获程序在运行时发生的异常并进行相应的处理</p>
<h4 id="8-异常的注意事项"><a href="#8-异常的注意事项" class="headerlink" title="8. 异常的注意事项"></a>8. 异常的注意事项</h4><ul>
<li>一个方法被覆盖时，覆盖它的方法必须抛出相同的异常或异常子类</li>
<li>如果父类抛出多个异常，则覆盖方法必须抛出那些异常的一个子集，不能抛出新异常</li>
</ul>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/06/15/Java09/">Java09</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-06-15T11:34:04.000Z" itemprop="datePublished">
    2021-06-15
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="类的高级特性"><a href="#类的高级特性" class="headerlink" title="类的高级特性"></a>类的高级特性</h2><h4 id="1-类名冲突与完整路径"><a href="#1-类名冲突与完整路径" class="headerlink" title="1. 类名冲突与完整路径"></a>1. 类名冲突与完整路径</h4><p>​    在Java中，同名的两个类需要放在不同的类包(包)中<br>​    完整的类名为包名和类名的组合<br>​    像指定类时是可以写完整类名的但是由于麻烦和可读性就会使用import关键字来引入</p>
<h4 id="2-同一个包中的类相互访问时，可以不指定包名"><a href="#2-同一个包中的类相互访问时，可以不指定包名" class="headerlink" title="2. 同一个包中的类相互访问时，可以不指定包名"></a>2. 同一个包中的类相互访问时，可以不指定包名</h4><h4 id="3-CLASSPATH"><a href="#3-CLASSPATH" class="headerlink" title="3. CLASSPATH"></a>3. CLASSPATH</h4><p>​    直译的话就是类的路径，配置了classpath后java程序会直接去classpath的路径下去找.class文件运行。这样我们就可以在任意目录下来运行我们的java程序，在连接数据库时我配置了这个的环境变量</p>
<h4 id="4-package关键字"><a href="#4-package关键字" class="headerlink" title="4. package关键字"></a>4. package关键字</h4><p>​    用来定义包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package 包名</span><br></pre></td></tr></table></figure>
<p>​    需要将package表达式放置在第一行，它必须是程序第一行非注释代码<br>​    Java包的命名规则：全部使用小写字母</p>
<h4 id="5-import关键字"><a href="#5-import关键字" class="headerlink" title="5. import关键字"></a>5. import关键字</h4><p>​    (1).用来导入包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import 包名.类名  &#x2F;&#x2F;如果类不在包中则只要类名即可</span><br></pre></td></tr></table></figure>
<p>​    如果需要使用包中的多个类，类名用 * 代替， * 表所有的类<br>​    <strong>注意：<br>​    如果已经用import引入了一个类，如果还要引用一个和这个类同名的类，则必须使用完整路径</strong></p>
<p>​    (2).用来导入静态成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static 静态成员 &#x2F;&#x2F;静态成员应为完整路径，可以为静态变量，也可以是静态方法</span><br></pre></td></tr></table></figure>
<p>​    导入完之后就可以直接使用了，不需要再写完整的路径</p>
<h4 id="6-final关键字"><a href="#6-final关键字" class="headerlink" title="6. final关键字"></a>6. final关键字</h4><p>​    <strong>(1).final变量</strong><br>​    使用final声明的变量，一旦被设定就不可以再改变它的值，<strong>通常使用这个方式来定义常量，final常量定义时需要使用大写字母命名</strong><br>​    注意：final变量定义的时候，可以先声明，而不给初值，这种变量也称为final空白</p>
<p>​    final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量</p>
<p>​    <strong>(2).final对象</strong><br>​    使用final修饰对象，一旦一个对象的引用被修饰，则它只能恒定指向一个对象，不能改变指向，未被指定时可以随便指<br>​    <strong>注意：数组也可以看作是一个对象来使用这个关键字</strong></p>
<p>​    <strong>(3).final方法</strong><br>​    定义为final的方法不能被重写，可以被继承<br>​    定义为final的方法的执行效率高于非final的方法<br>​    定义为private不能被子类方法覆盖，private类型的方法默认是final类型的（这句先不说覆不覆盖就private感觉外部就调用不了了）</p>
<p>​    <strong>(4).final类</strong><br>​    定义为final类不能被继承，没有子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final 类名&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>如果一个类设置为final，则类中所有的方法都被隐式设置为final形式，但final类中的成员变量可以被定义为final或者非final形式</strong></p>
<p>​    <strong>(5).static和final一起使用</strong><br>​    static final用来修饰成员变量和成员方法，可以看作为全局常量</p>
<ul>
<li>对于变量，表示一旦给值就不可修改，并且通过类名可以访问</li>
<li>对于方法，表示不可覆盖，并且可以通过类名直接访问</li>
</ul>
<p>​    <strong>注意：对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象</strong></p>
<h4 id="7-内部类"><a href="#7-内部类" class="headerlink" title="7. 内部类"></a>7. 内部类</h4><p>​    如果在一个类中再定义一个类，则将这个再定义的类称为内部类，<strong>内部类分为成员内部类、局部内部类、匿名类</strong></p>
<p>​    <strong>(1).成员内部类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Outside&#123; &#x2F;&#x2F;外部类</span><br><span class="line">	private class Inside&#123; &#x2F;&#x2F;内部类,是一个私有成员</span><br><span class="line">		&#x2F;&#x2F;something</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>在内部类中可以随意使用外部类的成员方法和成员变量，尽管被修饰为了private</strong><br>​    就像main方法放在类中可以访问该类的私有成员一样<br>​    <strong>但外部类不能直接访问内部类成员，需要先将内部类在外部类中实例化后再使用，内部类为private在外部类实例化后一样也可以使用</strong><br>​    <strong>内部类修饰为private只能外部类访问，其他类没有权限访问（哪怕是继承了外部类的子类）</strong></p>
<p>​    内部类的实例化需要绑定在外部类的实例上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;内部类的实例化，如果在外部类和外部类非静态方法之外实例内部类对象则需要下面的形式</span><br><span class="line">外部类名.内部类名 引用变量名 &#x3D; 外部实例引用变量.内部实例  &#x2F;&#x2F;内部实例可以是new的也可以是其他只要是内部实例就行</span><br></pre></td></tr></table></figure>
<p>​    <strong>类中多次实现接口中同一个方法</strong><br>​    在程序中可以用权限修饰符为private的内部类实现。可以在外部提供一个接口，在接口中声明一个方法。如果在实现该接口的内部类中实现该接口的方法，就可以定义多个内部类以不同的方式实现接口中的同一个方法，而在一般的类中是不能多次实现接口中同一个方法的<br>​    此时通过在外部类中写方法实例化这个private内部类，之后用接口的引用来接这个实现接口的实例<br>​    <strong>详细见《Java实例-内部类的基本作用》例一</strong></p>
<p>​    <strong>外部类中定义的成员变量与内部类的成员变量名称相同，可以使用this关键字</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Outside&#123;</span><br><span class="line">	private int x &#x3D; 0;</span><br><span class="line">	private class Inside&#123;</span><br><span class="line">		private int x &#x3D; 9;</span><br><span class="line">		public void doit(int x)&#123;</span><br><span class="line">			x++;              &#x2F;&#x2F;调用的是形参x</span><br><span class="line">			this.x++          &#x2F;&#x2F;调用的是内部类成员变量x</span><br><span class="line">			Outside.this.x++  &#x2F;&#x2F;调用的是外部类成员变量x</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>(2).局部内部类</strong><br>​    在类的局部进行定义，如在类的方法或任意作用域中定义<br>​    由于内部类在类方法或者任意作用域中，<strong>在方法(作用域)的外部是无法访问该内部类</strong>，而内部类却可以访问当前代码块的常量**(final类型的局部变量)<strong>以及</strong>此外部类的所有成员**<br>​    在方法中的局部变量在内部类中可以访问<br>​    <strong>详细见《Java实例-内部类的基本作用》例二</strong></p>
<p>​    <strong>(3).匿名内部类</strong><br>​    用时再查，和局部内部类一样在方法中，不过去掉类名，在return语句下在描述类体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;语法</span><br><span class="line">return new A()&#123;&#x2F;&#x2F;A为接口名</span><br><span class="line">	&#x2F;&#x2F;类体</span><br><span class="line">&#125;; &#x2F;&#x2F;注意：这里特殊的需要加一个分号，分号代表接口的引用表达式的创建</span><br></pre></td></tr></table></figure>
<p>​    匿名内部类编译后会产生以“外部类名$序号”为名称的.class文件，序号以1<del>n排列，分别代表1</del>n个匿名内部类</p>
<p>​    <strong>(4).静态内部类（少见）</strong><br>​    在内部类前加修饰符static，则为静态内部类，<strong>静态内部类中可以声明static成员，但在非静态内部类中不能声明静态成员</strong><br>​    <strong>静态内部类的特点</strong></p>
<ul>
<li>静态内部类内不可以使用外部类的非静态成员</li>
<li>如果创建静态内部类的对象，不需要其外部类的对象<br>​    在程序测试时需要每个文件设置一个主方法，这会产生许多额外的代码，程序本身不需要这些主方法，所以一般把主方法写到静态内部类中，主要是编译后会产生独立类，测试完后删除即可</li>
</ul>
<h4 id="8-内部类的继承"><a href="#8-内部类的继承" class="headerlink" title="8. 内部类的继承"></a>8. 内部类的继承</h4><p>​    内部类的继承比普通类的继承要复杂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">public class First extends A.B&#123; &#x2F;&#x2F;继承内部类class B</span><br><span class="line">	public First(A a) &#123;</span><br><span class="line">		a.super();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">	class B&#123;</span><br><span class="line">		&#x2F;&#x2F;something</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>在某个类继承内部类时，必须硬性给与这个类一个带参数的构造方法，并且该构造方法的参数为需要继承内部类的外部类的引用，同时在构造方法体中使用a.super()语句，这样才为继承提供了必要的对象引用</strong></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/06/05/Java08/">Java08</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-06-05T11:46:05.000Z" itemprop="datePublished">
    2021-06-05
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h4 id="1-抽象类的引入"><a href="#1-抽象类的引入" class="headerlink" title="1. 抽象类的引入"></a>1. 抽象类的引入</h4><p>​    一般将父类定义为抽象类，然后对这个父类进行继承与多态处理，在继承树中越上方的类越抽象<br>​    在多态机制中，一般不需要将父类初始化对象，只需要子类对象，<strong>在Java中设置的抽象类不能实例化为对象</strong></p>
<h4 id="2-abstract关键字"><a href="#2-abstract关键字" class="headerlink" title="2. abstract关键字"></a>2. abstract关键字</h4><p>​    abstract关键字定义的类为抽象类，定义的方法为抽象方法，抽象方法没有方法体，方法本身没有意义，但通过重写来获得意义，承载这个抽象方法的抽象类必须被继承，实际上抽象类除了被继承之外没有任何意义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Test&#123;  &#x2F;&#x2F;定义抽象类</span><br><span class="line">	abstract void textAbstract();  &#x2F;&#x2F;定义抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    声明一个抽象的方法，则必须将承载这个抽象方法的类定义为抽象类，不可能在非抽象类获取抽象方法，只要类中有一个抽象方法，这个类就被标记为抽象类<br>​    抽象类被继承后子类若不是抽象类需要实现其中所有的抽象方法，要保证相同的方法名称、参数列表和相同的返回类型<br>​    abstract无法和final共存修饰类，但是抽象类里面可以用final与static修饰变量和方法，若你创建的类不想被创建对象，变量方法不想被继承，但又要可以直接调用，可以实现抽象类</p>
<h4 id="3-接口的引入"><a href="#3-接口的引入" class="headerlink" title="3. 接口的引入"></a>3. 接口的引入</h4><p>​    当你需要的一系列子类既需要继承重写父类的抽象方法，同时还需要一个共同的方法但实现过程各子类不相同，有些甚至不需要，就可以把这个方法封装在接口中，需要的子类再去实现这个接口，不需要的就不用了<br>​    接口是抽象类的延伸，可以把它看作为一个纯粹的抽象类，接口中的所有方法都没有方法体<br>​    接口用来弥补类无法实现多继承的局限<br>​    由于接口为抽象类，为父类，所以你也可以像之前多态一样去使用接口，具体见<strong>7</strong><br>​    <strong>注意：接口内的方法省略abstract关键字</strong><br>​    如果一个类实现了一个接口中要求的所有的方法，然而没有提供方法体而仅仅只有方法标识，那么这个类一定是一个抽象类</p>
<h4 id="4-interface关键字"><a href="#4-interface关键字" class="headerlink" title="4. interface关键字"></a>4. interface关键字</h4><p>​    接口使用interface关键字进行定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface drawTest&#123;&#x2F;&#x2F;public可以不要，有public类时就不需要了</span><br><span class="line">	void draw(); &#x2F;&#x2F;接口内的方法省略abstract关键字</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-implements关键字"><a href="#5-implements关键字" class="headerlink" title="5. implements关键字"></a>5. implements关键字</h4><p>​    一个类实现一个接口，可以使用implements关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;public可以不要，有public类时就不需要了</span><br><span class="line">public class child extends father implements drawTest&#123;&#x2F;&#x2F;可以不继承直接实现接口的，要实现多个接口每个接口用,隔开</span><br><span class="line">	&#x2F;&#x2F;something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-接口的注意事项"><a href="#6-接口的注意事项" class="headerlink" title="6. 接口的注意事项"></a>6. 接口的注意事项</h4><ul>
<li>在接口中方法必须定义为public或者abstract形式，其他权限修饰符不被Java编译器认可，如果未注明默认就是public and abstract的</li>
<li>在接口中定义的任何字段都自动是static和final和public的</li>
<li>继承一个接口时需要实现接口中所有的方法</li>
<li>一个类可以实现不止一个接口，语法见<strong>5</strong></li>
</ul>
<h4 id="7-接口的进阶"><a href="#7-接口的进阶" class="headerlink" title="7. 接口的进阶"></a>7. 接口的进阶</h4><p>​    <strong>我们不能直接去实例化一个接口，因为接口中的方法都是抽象的，是没有方法体的，这样怎么可能产生具体的实例呢？但是，我们可以使用接口类型的引用指向一个实现了该接口的对象，并且可以调用这个接口中的方法</strong></p>
<p>​    应该优先使用接口而不是类来引用对象。如果有适合的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明。只有当你利用构造器创建某个对象的时候，才真正需要引用这个对象的类。<br>​    如果你养成了用接口作为类型的习惯，你的程序将会更加灵活</p>
<h4 id="8-接口的静态方法"><a href="#8-接口的静态方法" class="headerlink" title="8. 接口的静态方法"></a>8. 接口的静态方法</h4><p>​    Java 8允许静态接口方法<br>​    不能覆盖静态接口方法，只能通过使用接口名+静态接口方法名使用该静态接口方法，实例化后是无法调用的<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/4zrWGD"><img src="https://z3.ax1x.com/2021/10/06/4zrWGD.png" alt="4zrWGD.png"></a></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/06/04/Java07/">Java07</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-06-04T14:37:40.000Z" itemprop="datePublished">
    2021-06-04
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="类的继承，多态"><a href="#类的继承，多态" class="headerlink" title="类的继承，多态"></a>类的继承，多态</h2><h4 id="1-继承的基本思想是基于某个父类进行拓展，得到一个新子类，该子类可以继承父类原有的属性和方法，可以增加父类不具备的属性和方法，可以重写-覆盖-父类中的某些方法"><a href="#1-继承的基本思想是基于某个父类进行拓展，得到一个新子类，该子类可以继承父类原有的属性和方法，可以增加父类不具备的属性和方法，可以重写-覆盖-父类中的某些方法" class="headerlink" title="1. 继承的基本思想是基于某个父类进行拓展，得到一个新子类，该子类可以继承父类原有的属性和方法，可以增加父类不具备的属性和方法，可以重写(覆盖)父类中的某些方法"></a>1. 继承的基本思想是基于某个父类进行拓展，得到一个新子类，该子类可以继承父类原有的属性和方法，可以增加父类不具备的属性和方法，可以重写(覆盖)父类中的某些方法</h4><h4 id="2-extends关键字"><a href="#2-extends关键字" class="headerlink" title="2. extends关键字"></a>2. extends关键字</h4><p>​    用来标识两个类的继承关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;父类</span><br><span class="line">class bookStore&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;子类</span><br><span class="line">class book extends bookStore&#123;</span><br><span class="line">	&#x2F;&#x2F;当子类再次声明与父类一样的成员变量时，就有两个名字一样的成员变量，要使用父类的话需用super()关键字来引用父类(无关键字时，子类中和父类中的属性或方法同名，则父类中的方法或属性将被覆盖或隐藏)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-super关键字"><a href="#3-super关键字" class="headerlink" title="3. super关键字"></a>3. super关键字</h4><p>​    (1).在Java类中使用super关键字来引用父类的成分，它是一个指代变量，用于在子类中指代父类对象<br>​    (2).只能用于子类的构造函数和实例方法中，不能用于子类的类（静态）方法中。原因是super指代的是一个父类的对象，它需要在运行时被创建，而静态方法是类方法，它是类的一部分。当类被加载时，方法已经存在，但是这时候父类对象还没有被初始化</p>
<h4 id="4-子类是父类的派生类，它的实例化依赖于父类的实例化。所以它的任何一个构造函数都必须要初始化父类"><a href="#4-子类是父类的派生类，它的实例化依赖于父类的实例化。所以它的任何一个构造函数都必须要初始化父类" class="headerlink" title="4. 子类是父类的派生类，它的实例化依赖于父类的实例化。所以它的任何一个构造函数都必须要初始化父类"></a>4. 子类是父类的派生类，它的实例化依赖于父类的实例化。所以它的任何一个构造函数都必须要初始化父类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class bookStore&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;子类</span><br><span class="line">class book extends bookStore&#123;</span><br><span class="line">	public book()&#123;</span><br><span class="line">		super();  &#x2F;&#x2F;初始化父类</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>注意：</strong></p>
<ul>
<li>在我们子类的构造函数中，如果我们没有显式调用super来初始化父类的话，那么Java会隐式的调用super();来调用父类无参构造函数并把它放在构造函数的第一行</li>
<li>Java只会隐式的调用无参构造函数，如果父类没有无参构造函数，那么子类中就必须显式的调用super关键字来调用已有的有参构造函数来初始化父类</li>
<li> 子类中的super为什么必须要放在第一行？因为子类的实例化依赖于父类的实例化，在构建子类时，必须要有父类实例，只能有了父类的实例，子类才能够初始化自己</li>
</ul>
<h4 id="5-当实例化子类对象时，父类的对象也相应的被实例化，且Java编译器会在子类的构造方法中自动调用父类的无参构造方法，-一个-多个父类时是从顶级向下调用"><a href="#5-当实例化子类对象时，父类的对象也相应的被实例化，且Java编译器会在子类的构造方法中自动调用父类的无参构造方法，-一个-多个父类时是从顶级向下调用" class="headerlink" title="5. 当实例化子类对象时，父类的对象也相应的被实例化，且Java编译器会在子类的构造方法中自动调用父类的无参构造方法，(一个)多个父类时是从顶级向下调用"></a>5. 当实例化子类对象时，父类的对象也相应的被实例化，且Java编译器会在子类的构造方法中自动调用父类的无参构造方法，(一个)多个父类时是从顶级向下调用</h4><h4 id="6-方法的重写"><a href="#6-方法的重写" class="headerlink" title="6. 方法的重写"></a>6. 方法的重写</h4><p>​    重写也可以称为覆盖，是保留父类成员方法的名字，可以重写成员方法实现的内容、成员方法的修饰符权限、成员方法的返回值类型<br><strong>注意：修改成员方法修饰符权限只能从小范围向大范围改变</strong><br><strong>注意：不可以被重写，可以被继承</strong></p>
<p>​    重构：特殊的重写方法，子类与父类的返回值、方法名称、参数类型以及个数完全相同，唯一不同的是方法的实现内容</p>
<h4 id="7-Object类"><a href="#7-Object类" class="headerlink" title="7. Object类"></a>7. Object类</h4><p>​    在Java中所有的类都继承了Java.lang.Object类，由于所有类都是继承这个类所以定义类时可以省略extends Object</p>
<p>​    Object类中的getClass()，notify()，notifyAll()，wait()等方法不能被重写，这些方法被定义为final类型</p>
<p>​    Object类的重要方法</p>
<ul>
<li><p>getClass()方法<br>​    返回对象执行时的Class实例，该实例通过getName()方法获得类的名称</p>
</li>
<li><p>toString()方法<br>​    将一个对象返回为字符串形式，它会返回一个String实例，在实际运用中经常重写该方法</p>
</li>
<li><p>equals()方法<br>​    按理说是比较两个对象的实际内容是否相等,但类对象的equals方法实现了对象上最有区别的等价关系；也就是说，对于任何非空的引用值x和y，当且仅当x和y引用同一对象（x == y的值为true）时，此方法才返回true，像之前的String比较里面内容是因为重写了这个方法<br>​    <strong>注意：在自定义类中使用equals()方法进行比较时，相同的对象比较会返回false，因为equals()方法的默认实现使用”==”运算符来比较两个对象的引用地址，而不上比较对象的内容，所以要比较内容需要重写equals()方法</strong></p>
</li>
</ul>
<h4 id="8-对象类型的转换"><a href="#8-对象类型的转换" class="headerlink" title="8. 对象类型的转换"></a>8. 对象类型的转换</h4><ul>
<li><p>向上转型(多态)<br>​    把子类对象赋值给父类类型的引用变量<br>​    <strong>父类的引用可以调用子类中重写的父类的方法，但不能调用子类中独有的方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类型 a &#x3D; new 子类型();</span><br></pre></td></tr></table></figure>
</li>
<li><p>向下转型(显式类型转换)<br>​    把父类对象强制转化为子类型，赋值给子类引用变量<br>​    进行向下转型时，如果父类对象不是子类的实例，会产生ClassCastException异常，所以经常使用instanceof操作符来完成判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子类型 b &#x3D; (子类型)父类对象的引用变量;</span><br></pre></td></tr></table></figure>
<p>​    父类中没有的方法和类型必须要向下转型后才能调用</p>
</li>
</ul>
<h4 id="9-instanceof操作符"><a href="#9-instanceof操作符" class="headerlink" title="9. instanceof操作符"></a>9. instanceof操作符</h4><p>​    用来判断是否一个类实现了某个接口，还可以判断一个实例的对象是否属于一个类(子类一定时属于父类的，不能说父类属于子类，即平行四边形属于四边形，但四边形不属于平行四边形)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子对象 instanceof 父类型; &#x2F;&#x2F;返回true</span><br></pre></td></tr></table></figure>
<p>​    该方式经常与向下转型连用，当不属于时把父类强制转化为子类<br>​    当两个类完全没有关系时使用这个操作符来操作会报错</p>
<p><strong>详细使用请看笔记《Java实例-多态》</strong></p>
<h4 id="10-方法的重载"><a href="#10-方法的重载" class="headerlink" title="10. 方法的重载"></a>10. 方法的重载</h4><p>​    在同一个类中允许存在一个以上的同名方法，只要这些方法的参数个数或类型不同即可<br>​    <strong>注意：方法重载中可以使两个方法的返回值类型不同，但只有返回值类型不同不足以区分两个方法的重载</strong><br>​    编译器是利用方法名、方法各参数类型和参数的个数以及参数的顺序来确定类中的方法是否唯一</p>
<h4 id="11-不定长参数"><a href="#11-不定长参数" class="headerlink" title="11. 不定长参数"></a>11. 不定长参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;定义不定长参数方法</span><br><span class="line"> &#x2F;&#x2F;返回值 方法名(参数数据类型...参数名称)</span><br><span class="line">public static int add(int...a)&#123;不定长参数a为一个数组，a的长度取决于调用时传的参数</span><br><span class="line">	&#x2F;&#x2F;方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    不定长参数方法可以作为一个单独的重载方法</p>
<h4 id="12-多态"><a href="#12-多态" class="headerlink" title="12. 多态"></a>12. 多态</h4><p>​    多态存在的三个前提</p>
<ul>
<li>要有继承关系</li>
<li>子类要重写父类方法</li>
<li>父类引用指向子类对象</li>
</ul>
<p>​    通过定义一个父类，让它的所有子类通过向上转型的原则作为一个方法的参数，再在这个方法中做出一些限定，后可以做出每个子类自己独有的事情。<br>​    这样的处理可以很好解决代码的冗余问题，同时使得程序易于维护，可以随意增加子类，只需要改变传参就可以了</p>
<p><strong>多态的样例代码见请看笔记《Java实例-多态》</strong></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/06/02/Java06/">Java06</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-06-02T08:41:57.000Z" itemprop="datePublished">
    2021-06-02
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h4 id="1-为什么要有包装类"><a href="#1-为什么要有包装类" class="headerlink" title="1. 为什么要有包装类"></a>1. 为什么要有包装类</h4><ul>
<li>在面向对象中，“一切皆对象”，但基本数据类型的数据不太符合这一理念，基本数据类型不是对象</li>
<li>涉及到类型之间的转化，数据类型之间的基本操作；如果都有我们自己去实现，那么工作量过大</li>
<li>java针对每一个基本数据类型都设计了一个包装类</li>
</ul>
<h4 id="2-java-lang包中的Integer类、Long类、Short类，可以将int、long和short封装成一个类，这些都是Number的子类，他们包含的方法基本相同，之后只以Integer类为例"><a href="#2-java-lang包中的Integer类、Long类、Short类，可以将int、long和short封装成一个类，这些都是Number的子类，他们包含的方法基本相同，之后只以Integer类为例" class="headerlink" title="2. java.lang包中的Integer类、Long类、Short类，可以将int、long和short封装成一个类，这些都是Number的子类，他们包含的方法基本相同，之后只以Integer类为例"></a>2. java.lang包中的Integer类、Long类、Short类，可以将int、long和short封装成一个类，这些都是Number的子类，他们包含的方法基本相同，之后只以Integer类为例</h4><h4 id="3-Integer类"><a href="#3-Integer类" class="headerlink" title="3. Integer类"></a>3. Integer类</h4><p>Integer类将原语类型int的值包装在对象中。integer类型的对象包含一个类型为int的字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		Integer d &#x3D; Integer.valueOf(400); &#x2F;&#x2F;等同于将基本类型装箱，另一种装箱方法已经不允许Integer d &#x3D; new Integer(400);</span><br><span class="line">		int a &#x3D; d.intValue(); &#x2F;&#x2F;将Integer类型拆箱</span><br><span class="line">&#x2F;*</span><br><span class="line">*在Java 5之前的版本中，基本数据类型和包装类之间的转换是需要手动进行的,但Sun公司从Java5开始提供了的自动装箱(Autoboxing)和自动拆箱(AutoUnboxing)操作</span><br><span class="line">*&#x2F;</span><br><span class="line">		Integer i &#x3D; 13; &#x2F;&#x2F;自动装箱</span><br><span class="line">		int c &#x3D; i;      &#x2F;&#x2F;自动拆箱</span><br><span class="line">		System.out.print(a);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;输出400</span><br></pre></td></tr></table></figure>
<p>一般都是使用该类的提供的一些方法，让数据可以在int类型与String类型之间相互转换<br>如，以下为部分静态方法(详细全部方法见API文档)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">toString() &#x2F;&#x2F;返回一个表示该Integer值的String对象，返回值String</span><br><span class="line">parseInt(String str) &#x2F;&#x2F;返回包含在由str指定的字符串中的数字的等价整数值，返回值int</span><br><span class="line">valueOf(String str或者int i) &#x2F;&#x2F;返回保存指定的String值或int值的Integer对象</span><br><span class="line">intValue() &#x2F;&#x2F;以int型返回此Integer对象，返回值int</span><br></pre></td></tr></table></figure>

<h4 id="4-Boolean类，Byte类，Character类，Double类都与上面Integer类类似，需要时自己查阅即可"><a href="#4-Boolean类，Byte类，Character类，Double类都与上面Integer类类似，需要时自己查阅即可" class="headerlink" title="4. Boolean类，Byte类，Character类，Double类都与上面Integer类类似，需要时自己查阅即可"></a>4. Boolean类，Byte类，Character类，Double类都与上面Integer类类似，需要时自己查阅即可</h4><h2 id="数字处理类"><a href="#数字处理类" class="headerlink" title="数字处理类"></a>数字处理类</h2><h4 id="1-Java中未进行格式化的数字遵循以下原则："><a href="#1-Java中未进行格式化的数字遵循以下原则：" class="headerlink" title="1. Java中未进行格式化的数字遵循以下原则："></a>1. Java中未进行格式化的数字遵循以下原则：</h4><ul>
<li>如果数据绝对值大于0.001并且小于10000000，使以常规小数形式表示</li>
<li>如果数据绝对值小于0.001并且大于10000000，使用科学计数法表示</li>
</ul>
<h4 id="2-数字格式化-使用DecimalFormat"><a href="#2-数字格式化-使用DecimalFormat" class="headerlink" title="2. 数字格式化(使用DecimalFormat)"></a>2. 数字格式化(使用DecimalFormat)</h4><p>​    使用这个类时需要用import关键字将java.text.DecimalFormat引入<br>​    DecimalFormat是NumberFormat的一个子类，用于格式化十进制数字，可以在实例化DecimalFormat对象时传递数字格式(以字符串格式表示)，如果未传入的话则可以通过applyPattern方法来传入设置模板(模板是有特殊字符组成的)，该方法参数为空时抛出异常NullPointerException，<strong>注意：小数时若模板小于数字则会四舍五入</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/2V5aR0"><img src="https://z3.ax1x.com/2021/05/30/2V5aR0.png" alt="2V5aR0.png"></a></p>
<hr>
<p><strong>DecimalFormat类中特殊字符的说明</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">代表阿拉伯数字，一个0表示一个阿拉伯数字，如果该位不存在数字，则显示0</td>
</tr>
<tr>
<td align="center">#</td>
<td align="center">代表阿拉伯数字，一个#表示一个阿拉伯数字，如果该位不存在数字，则不显示</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">小数分割符或货币小数分割符</td>
</tr>
</tbody></table>
<p>​    setGroupingSize(int newValue)方法设置格式化数字的分组大小,分组大小是数字整数部分中分组分隔符之间的位数，像分组为2的话，123456.789为12,34,56.789<br>​    setGroupingUsed(boolean newValue)方法设置是否在此格式中使用分组，newValue的值为如果使用分组，则为true；否则为假</p>
<h4 id="3-数学运算"><a href="#3-数学运算" class="headerlink" title="3. 数学运算"></a>3. 数学运算</h4><p>​    Java中提供了一个执行数学基本运算的Math类，在java.lang.Math，里面提供的大多数方法都被定义为static形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.数字方式</span><br></pre></td></tr></table></figure>
<p>​    Math类也提供一些常用数学常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.PI   &#x2F;&#x2F;Π</span><br></pre></td></tr></table></figure>
<p>​    <strong>常用的数学运算方法分为四类，三角函数方法、指数函数方法、取整函数方法、取最大值最小值绝对值函数方法，具体的需要使用时，自行翻阅API文档</strong></p>
<h4 id="4-随机数"><a href="#4-随机数" class="headerlink" title="4. 随机数"></a>4. 随机数</h4><p>​    通过Math类中的random()方法产生伪随机数字，该方法返回一个double型的随机数，小数点后面可以保留15位小数，返回值是从该范围内以（近似）均匀分布伪随机选择的，范围在0&lt;=Math.random()&lt;1.0，通过对于该方法的处理可以产生任意范围内的随机数，这个方法是调用java.util.Random()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;产生其他范围的伪随机数</span><br><span class="line">(int)(Math.random()*n) &#x2F;&#x2F;返回大于等于0且小于n的随机数</span><br><span class="line">m+(int)(Math.random()*n) &#x2F;&#x2F;返回大于等于m且小于m+n的随机数</span><br></pre></td></tr></table></figure>
<p>​    什么是伪随机数？</p>
<ul>
<li>伪随机数是看似随机实质是固定的周期性序列,也就是有规则的随机。</li>
<li>只要这个随机数是由确定算法生成的,那就是伪随机,只能通过不断算法优化,使你的随机数更接近随机。(随机这个属性和算法本身就是矛盾的)</li>
<li>通过真实随机事件取得的随机数才是真随机数</li>
</ul>
<p>​    Random类<br>​    Random类在java.util下，通过实例化Random对象可以创建一个随机数字生成器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random r &#x3D; new Random(); &#x2F;&#x2F;未在初始化器里设置种子</span><br></pre></td></tr></table></figure>
<p>​    当用这个方式实例化对象时(未在初始化器里设置种子)，Java编译器将以系统当前时间作为随机数生成器的种子(每时每刻时间不同)，但如果运行速度太快，也会产生两次运行结果相同的随机数</p>
<p>​    也可以在实例化对象时，设置随机数生成器种子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random r &#x3D; new Random(long seed); &#x2F;&#x2F;设置种子,当种子一样时，产生的随机数是一样的</span><br></pre></td></tr></table></figure>

<p>​    Random类提供的常用方法(部分)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public int nextInt():返回一个随机整数</span><br><span class="line">public int nextInt(int n):返回大于等于0且小于n的随机整数</span><br><span class="line">public boolean nextBoolean():返回一个随机布尔值</span><br><span class="line">public double nextDouble():返回一个随机双精度值</span><br></pre></td></tr></table></figure>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/05/25/Java05/">Java05</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-05-25T13:30:52.000Z" itemprop="datePublished">
    2021-05-25
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h4 id="1-在Java中对象的属性也被称为成员变量，类对象的行为叫做成员方法"><a href="#1-在Java中对象的属性也被称为成员变量，类对象的行为叫做成员方法" class="headerlink" title="1. 在Java中对象的属性也被称为成员变量，类对象的行为叫做成员方法"></a>1. 在Java中对象的属性也被称为成员变量，类对象的行为叫做成员方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;成员方法的语法格式</span><br><span class="line">	权限修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">	&#x2F;&#x2F;方法体</span><br><span class="line">	return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-权限修饰符"><a href="#2-权限修饰符" class="headerlink" title="2. 权限修饰符"></a>2. 权限修饰符</h4><p><strong>类权限(注意：类权限会约束类成员的权限设定，大于类的权限的类成员都会默认为类的权限进行约束)</strong></p>
<table>
<thead>
<tr>
<th align="center">访问包位置</th>
<th align="center">private</th>
<th align="center">protected</th>
<th align="center">public</th>
</tr>
</thead>
<tbody><tr>
<td align="center">本类</td>
<td align="center">可见</td>
<td align="center">可见</td>
<td align="center">可见</td>
</tr>
<tr>
<td align="center">同包其他类或者子类</td>
<td align="center">不可见</td>
<td align="center">可见</td>
<td align="center">可见</td>
</tr>
<tr>
<td align="center">其他包的类或子类</td>
<td align="center">不可见</td>
<td align="center">不可见</td>
<td align="center">可见</td>
</tr>
</tbody></table>
<p><strong>注意：声明类时不使用上述三个修饰符设置权限，则这个类预设为friendly，可以本类，同包其他类但不能子类，其他包即子类也不行</strong></p>
<h4 id="3-局部变量"><a href="#3-局部变量" class="headerlink" title="3. 局部变量"></a>3. 局部变量</h4><p>​    在成员方法内定义的变量叫做局部变量，方法是形参也是局部变量<br>​    <strong>局部变量在方法内使用时必须进行赋值和初始化不然会报错</strong></p>
<h4 id="4-局部变量的作用域-有效范围"><a href="#4-局部变量的作用域-有效范围" class="headerlink" title="4. 局部变量的作用域(有效范围)"></a>4. 局部变量的作用域(有效范围)</h4><p>​    在相互不嵌套使用的作用域中可以同时声明两个名称和类型相同的局部变量<br>​    一个花括号括起来的表示一个作用域</p>
<h4 id="5-this关键字"><a href="#5-this关键字" class="headerlink" title="5. this关键字"></a>5. this关键字</h4><p>​    在Java语言中规定使用this关键字来代表本类对象的引用，即引用对象的成员变量和方法<br>​    <strong>(1).在局部变量与类的成员变量重名时，就需要添加this关键字来明确引用的是类</strong></p>
<p>​    (2).this关键字还可以作为方法的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Book getBook()&#123;</span><br><span class="line">	return this;      &#x2F;&#x2F;返回Book类的对象等同于return Book</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    (3).this关键字还可以调用构造方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123; &#x2F;&#x2F;定义一个类，类的名字为student。  </span><br><span class="line">	public Student() &#123; &#x2F;&#x2F;定义一个方法，名字与类相同故为构造方法</span><br><span class="line">		this(“Hello!”);   &#x2F;&#x2F;this来引用下面的带形参的构造方法，因为this关键字里面带有一个参数</span><br><span class="line">		&#125;</span><br><span class="line">	public Student(String name) &#123;</span><br><span class="line">		&#x2F;&#x2F;定义一个带形式参数的构造方法 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>注意：this()只能出现在构造方法非注释语句的第一行</strong></p>
<p>​    (4). this关键字不能使用在静态方法当中</p>
<h4 id="6-类的构造方法"><a href="#6-类的构造方法" class="headerlink" title="6. 类的构造方法"></a>6. 类的构造方法</h4><p>类中除了成员方法外，还存在着构造方法<br>​    ==构造方法是一个与类同名的方法==，对象的创建就是构造方法完成的，每当实例化对象(new 对象)时，类会自动调用构造方法<br>​    <strong>注意：构造方法没有返回值，但方法前不需要void关键字修饰，类中没有明确定义构造方法时编译器会自动创建一个不带参数的默认构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构造方法的定义格式</span><br><span class="line">public book()&#123; &#x2F;&#x2F;里面可以放参数</span><br><span class="line">	&#x2F;&#x2F;构造方法体; &#x2F;&#x2F;可以初始化成员变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-static关键字"><a href="#7-static关键字" class="headerlink" title="7. static关键字"></a>7. static关键字</h4><p>​    由static修饰的变量、常量和方法被称为静态变量、常量和方法，即静态成员，静态成员属于类所有，使用类名+’.’运算符调用静态成员<br>​    当需要两个或以上的类要在同一个内存区域共享一个数据，可以使用静态变量来存储该数据<br>​    实例化后的对象依然可以调用静态XX，但不建议使用这样的形式，这样容易混淆静态成员和非静态成员<br>​    <strong>注意：静态方法中不可以直接调用非静态方法</strong><br>​    Java中规定不能将方法体内的局部变量声明为static</p>
<p>​    <strong>类加载</strong><br>​    jvm在程序执行的时候，需要用到类中的信息，但jvm只能读取内存的数据，所以需要进一步操作，把类中的信息，从硬盘上.class文件读取出来放在合适的位置<br>​    当一个类首次被使用，对该类加载，加载的同时，执行类的初始化过程<strong>（注意初始化和实例化的区别）</strong><br>​    被<strong>static关键字修饰</strong>的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">	private Test(String s) &#123;</span><br><span class="line">		System.out.println(s);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;通过static关键字在类加载时初始化a</span><br><span class="line">	private static Test a &#x3D; new Test(&quot;这是一个static程序&quot;);</span><br><span class="line">	</span><br><span class="line">	public static Test instance() &#123;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>​    <strong>类的初始化操作</strong><br>​    通过static定义静态区域(静态块)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class example&#123;</span><br><span class="line">	static&#123;</span><br><span class="line">		&#x2F;&#x2F;some;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    当这个类被引用时，首先自动执行static块中的程序，而且只会执行一次</p>
<h4 id="8-类的主方法"><a href="#8-类的主方法" class="headerlink" title="8. 类的主方法"></a>8. 类的主方法</h4><p>​    主方法是类的入口点，Java编译器通过主方法来执行程序<br>​    主方法语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	&#x2F;&#x2F;方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    主方法的特性<br>​    (1).主方法是静态的,在主方法中要直接调用其他方法,该方法也必须是静态的<br>​    (2).主方法没有返回值<br>​    (3).主方法的形参为数组,args[0]~args[n],表示第一到第n个参数,参数个数用args.length来获取</p>
<h4 id="9-对象"><a href="#9-对象" class="headerlink" title="9. 对象"></a>9. 对象</h4><p>​    (1).对象的创建<br>​    对象是由类抽象出来的某一个特例,每一个对象是相互独立的<br>​    Java语言中使用new操作符调用构造方法来创建对象,对象被创建出来时就是对一个对象的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Book a &#x3D; new Book(); &#x2F;&#x2F;对象的创建可以直接new Book()不需要前面的,但操作不了</span><br></pre></td></tr></table></figure>

<p>​    (2).访问对象的属性和方法<br>​    在使用new操作符创建了一个对象后,可以使用”对象.类成员”来获取对象的属性和方法</p>
<p>​    (3).对象的引用<br>​    基本语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;类名 对象引用名称</span><br><span class="line">Book book; &#x2F;&#x2F;引用不需要有一个对象相关联</span><br></pre></td></tr></table></figure>
<p>​    <strong>注意:引用只是存放一个对象的内存地址,并非存放一个对象</strong></p>
<p>​    (4).对象的比较<br>​    Java语言有两种比较对象的方式,”==”运算符和equals()方法(String类中的方法)</p>
<ul>
<li><p>“==”运算符<br>​    比较的是两个对象的引用地址是否相等</p>
</li>
<li><p>equals()方法<br>​    比较两个对象引用所指向的内容是否相等</p>
</li>
</ul>
<p>​    (5).对象的销毁<br>​    在Java中处于两种情况下对象被Java虚拟机视为垃圾</p>
<ul>
<li>对象引用超过其作用范围(作用域)</li>
<li>将对象的赋值为null</li>
</ul>
<p>​    <strong>注意:Java的垃圾回收器只能销毁new操作符创建的对象</strong><br>​    为了回收不通过new操作符来在内存中获取存储空间的对象,Java还提供object类中的finalize()方法被声明为protected,用户可以自己的类中定义这个方法来回收垃圾(不保证一定发生,当Java虚拟机内存耗尽时,则不会执行垃圾回收处理)<br>​    Java还提供了System.gc()方法强制启动垃圾回收器</p>

      
    </div>
</article>

    </li>
  
</ul>

  <section id="nav-wrapper">
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/tags/Java/page/2/">2</a><a class="extend next" rel="next" href="/tags/Java/page/2/">next »</a>
    </nav>
  </section>



            <footer>
    <div>© 2021 - nature </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>