<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>祈雨</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(/assets/blog.png)">
        </div>
    </section>
    <section class='menu'>
        <div>祈雨</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>  
          
            <a href="/about/" class="Btn">
              <li>About</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
            
                <a target="_blank" rel="noopener" href="https://github.com/Magician-Snow">
                    <img src="/assets/github.svg" />
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
    <header class='PageTitle'>
        <h1>{ SSM }</h1>
    </header>
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2023/04/25/Spring04/">Spring04</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2023-04-25T11:27:33.000Z" itemprop="datePublished">
    2023-04-25
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/SSM/">SSM</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="SpringMVC的数据的请求和响应"><a href="#SpringMVC的数据的请求和响应" class="headerlink" title="SpringMVC的数据的请求和响应"></a>SpringMVC的数据的请求和响应</h2><h4 id="1-SpringMVC的数据相应方式"><a href="#1-SpringMVC的数据相应方式" class="headerlink" title="1. SpringMVC的数据相应方式"></a>1. SpringMVC的数据相应方式</h4><p><strong>1. 页面跳转</strong></p>
<ul>
<li>直接返回字符串</li>
<li>通过ModelAndView对象返回</li>
</ul>
<p><strong>2.回写数据</strong></p>
<ul>
<li>直接返回字符串</li>
<li>返回对象或集合</li>
</ul>
<h4 id="2-页面跳转"><a href="#2-页面跳转" class="headerlink" title="2. 页面跳转"></a>2. 页面跳转</h4><p>​    <strong>(1).返回字符串形式</strong></p>
<p>​        此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9Vqgdx"><img src="https://s1.ax1x.com/2023/04/22/p9Vqgdx.png" alt="p9Vqgdx.png"></a></p>
<p>​    该种形式就是上面代码模拟的形式</p>
<p>​    <strong>(2).返回ModelAndView形式</strong></p>
<p>​    Model表示模型，作用为封装数据；View表示视图，作用为展示数据。在返回视图给页面时可以不携带数据，只展示视图</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9VOPjH"><img src="https://s1.ax1x.com/2023/04/22/p9VOPjH.png" alt="p9VOPjH.png"></a></p>
<p>​    modelAndView.setViewName(“页面路径”)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;/user/save/result&quot;</span>);<span class="comment">//默认为forward模式  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ModelAndView mv = new ModelAndView(&quot;redirect:/user/save/result&quot;);//redirect模式</span></span><br></pre></td></tr></table></figure>



<p>​    也可以为model设置数据，通过方法<code>modelAndView.addObject(键值对)</code></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9VOxqs"><img src="https://s1.ax1x.com/2023/04/22/p9VOxqs.png" alt="p9VOxqs.png"></a></p>
<p>​    当然也可以换一种方式，通过注入思想，直接在方法传递形参，因为本身方法是SpringMVC调用，所以在调用方法时自动创造形参相对应的对象</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9VxqTs"><img src="https://s1.ax1x.com/2023/04/22/p9VxqTs.png" alt="p9VxqTs.png"></a></p>
<p>​    在使用字符串形式时，也可以通过Model对象来传递参数，下面代码的model对象也是由SpringMVC自动创建</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9Vze1K"><img src="https://s1.ax1x.com/2023/04/22/p9Vze1K.png" alt="p9Vze1K.png"></a></p>
<h4 id="3-回写数据"><a href="#3-回写数据" class="headerlink" title="3. 回写数据"></a>3. 回写数据</h4><p>​    <strong>(1).直接返回字符串</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9VzXHH"><img src="https://s1.ax1x.com/2023/04/22/p9VzXHH.png" alt="p9VzXHH.png"></a></p>
<p>​    可以通过SpringMVC框架直接注入：通过形参声明response引用类型由SpringMVC分配对象</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ZSVEj"><img src="https://s1.ax1x.com/2023/04/22/p9ZSVEj.png" alt="p9ZSVEj.png"></a></p>
<p>​    注意：回写是不需要跳转，方法返回值为void</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ZSu80"><img src="https://s1.ax1x.com/2023/04/22/p9ZSu80.png" alt="p9ZSu80.png"></a></p>
<p>​    浏览器输入页面后得到回写的字符串</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ZSGVJ"><img src="https://s1.ax1x.com/2023/04/22/p9ZSGVJ.png" alt="p9ZSGVJ.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9Zpmee"><img src="https://s1.ax1x.com/2023/04/22/p9Zpmee.png" alt="p9Zpmee.png"></a></p>
<p>​    注意：该注解加在方法前，如果不加注解，SpringMVC会把返回的return的字符串当作跳转页面名称进行资源匹配</p>
<p>​    使用<code>@ResponseBody</code>注解进行字符串的回写</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9Zp5Sx"><img src="https://s1.ax1x.com/2023/04/22/p9Zp5Sx.png" alt="p9Zp5Sx.png"></a></p>
<p>​    上述回写字符串一般没什么意义，在实际开发中会回写json格式字符串，把某个实体类中存储的数据转换器json格式进行返回</p>
<p>​    首先在pom.xml导json相关的包，</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9Zx2Us"><img src="https://s1.ax1x.com/2023/04/23/p9Zx2Us.png" alt="p9Zx2Us.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ZxfCq"><img src="https://s1.ax1x.com/2023/04/23/p9ZxfCq.png" alt="p9ZxfCq.png"></a></p>
<p>​    通过新建对象ObjectMapper，并调用对象中方法<code>writeValueAsString(要转成json格式字符串的对象)</code>，进行转换</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ZxxxK"><img src="https://s1.ax1x.com/2023/04/23/p9ZxxxK.png" alt="p9ZxxxK.png"></a></p>
<p>​    <strong>(2).返回对象或者集合</strong></p>
<p>​    对于手动转型为字符串的操作，SpringMVC有提供自动转型的功能，但要实现该功能需要手动的进行配置</p>
<p>​    找处理器适配器<code>(org.springframework.web.servlet.HandlerAdapter)</code>中的<code>RequestMappingHandlerAdapter</code>，在这个类中提供有<code>setMessageConverters</code>方法指定多个消息转换器</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eFYtg"><img src="https://s1.ax1x.com/2023/04/23/p9eFYtg.png" alt="p9eFYtg.png"></a></p>
<p>​    在spring-mvc.xml文件中注入且<strong>修改处理器适配器的转换逻辑</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eiHln"><img src="https://s1.ax1x.com/2023/04/23/p9eiHln.png" alt="p9eiHln.png"></a></p>
<p>​    此时在java类只要传递对象SpringMVC就可以自动的把它转换为json格式</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eFkm6"><img src="https://s1.ax1x.com/2023/04/23/p9eFkm6.png" alt="p9eFkm6.png"></a></p>
<p>​    除了上述的spring-mvc.xml配置非常繁琐还可以通过如下方式简化配置</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ekC4g"><img src="https://s1.ax1x.com/2023/04/23/p9ekC4g.png" alt="p9ekC4g.png"></a></p>
<p>​    <strong>HandlerMapping(处理器映射器)，是SpringMVC中用来处理Request请求URL到具体Controller的，其自身也分成很多种类；</strong></p>
<p>​    <strong>HandlerAdapter(处理器适配器)，是SpringMVC中用来处理具体请求映射到具体方法的，其自身也分很多种类</strong></p>
<p>​    在spring-mvc.xml文件中配置注解驱动取代注入配置处理器适配器，注意：使用mvc的注解驱动需要导入命名空间和约束路径</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eF5B6"><img src="https://s1.ax1x.com/2023/04/23/p9eF5B6.png" alt="p9eF5B6.png"></a></p>
<p>​    导入完之后编写注解驱动</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eF29J"><img src="https://s1.ax1x.com/2023/04/23/p9eF29J.png" alt="p9eF29J.png"></a></p>
<h4 id="4-SpringMVC获得请求参数"><a href="#4-SpringMVC获得请求参数" class="headerlink" title="4. SpringMVC获得请求参数"></a>4. SpringMVC获得请求参数</h4><p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eAqOI"><img src="https://s1.ax1x.com/2023/04/23/p9eAqOI.png" alt="p9eAqOI.png"></a></p>
<p><strong>(1).获得基本类型参数</strong></p>
<p>​    Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配</p>
<p>​    注意：客户端请求任何参数都是字符串形式，但用了Spring框架可以帮你把数据进行自动转型</p>
<p>​    编写方法获得请求参数<code>localhost:8080/user/quick11?username=zhangsan&amp;age=18</code> </p>
<p>​    该方法有<code>@ResponBody</code>表示不进行页面跳转，返回值为void表示不回写数据，两个形参由于接收GET请求的参数</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eEyAf"><img src="https://s1.ax1x.com/2023/04/23/p9eEyAf.png" alt="p9eEyAf.png"></a></p>
<p><strong>(2).获得POJO类型参数</strong></p>
<p>​    Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eVAvd"><img src="https://s1.ax1x.com/2023/04/23/p9eVAvd.png" alt="p9eVAvd.png"></a></p>
<p><strong>(3).获得数组类型参数</strong></p>
<p>​    Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配</p>
<p>​    因为数组默认是打印地址，所以要使用<code>Arrays.asList()</code>方法打印</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eeA0I"><img src="https://s1.ax1x.com/2023/04/23/p9eeA0I.png" alt="p9eeA0I.png"></a></p>
<p><strong>(4).获得集合类型参数</strong></p>
<p>​    获得集合参数时，在编写方法时要将集合参数包装到一个POJO中，以POJO为形参才能够接收</p>
<p>​    封装的POJO一般叫做VO对象，为该对象生成get、set以及toString方法</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eQIbQ"><img src="https://s1.ax1x.com/2023/04/23/p9eQIbQ.png" alt="p9eQIbQ.png"></a></p>
<p>​    在提交数据时，需要使用form表单进行提交，name的属性值要与后端的值相同</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9elNZQ"><img src="https://s1.ax1x.com/2023/04/23/p9elNZQ.png" alt="p9elNZQ.png"></a></p>
<p>​    Controller业务中的方法vo来当作形参接收，vo与表单的userList[x]相对应</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9e3K3t"><img src="https://s1.ax1x.com/2023/04/23/p9e3K3t.png" alt="p9e3K3t.png"></a></p>
<p><strong>(5).获得ajax发送的集合类型参数</strong></p>
<p>​    当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用<code>@RequestBody</code>可以直接接收集合数据无需使用POJO进行包装</p>
<p>​    一般发生ajax请求除了可以使用原生的js外，还可以导入jQuery包</p>
<p>​    导入jQuery包，编写ajax请求</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eYsQ1"><img src="https://s1.ax1x.com/2023/04/23/p9eYsQ1.png" alt="p9eYsQ1.png"></a></p>
<p>​    服务端直接用集合来接收，方法参数前要加注解<code>@RequestBody</code></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eYLTS"><img src="https://s1.ax1x.com/2023/04/23/p9eYLTS.png" alt="p9eYLTS.png"></a></p>
<p>​    因为有静态资源访问的问题，需要在<code>spring-mvc.xml</code>文件下加一句话</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9etep9"><img src="https://s1.ax1x.com/2023/04/23/p9etep9.png" alt="p9etep9.png"></a></p>
<h4 id="5-SpringMVC获得请求参数-静态资源访问的开启"><a href="#5-SpringMVC获得请求参数-静态资源访问的开启" class="headerlink" title="5. SpringMVC获得请求参数-静态资源访问的开启"></a>5. SpringMVC获得请求参数-静态资源访问的开启</h4><p>​    如果不加静态资源设置spring-mvc.xml会使得访问不成功，原因是导入的jQuery文件找不到，因为在web.xml的文件中的前端控制器的配置是<code>/</code>，其是缺省的servlet，客户端发送请求找对应servlet进行处理，如果没有则全部交给缺省的进行处理，即下面代码中名字叫<code>DispatcherServlet</code>的servlet进行处理，但其内部进行虚拟路径的匹配，而jQuery.js也通过<code>@RequestMapping(&quot;/quick15&quot;)</code>进行匹配，但是没有，所以匹配不上</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eU9aT"><img src="https://s1.ax1x.com/2023/04/23/p9eU9aT.png" alt="p9eU9aT.png"></a></p>
<p>​    下面代码表示在SpringMVC框架中开放资源的访问权限，mapping表示映射地址，location表示哪个目录下的资源是对外开放的</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9etep9"><img src="https://s1.ax1x.com/2023/04/23/p9etep9.png" alt="p9etep9.png"></a></p>
<h4 id="6-请求数据乱码问题"><a href="#6-请求数据乱码问题" class="headerlink" title="6. 请求数据乱码问题"></a>6. 请求数据乱码问题</h4><p>​    Tomcat8.5的服务器，对于GET请求是不会乱码的，但POST请求对于中文会出现乱码问题</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9edQvd"><img src="https://s1.ax1x.com/2023/04/23/p9edQvd.png" alt="p9edQvd.png"></a></p>
<p>​    在web.xml文件中配置一个全局过滤器，并配置过滤器以那种方式进行编码，<code>&lt;filter-mapping&gt;</code> 配置对什么资源进行过滤，<code>/*</code>表示对所有的资源进行过滤</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ed2PU"><img src="https://s1.ax1x.com/2023/04/23/p9ed2PU.png" alt="p9ed2PU.png"></a></p>
<h4 id="7-参数绑定注解-requestParam"><a href="#7-参数绑定注解-requestParam" class="headerlink" title="7. 参数绑定注解@requestParam"></a>7. 参数绑定注解<code>@requestParam</code></h4><p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ewnZq"><img src="https://s1.ax1x.com/2023/04/23/p9ewnZq.png" alt="p9ewnZq.png"></a></p>
<p>​    实际意思就是，请求参数xxx与Controller中的业务方法的参数名称要不一致时，可以在Controller中的业务方法的参数名称使用<code>@requestParam(value=&quot;xxx&quot;)</code>绑定请求参数xxx，且该注解如果只有一个属性可以省略value</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9e0l7t"><img src="https://s1.ax1x.com/2023/04/23/p9e0l7t.png" alt="p9e0l7t.png"></a></p>
<h4 id="8-获得Restful风格的参数"><a href="#8-获得Restful风格的参数" class="headerlink" title="8. 获得Restful风格的参数"></a>8. 获得Restful风格的参数</h4><p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eW8SI"><img src="https://s1.ax1x.com/2023/04/23/p9eW8SI.png" alt="p9eW8SI.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eWNm8"><img src="https://s1.ax1x.com/2023/04/23/p9eWNm8.png" alt="p9eWNm8.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eWy60"><img src="https://s1.ax1x.com/2023/04/23/p9eWy60.png" alt="p9eWy60.png"></a></p>
<p>​    上述url地址/user/1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用<code>@PathVariable</code>注解进行占位符的匹配获取工作</p>
<p>​    在<code>@RequestMapping(&quot;/quick/&#123;xxxx&#125;&quot;)</code>来进行占位符的声明，用<code>@PathVariable(value=&quot;xxxx&quot;)</code>来获取占位符对应的参数，<strong>xxxx必须完全匹配</strong>，并把参数赋值给方法的形参</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9efENQ"><img src="https://s1.ax1x.com/2023/04/23/p9efENQ.png" alt="p9efENQ.png"></a></p>
<h4 id="9-自定义类型转换器"><a href="#9-自定义类型转换器" class="headerlink" title="9. 自定义类型转换器"></a>9. 自定义类型转换器</h4><p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9efqvq"><img src="https://s1.ax1x.com/2023/04/23/p9efqvq.png" alt="p9efqvq.png"></a></p>
<p><strong>自定义类型转换器的开发步骤：</strong></p>
<ol>
<li>定义转换器类实现Converter接口(SpringMVC提供的转换器接口)</li>
<li>在Spring-mvc.xml配置文件中声明转换器</li>
<li>在<code>&lt;annotation-driven&gt;</code> 中引用转换器</li>
</ol>
<p>​    <code>Converter&lt;S,T&gt;</code>接口，要实现泛型，S代表要转换前的类型，后面的T代表要转成的类型，在该接口中有一个未实现方法convert需要实现，参数是S，返回值为T</p>
<p>​    新建一个DateConverter的实现类，实现converter接口</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9e5YCQ"><img src="https://s1.ax1x.com/2023/04/23/p9e5YCQ.png" alt="p9e5YCQ.png"></a></p>
<p>​    在Spring-mvc.xml配置文件中声明转换器，<code>&lt;list&gt;</code>中为刚刚自定义转换器类的全限定名 <a target="_blank" rel="noopener" href="https://imgse.com/i/p9e5wD0"><img src="https://s1.ax1x.com/2023/04/23/p9e5wD0.png" alt="p9e5wD0.png"></a></p>
<p>​    通过指定转换器工厂帮产生日期转换器，传刚刚注入的id值</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9e5hb6"><img src="https://s1.ax1x.com/2023/04/23/p9e5hb6.png" alt="p9e5hb6.png"></a></p>
<h4 id="10-获得Servlet相关API"><a href="#10-获得Servlet相关API" class="headerlink" title="10. 获得Servlet相关API"></a>10. 获得Servlet相关API</h4><p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9e73ss"><img src="https://s1.ax1x.com/2023/04/23/p9e73ss.png" alt="p9e73ss.png"></a></p>
<p>​    获取方式为，在想要使用的方法的形参进行注入，因为方法是框架调用，所以SpringMVC框架会帮你生成引用类型对应的对象</p>
<p>​    这个知识点前面有使用过</p>
<h4 id="11-获得请求头信息"><a href="#11-获得请求头信息" class="headerlink" title="11. 获得请求头信息"></a>11. 获得请求头信息</h4><p>​    请求头是键值对形式</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ebDV1"><img src="https://s1.ax1x.com/2023/04/23/p9ebDV1.png" alt="p9ebDV1.png"></a></p>
<p>​    注意：required的取值为true或者false，表示访问资源时是否要携带指定的请求头</p>
<p>​    <strong>网页的请求头</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ebbRS"><img src="https://s1.ax1x.com/2023/04/23/p9ebbRS.png" alt="p9ebbRS.png"></a></p>
<p>​    获得请求头User-Agent请求头携带的信息，<code>@RequestHeader</code>的value对应的值要与网页的一致</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eqAsJ"><img src="https://s1.ax1x.com/2023/04/23/p9eqAsJ.png" alt="p9eqAsJ.png"></a></p>
<p>​    由于Cookie比较特殊，所以有如下注解获得Cookie对应的信息</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eqJeA"><img src="https://s1.ax1x.com/2023/04/23/p9eqJeA.png" alt="p9eqJeA.png"></a></p>
<p>​    使用<code>@CookieValue</code>获得cookie值</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9eq6wn"><img src="https://s1.ax1x.com/2023/04/23/p9eq6wn.png" alt="p9eq6wn.png"></a></p>
<h4 id="12-文件上传"><a href="#12-文件上传" class="headerlink" title="12. 文件上传"></a>12. 文件上传</h4><p><strong>文件上传客户端三要素</strong></p>
<pre><code>1. 表单项`type=&quot;file&quot;`

   2. 表单的提交方式是`POST`
   3. 表单的enctype属性是多部分表单形式，及`enctype=&quot;multipart/form-data&quot;`</code></pre>
<p>​    创建upload.jsp文件，编写文件上传表单</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9mUl9g"><img src="https://s1.ax1x.com/2023/04/24/p9mUl9g.png" alt="p9mUl9g.png"></a></p>
<p><strong>文件上传原理</strong></p>
<ul>
<li>当form表单修改为多部份表单时，request.getParameter()将失效</li>
<li>enctype=<code>&quot;application/x-www-form-urlencoded&quot;</code>时，form表单的正文格式是：<code>key=value&amp;key=value&amp;key=value</code>，即键值对格式，这种方法也是form表单的默认提交格式</li>
<li>当form表单的enctype取值为Mutilpart/form-data时，请求正文内容就变成多部分形式：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ma0dP"><img src="https://s1.ax1x.com/2023/04/24/p9ma0dP.png" alt="p9ma0dP.png"></a></p>
<p><strong>单文件上传步骤</strong></p>
<pre><code>1. 导入fileupload和io坐标

   2. 配置文件上传解析器，**应该这个xml文件也是由之前的`&lt;mvc-annotation-driven&gt;`解析的，这是我的猜测待考证**
   3. 编写文件上传代码</code></pre>
<p>​    在pom.xml导入fileupload和io坐标</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9mdEwt"><img src="https://s1.ax1x.com/2023/04/24/p9mdEwt.png" alt="p9mdEwt.png"></a></p>
<p>​    在spring-mvc.xml文件中配置文件上传解析器</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9mdXcQ"><img src="https://s1.ax1x.com/2023/04/24/p9mdXcQ.png" alt="p9mdXcQ.png"></a></p>
<p>​    在后台代码中，<strong>形参设置时应该与请求参数(form表单传递过来的参数)相一致</strong>，只不过传递的文件会被SpringMVC封装为一个叫MultipartFile类型的对象，其名字应该与form表单中file的name属性值一致</p>
<p>​    在后台代码接收前面upload.jsp中form表单传递的值</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9m0QZn"><img src="https://s1.ax1x.com/2023/04/24/p9m0QZn.png" alt="p9m0QZn.png"></a></p>
<p>​    除了打印，将接收到的文件转存到磁盘某个位置(未来有服务器可以存到网络地址)，<code>getOriginaFilename()</code>作用为获得上传文件的文件名</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9mBFOJ"><img src="https://s1.ax1x.com/2023/04/24/p9mBFOJ.png" alt="p9mBFOJ.png"></a></p>
<p><strong>多文件上传步骤</strong></p>
<p>​    与单文件上传一样，注意后台形参接收时与请求参数一致就行</p>
<p>​    如果前台<code>&lt;input type=&quot;file&quot; name =&quot;xxx&quot;&gt;</code> 多个name的属性值一样，那么后台使用数组接收就行，注意：数组名应与name属性值一致</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9mB7A1"><img src="https://s1.ax1x.com/2023/04/24/p9mB7A1.png" alt="p9mB7A1.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9mBbh6"><img src="https://s1.ax1x.com/2023/04/24/p9mBbh6.png" alt="p9mBbh6.png"></a></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2023/04/25/Spring03/">Spring03</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2023-04-25T11:24:27.000Z" itemprop="datePublished">
    2023-04-25
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/SSM/">SSM</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="监听器的使用与Spring集成Web环境"><a href="#监听器的使用与Spring集成Web环境" class="headerlink" title="监听器的使用与Spring集成Web环境"></a>监听器的使用与Spring集成Web环境</h2><h4 id="1-应用上下文的创建"><a href="#1-应用上下文的创建" class="headerlink" title="1. 应用上下文的创建"></a>1. 应用上下文的创建</h4><p>​    因为上下文对象是通过<code>new ClasspathXmlApplicationContext(Spring配置文件)</code>获得，但每一次获取Bean时都要编写一次，这样会使得上下文对象创建多次</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9ipmxH"><img src="https://s1.ax1x.com/2023/04/18/p9ipmxH.png" alt="p9ipmxH.png"></a></p>
<p>​    <strong>思想：将创建上下文对象的行为放在监听器中，并由监听器存储在ServletContext域中，需要使用对象时，通过ServletContext对象向ServletContext域中获取</strong></p>
<p>​    <strong>监听器的配置</strong></p>
<p>​    新建java文件，继承实现监听servletContext的接口</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9i9MpF"><img src="https://s1.ax1x.com/2023/04/18/p9i9MpF.png" alt="p9i9MpF.png"></a></p>
<p>​    需要在web.xml文件，编写配置告知tomcat有这个监听器</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9i9JTx"><img src="https://s1.ax1x.com/2023/04/18/p9i9JTx.png" alt="p9i9JTx.png"></a></p>
<p>​    从容器中获取上下文对象</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9i9hcQ"><img src="https://s1.ax1x.com/2023/04/18/p9i9hcQ.png" alt="p9i9hcQ.png"></a></p>
<h4 id="2-监听器的优化"><a href="#2-监听器的优化" class="headerlink" title="2. 监听器的优化"></a>2. 监听器的优化</h4><p>​    使用web.xml配置**全局初始化参数<code>&lt;context-param&gt;</code> **，<code>&lt;param-name&gt;</code>写自定义的名字，<code>&lt;param-value&gt;</code> 写名字对应的值</p>
<p>​    web.xml文件配置参数</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9iCPN6"><img src="https://s1.ax1x.com/2023/04/18/p9iCPN6.png" alt="p9iCPN6.png"></a></p>
<p>​    java文件来读取参数</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9iCA3D"><img src="https://s1.ax1x.com/2023/04/18/p9iCA3D.png" alt="p9iCA3D.png"></a></p>
<p>​    新建一个工具类将具体的名字，像代码中的<code>&quot;app&quot;</code>给隐藏掉，即当需要对象时直接给对象而不是通过名字获取对象，其实本质就是把那句话变成一个方法返回值，就是一个封装</p>
<p>​    工具类封装</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EUBNQ"><img src="https://s1.ax1x.com/2023/04/21/p9EUBNQ.png" alt="p9EUBNQ.png"></a></p>
<p>​    调用类直接使用，doGet为收到GET请求后调用</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EaFDf"><img src="https://s1.ax1x.com/2023/04/21/p9EaFDf.png" alt="p9EaFDf.png"></a></p>
<h4 id="3-Spring提供上述监听器获取应用上下文工具"><a href="#3-Spring提供上述监听器获取应用上下文工具" class="headerlink" title="3. Spring提供上述监听器获取应用上下文工具"></a>3. Spring提供上述监听器获取应用上下文工具</h4><p>​    上面代码有个同名监听器是仿的，目的是要领会监听器内部的实现</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EdDln"><img src="https://s1.ax1x.com/2023/04/21/p9EdDln.png" alt="p9EdDln.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9Ed4p9"><img src="https://s1.ax1x.com/2023/04/21/p9Ed4p9.png" alt="p9Ed4p9.png"></a></p>
<p>​    在pom.xml文件导入spring-web坐标</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EdLkD"><img src="https://s1.ax1x.com/2023/04/21/p9EdLkD.png" alt="p9EdLkD.png"></a></p>
<p>​    在web.xml文件下配置监听器，并设置全局初始化参数，因为要获取的是resource下的spring的xml文件的上下文，路径为<code>classpath:XXXX.xml</code></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EwUnx"><img src="https://s1.ax1x.com/2023/04/21/p9EwUnx.png" alt="p9EwUnx.png"></a></p>
<p>​    通过调用Spring监听器对象提供的方法，如上面写的假的监听器一样，这个方法是static的，获得上下文对象</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EwvUU"><img src="https://s1.ax1x.com/2023/04/21/p9EwvUU.png" alt="p9EwvUU.png"></a></p>
<h4 id="4-SpringMVC的概述"><a href="#4-SpringMVC的概述" class="headerlink" title="4. SpringMVC的概述"></a>4. SpringMVC的概述</h4><p>​    SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架，<strong>SpringMVC是属于管项目的web层的</strong></p>
<p>​    将共有行为抽取出来，由框架封装</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9E5Xlt"><img src="https://s1.ax1x.com/2023/04/21/p9E5Xlt.png" alt="p9E5Xlt.png"></a></p>
<p>​    <strong>SpringMVC的使用</strong></p>
<pre><code>1. 导入SpringMVC包

   2. 配置Servlet，先找共有行为再找特有行为
   3. 编写POJO(普通JavaBean)，也称为Controller
   4. 通过注解把POJO放到Spring容器中
   5. 配置spring-mvc.xml文件(配置组件扫描)
   6. 执行访问测试</code></pre>
<p>​    在pom.xml文件导入SpringMVC包</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EID1I"><img src="https://s1.ax1x.com/2023/04/21/p9EID1I.png" alt="p9EID1I.png"></a></p>
<p>​    在web.xml中配置SpringMVC的前端控制器<code>&lt;servlet&gt;</code> ，<code>&lt;load-on-startup&gt;</code> 代表服务器启动时就去加载servlet，不配置则默认为第一次访问时创建对象；<code>&lt;servlet-mapping&gt;</code>为映射地址，  <code>&lt;url-pattern&gt;/&lt;url-pattern&gt;</code>，这个<code>/</code>表示缺省的servlet，即每次访问任何请求都要走这个servlet，也有<code>*.xxx</code>为扩展名为<code>*.xxx</code>时才走这个servlet</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EI53n"><img src="https://s1.ax1x.com/2023/04/21/p9EI53n.png" alt="p9EI53n.png"></a></p>
<p>​    创建Controller的Java包，return后接要跳转的jsp，用注解将UserController存入spring容器中，注解<code>@RequestMapping(&quot;/quick&quot;)</code>为请求映射，当访问quick时映射到save方法，执行方法的逻辑</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EHSvn"><img src="https://s1.ax1x.com/2023/04/21/p9EHSvn.png" alt="p9EHSvn.png"></a></p>
<p>​    创建Spring的xml文件，进行组件扫描    </p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9E7HDP"><img src="https://s1.ax1x.com/2023/04/21/p9E7HDP.png" alt="p9E7HDP.png"></a></p>
<p>​    配置组件扫描的这个xml文件没有加载，所以最先是<code>new ClassPathXmlApplicationContext(&quot;参数为resource文件夹的xml文件路径&quot;)</code>，限制是spring，所以只需要在前端控制器声明有这个配置文件，<code>&lt;init-param&gt;</code> 代表servlet在初始化时执行，<code>&lt;param-name&gt;</code> 是监听器的名字，<code>&lt;param-value&gt;</code> 是路径</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9EHart"><img src="https://s1.ax1x.com/2023/04/21/p9EHart.png" alt="p9EHart.png"></a></p>
<h4 id="5-SpringMVC的执行流程解析"><a href="#5-SpringMVC的执行流程解析" class="headerlink" title="5. SpringMVC的执行流程解析"></a>5. SpringMVC的执行流程解析</h4><p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9VNbaF"><img src="https://s1.ax1x.com/2023/04/22/p9VNbaF.png" alt="p9VNbaF.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9VNzKx"><img src="https://s1.ax1x.com/2023/04/22/p9VNzKx.png" alt="p9VNzKx.png"></a></p>
<h4 id="6-SpringMVC的组件解析"><a href="#6-SpringMVC的组件解析" class="headerlink" title="6. SpringMVC的组件解析"></a>6. SpringMVC的组件解析</h4><p><code>@RequestMapping</code></p>
<p><strong>作用：</strong>用于建立请求URL和处理请求方法之间的对应关系</p>
<p><strong>位置：</strong></p>
<ul>
<li><p>类上，请求URL的第一级访问目录，此处不写的话，就相当于根目录</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9VaD78"><img src="https://s1.ax1x.com/2023/04/22/p9VaD78.png" alt="p9VaD78.png"></a></p>
</li>
<li><p>方法上，请求URL的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9VaOj1"><img src="https://s1.ax1x.com/2023/04/22/p9VaOj1.png" alt="p9VaOj1.png"></a></p>
<p>这个方式是为了区分是哪个模块的方法，此时return方法返回的是<code>http://localhost:8080/xxx/</code>下的<code>success.jsp</code>页面，如果jsp文件路径不对会报404，可以改为带<code>/success.jsp</code>表示要在当前web应用下找这个资源</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9Vd25D"><img src="https://s1.ax1x.com/2023/04/22/p9Vd25D.png" alt="p9Vd25D.png"></a></p>
</li>
</ul>
<p><strong>属性：</strong></p>
<ul>
<li>value：用于指定请求的URL，在只有value的情况下可以省略，但多个属性不能省如上面代码完整的应该为<code>@RequestMapping(value=&quot;/quick&quot;)</code></li>
<li>method：用于指定请求的方式，默认是GET，如果要改为POST，它存储方式是枚举类型为<code>@RequestMapping(value=&quot;/quick&quot;,method=RequestMethod.POST)</code>，注意：jsp表单提交是GET类型的，设置成POST会报错</li>
<li>params：用于指定限制请求参数的条件，它支持简单的表达式，要求请求参数的key和value必须和配置的一模一样<ul>
<li><code>params=&#123;&quot;accountName&quot;&#125;</code>，表示请求参数必须有accountName，没有这个参数则该资源不能被你访问</li>
<li><code>params=&#123;&quot;money!100&quot;&#125;</code>，表示请求参数中money不能是100</li>
</ul>
</li>
</ul>
<h4 id="7-SpringMVC的组件扫描"><a href="#7-SpringMVC的组件扫描" class="headerlink" title="7. SpringMVC的组件扫描"></a>7. SpringMVC的组件扫描</h4><p>​    springMVC是管理web层的，所以组件扫描时，只扫描web层相关，而其他的像dao层、service层归Spring来扫描</p>
<p>​    为了让只扫springmvc，可以在其配置的xml文件中进行如下设置</p>
<p>​    <code>include-filter</code>表示包括如果改为<code>exclude-filter</code>表示不包括，<code>type=&quot;annotation&quot;</code>表示扫描类型为注解，expression=”注解的全限定名”</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9V0b9g"><img src="https://s1.ax1x.com/2023/04/22/p9V0b9g.png" alt="p9V0b9g.png"></a></p>
<h4 id="8-SpringMVC的xml文件配置"><a href="#8-SpringMVC的xml文件配置" class="headerlink" title="8. SpringMVC的xml文件配置"></a>8. SpringMVC的xml文件配置</h4><p>​    有点难，可以反复看<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1WZ4y1P7Bp/?p=49&spm_id_from=pageDriver&vd_source=41e90cead08809b70890e8713c58ac8b">13-SpringMVC组件解析-SpringMVC的XML配置解析（资源解析器）_哔哩哔哩_bilibili</a></p>
<p>​    可以自行配置视图解析器，配置完后方法return时指定页面就可以少写页面的前缀和后缀</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9VBXGD"><img src="https://s1.ax1x.com/2023/04/22/p9VBXGD.png" alt="p9VBXGD.png"></a></p>
<h4 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h4><p>​    <a target="_blank" rel="noopener" href="https://imgse.com/i/p9VDMd0"><img src="https://s1.ax1x.com/2023/04/22/p9VDMd0.png" alt="p9VDMd0.png"></a></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2023/04/25/Spring02/">Spring02</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2023-04-25T11:22:16.000Z" itemprop="datePublished">
    2023-04-25
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/SSM/">SSM</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="数据库连接池与Spring注解"><a href="#数据库连接池与Spring注解" class="headerlink" title="数据库连接池与Spring注解"></a>数据库连接池与Spring注解</h2><h4 id="1-数据源-连接池-的作用"><a href="#1-数据源-连接池-的作用" class="headerlink" title="1. 数据源(连接池)的作用"></a>1. 数据源(连接池)的作用</h4><ul>
<li>提高程序性能</li>
<li>实例化数据源，初始化部分连接资源</li>
<li>使用连接资源时从数据源中获取</li>
<li>使用完毕后连接资源归还给数据源</li>
</ul>
<p>​    常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等</p>
<h4 id="2-数据源的开发步骤"><a href="#2-数据源的开发步骤" class="headerlink" title="2. 数据源的开发步骤"></a>2. 数据源的开发步骤</h4><pre><code>1. 导入数据源的坐标(jar)和数据库驱动坐标(jar)
   2. 创建数据源对象
   3. 设置数据源的基本连接数据库的数据
   4. 使用数据源获取连接资源和归还连接资源</code></pre>
<p>​    在pom.xml文件中导入坐标，mysql、c3p0、druid</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppOCFxS"><img src="https://s1.ax1x.com/2023/04/11/ppOCFxS.png" alt="ppOCFxS.png"></a></p>
<p>​    在java代码，创建c3p0数据源对象，以及给对应数据库的参数，获取数据库连接对象</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppOCdG6"><img src="https://s1.ax1x.com/2023/04/11/ppOCdG6.png" alt="ppOCdG6.png"></a></p>
<p>​    番外：创建druid数据源对象</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppOCHds"><img src="https://s1.ax1x.com/2023/04/11/ppOCHds.png" alt="ppOCHds.png"></a></p>
<h4 id="3-数据库参数的提取"><a href="#3-数据库参数的提取" class="headerlink" title="3. 数据库参数的提取"></a>3. 数据库参数的提取</h4><p>​    在上述数据库配置时，代码是耦合的，为了降低耦合需要将数据库参数字符串单独提取到一个(<code>XXXXX.properties</code>)文件存放</p>
<p>​    在resource文件夹下创建jdbc.properties文件</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppjkMkQ"><img src="https://s1.ax1x.com/2023/04/12/ppjkMkQ.png" alt="ppjkMkQ.png"></a></p>
<p>​    加载.properties文件来连接数据库，通过Java提供的ResourceBundle类以及该类提供的getBundle(“.properties文件的类加载路径，且该文件不需要写扩展名”)方法，来导入.properties文件。通过ResourceBundle对象的getString(“.properties文件中定义的key值”)，来获得对应的字符串</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppjA7G9"><img src="https://s1.ax1x.com/2023/04/12/ppjA7G9.png" alt="ppjA7G9.png"></a></p>
<h4 id="4-Spring产生数据源对象"><a href="#4-Spring产生数据源对象" class="headerlink" title="4. Spring产生数据源对象"></a>4. Spring产生数据源对象</h4><p>​    对于c3p0连接池的对象dataSource的创建使用Spring容器完成</p>
<p>​    创建xml文件把CombopooledDataSource类进行注入，并通过类中已编写的set方法(该类为第三方jar包的)注入参数</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppjEfSA"><img src="https://s1.ax1x.com/2023/04/12/ppjEfSA.png" alt="ppjEfSA.png"></a></p>
<p>​    java文件完成对Spring的加载以及对数据库对象的打印</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppjVV61"><img src="https://s1.ax1x.com/2023/04/12/ppjVV61.png" alt="ppjVV61.png"></a></p>
<h4 id="5-进一步优化，Spring抽取jdbc配置文件"><a href="#5-进一步优化，Spring抽取jdbc配置文件" class="headerlink" title="5. 进一步优化，Spring抽取jdbc配置文件"></a>5. 进一步优化，Spring抽取jdbc配置文件</h4><p>​     在spring的xml文件中加载.properties文件获得连接信息</p>
<p>​    需要引入命名空间(beans标签下直接引入)和约束路径(在属性<code>xsi:schemaLocation</code>下作为属性值引入)</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppz0y8S"><img src="https://s1.ax1x.com/2023/04/14/ppz0y8S.png" alt="ppz0y8S.png"></a></p>
<p>​    加载properties文件，其中<code>classpath:</code>表示该文件在类加载路径下</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppzBZIP"><img src="https://s1.ax1x.com/2023/04/14/ppzBZIP.png" alt="ppzBZIP.png"></a></p>
<p>​    引入.properties文件中对应的值，通过<code>$&#123;&#125;</code>来引入</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppzBvLj"><img src="https://s1.ax1x.com/2023/04/14/ppzBvLj.png" alt="ppzBvLj.png"></a></p>
<h4 id="6-Spring注解开发"><a href="#6-Spring注解开发" class="headerlink" title="6. Spring注解开发"></a>6. Spring注解开发</h4><p>​    Spring是轻代码重配置的框架，配置比较繁重影响开发效率，所以注解开发时一种趋势，注解代替xml配置文件可以简化配置，提高开发效率</p>
<h4 id="7-Spring的原始注解-老一点注解"><a href="#7-Spring的原始注解-老一点注解" class="headerlink" title="7. Spring的原始注解(老一点注解)"></a>7. Spring的原始注解(老一点注解)</h4><p>​    Spring原始注解主要是代替<code>&lt;Bean&gt;</code> 的配置</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9SdWjJ"><img src="https://s1.ax1x.com/2023/04/14/p9SdWjJ.png" alt="p9SdWjJ.png"></a></p>
<p>​    <strong>使用原始注解可以对xml文件内编写的内容进行替代，如果要使用注解需要在Spring的xml文件中进行声明</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9pMbDS"><img src="https://s1.ax1x.com/2023/04/15/p9pMbDS.png" alt="p9pMbDS.png"></a></p>
<p>​    <code>base-package=&quot;包名&quot;</code>，其会扫描该包下所有的子包，包下所有使用了注解的都会被扫描到</p>
<p>​    使用注解<code>@Component（&quot;唯一标识&quot;）</code>等同于对xml文件中的bean的配置，在需要Spring配置的类的上方写注解</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9pKqYR"><img src="https://s1.ax1x.com/2023/04/15/p9pKqYR.png" alt="p9pKqYR.png"></a></p>
<p>​    如果需要进行注入，则可以使用<code>@Autowired</code>和<code>@Qualifier(&quot;要注入的对象&quot;)</code>进行注入，注入代码需要写在类的里面</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9pMJXT"><img src="https://s1.ax1x.com/2023/04/15/p9pMJXT.png" alt="p9pMJXT.png"></a></p>
<p>​    在Spring的xml文件中配置组件扫描</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9pQ85d"><img src="https://s1.ax1x.com/2023/04/15/p9pQ85d.png" alt="p9pQ85d.png"></a></p>
<h4 id="8-原始注解详解"><a href="#8-原始注解详解" class="headerlink" title="8. 原始注解详解"></a>8. 原始注解详解</h4><p><strong>1. 代码的可读性</strong></p>
<p>​    在不同的层中都使用@Component会造成代码可读性下降，为了让可读性增加有了<code>@Controller</code>—web层；<code>@Service</code>—service层；<code>@Repository</code>—dao层，功能都是一样的只是方便读代码</p>
<p><strong>2. set方法的省略</strong></p>
<p>​    如果使用的是注解方式进行Spring配置，则可以省略set方法，因为注解直接写在java文件的属性上，所以不需要为属性再写set方法</p>
<p>​    </p>
<p><strong>3. <code>@Autowired</code>和<code>@Qualifier</code>的区别，以及注解<code>@Resource</code></strong></p>
<p>​    <code>@Autowired</code>是按照数据类型从Spring容器中进行匹配</p>
<p>​    如下面代码，其会在Spring容器中寻找一个UserDao类型的对象赋值给变量userDao</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure>



<p>​    <code>@Qualifier</code>是按照id值从容器中进行匹配，但其要结合<code>@Autowired</code>一起使用</p>
<p>​    <code>@Resource(name=&quot;id值&quot;)</code>，其相当于上述两个注解一起使用</p>
<p><strong>4. <code>@Value</code></strong></p>
<p>​    <code>@Value(&quot;要注入的值&quot;)</code>是对常量数据进行注入</p>
<p>​    对变量driver进行注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;itcast&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String driver;</span><br></pre></td></tr></table></figure>

<p>​    除了注入常量还可以注入键值对，只要Spring容器中加载了.properties文件就可以直接通过<code>$&#123;&#125;</code>进行注入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;jdbc.drive&#125;&quot;)</span><br><span class="line">private String driver;</span><br></pre></td></tr></table></figure>



<p><strong>5. <code>@Scope</code></strong></p>
<p>​    <code>@Scope(&quot;属性值&quot;)</code>，具体属性值见笔记<code>Spring01.md</code>，其写在类的上方，用来指定<code>&lt;bean&gt;</code> 是可以创造单例还是多例</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9pyj3t"><img src="https://s1.ax1x.com/2023/04/15/p9pyj3t.png" alt="p9pyj3t.png"></a></p>
<p><strong>6. <code>@PostConstruct</code>和<code>@preDestroy</code></strong></p>
<p>​    写在类中的方法前，表示对象在创建或者销毁时要执行的方法</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9p6l59"><img src="https://s1.ax1x.com/2023/04/15/p9p6l59.png" alt="p9p6l59.png"></a></p>
<h4 id="9-Spring新注解"><a href="#9-Spring新注解" class="headerlink" title="9. Spring新注解"></a>9. Spring新注解</h4><p>​    原始注解不能完全代替xml配置文件，还需要使用注解替代的配置如下：</p>
<ul>
<li>非自定义的Bean的配置：如第三方jar包中的类</li>
<li>加载properties文件的配置：<code>&lt;context:property-placeholder&gt;</code></li>
<li>组件扫描的配置：<code>&lt;context:component-scan&gt;</code></li>
<li>引入其他文件：<code>&lt;import&gt;</code> </li>
</ul>
<p>​    Spring新注解 </p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9p6xi9"><img src="https://s1.ax1x.com/2023/04/15/p9p6xi9.png" alt="p9p6xi9.png"></a></p>
<h4 id="10-Spring新注解详解"><a href="#10-Spring新注解详解" class="headerlink" title="10. Spring新注解详解"></a>10. Spring新注解详解</h4><p>​    通过新建一个java类并在类中使用新注解来替代spring的xml文件</p>
<p><strong>1. <code>@Configuration</code></strong></p>
<p>​    写在类前标志该类为Spring核心配置类</p>
<p><strong>2. <code>@ComponentScan(&quot;包名&quot;)</code></strong></p>
<p>​    相当于xml文件中的配置组件扫描</p>
<p><strong>3. <code>@PropertySource(&quot;路径&quot;)</code></strong></p>
<p>​    <code>@PropertySource(&quot;路径&quot;)</code>为导入.properties文件到Spring容器中</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p99RpcR"><img src="https://s1.ax1x.com/2023/04/16/p99RpcR.png" alt="p99RpcR.png"></a></p>
<p><strong>4. <code>@Bean(&quot;自己设定的id&quot;)</code></strong></p>
<p>​    <code>@Bean(&quot;自己设定的id&quot;)</code>写在方法前，用于将当前方法的返回值以自己设定的id名称存储到Spring容器中</p>
<p>​    下图代码已经将.properties文件抽取到Spring容器中，但是<code>$&#123;&#125;</code>是在xml文件中才可以这样写，所以需要使用<code>@value</code>来获取.properties文件的值，这个代码返回了数据库连接池c3p0的对象</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p99RqxA"><img src="https://s1.ax1x.com/2023/04/16/p99RqxA.png" alt="p99RqxA.png"></a></p>
<p><strong>5. <code>@Import(&quot;需要加载的类的名字.class&quot;)</code></strong></p>
<p>​    其本质是一个数组，可以一次多个添加</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p99Wco8"><img src="https://s1.ax1x.com/2023/04/16/p99Wco8.png" alt="p99Wco8.png"></a></p>
<h4 id="11-main方法对于使用注解-配置类-后的加载"><a href="#11-main方法对于使用注解-配置类-后的加载" class="headerlink" title="11. main方法对于使用注解(配置类)后的加载"></a>11. main方法对于使用注解(配置类)后的加载</h4><p>​    因为之前充当web测试的main方法它引入的是xml文件，所以应改为<code>AnnotationConfigApplicationContext(要引入的类名.class)</code></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p99f9w6"><img src="https://s1.ax1x.com/2023/04/16/p99f9w6.png" alt="p99f9w6.png"></a></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2023/04/25/Spring01/">Spring01</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2023-04-25T11:20:13.000Z" itemprop="datePublished">
    2023-04-25
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/SSM/">SSM</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h2 id="Spring开发入门"><a href="#Spring开发入门" class="headerlink" title="Spring开发入门"></a>Spring开发入门</h2><h4 id="1-传统Javaweb开发的困惑与解决方案"><a href="#1-传统Javaweb开发的困惑与解决方案" class="headerlink" title="1. 传统Javaweb开发的困惑与解决方案"></a>1. 传统Javaweb开发的困惑与解决方案</h4><p>问题1：传统javaweb的开发中对于数据的操作，往往都需要new对象来完成操作</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppbxDFU"><img src="https://s1.ax1x.com/2023/04/10/ppbxDFU.png" alt="ppbxDFU.png"></a></p>
<pre><code>解决思路：程序代码中不去new对象，第三方根据要求为程序提供需要的Bean对象</code></pre>
<p>问题2：事物功能、日志功能耦合在业务代码中</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppbxrYF"><img src="https://s1.ax1x.com/2023/04/10/ppbxrYF.png" alt="ppbxrYF.png"></a></p>
<pre><code>解决思路：第三方提供Bean对象的**代理对象(BeanProxy)**，该对象是对Bean的增强，可以完成事物操作</code></pre>
<h4 id="2-IoC、DI、AOP思想"><a href="#2-IoC、DI、AOP思想" class="headerlink" title="2. IoC、DI、AOP思想"></a>2. IoC、DI、AOP思想</h4><pre><code>IoC思想：控制反转，强调的是原来在程序中创建Bean的权利反转给第三方

DI思想：依赖注入，强调的Bean之间关系，这种关系第三方负责去设置

AOP思想：面向切面编程，功能的横向抽取，主要的实现方式是Proxy。(面向对象编程是纵向设计一个Bean)</code></pre>
<h4 id="3-框架概念"><a href="#3-框架概念" class="headerlink" title="3. 框架概念"></a>3. 框架概念</h4><pre><code>框架是基于基础技术之上，从众多业务中抽取出的通用解决方案，可以提升开发效率，并且框架具备扩展性</code></pre>
<h4 id="4-Spring的简介"><a href="#4-Spring的简介" class="headerlink" title="4.Spring的简介"></a>4.Spring的简介</h4><pre><code>spring是分层的JavaSE/EE应用full-stack轻量级开源框架，以Ioc(反转控制)和AOP(面向切面编程)为内核</code></pre>
<h4 id="5-Spring程序开发步骤"><a href="#5-Spring程序开发步骤" class="headerlink" title="5. Spring程序开发步骤"></a>5. Spring程序开发步骤</h4><pre><code>在jsp/servlet中，会用接口来引用接口实现的对象。

对于Spring开发，会在xml配置文件中用id标识来获取接口实现类全限定名，而后接口类通过Spring框架读取xml文件根据标识来获取对象，如下图所示</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppb9xOA"><img src="https://s1.ax1x.com/2023/04/09/ppb9xOA.png" alt="ppb9xOA.png"></a></p>
<pre><code>步骤总结：

1. 通过maven导入Spring开发的基本包坐标
 2. 编写Dao接口和实现类
 3. 创建Spring核心配置文件，在main/resources/创建xml文件
 4. 在Spring配置文件中配置UserDaoImpl
 5. 使用Spring的API获得Bean实例</code></pre>
<h4 id="6-Spring配置文件xml的介绍"><a href="#6-Spring配置文件xml的介绍" class="headerlink" title="6.Spring配置文件xml的介绍"></a>6.Spring配置文件xml的介绍</h4><h5 id="1-Bean标签基本配置"><a href="#1-Bean标签基本配置" class="headerlink" title="(1)Bean标签基本配置"></a>(1)Bean标签基本配置</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;唯一标识&quot; class=&quot;类的全限定名&quot;&gt;&lt;/bean&gt; //bean和class是基本属性</span><br></pre></td></tr></table></figure>

<pre><code>默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功</code></pre>
<h5 id="2-Bean标签的范围配置"><a href="#2-Bean标签的范围配置" class="headerlink" title="(2)Bean标签的范围配置"></a>(2)Bean标签的范围配置</h5><pre><code>属性  scope：指对象的作用范围，取值如下：</code></pre>
<table>
<thead>
<tr>
<th align="center">属性值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>singleton</strong></td>
<td align="center"><strong>默认值，单例</strong></td>
</tr>
<tr>
<td align="center"><strong>prototype</strong></td>
<td align="center"><strong>多例</strong></td>
</tr>
<tr>
<td align="center">request</td>
<td align="center">WEB项目中，Spring创建一个Bean的对象，将对象存入到request域中</td>
</tr>
<tr>
<td align="center">session</td>
<td align="center">WEB项目中，Spring创建一个Bean的对象，将对象存入到session域中</td>
</tr>
<tr>
<td align="center">global session</td>
<td align="center">WEB项目中，应用在Portlet环境，如果没有Portlet环境那么global session相当于session</td>
</tr>
</tbody></table>
<p>单例和多例的区别：</p>
<pre><code>单例是不管getBean(&quot;id&quot;)获取几次，都是同一地址的对象，多例获取几次，就创造几个对象，详细如下图所示</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppb8rIf"><img src="https://s1.ax1x.com/2023/04/09/ppb8rIf.png" alt="ppb8rIf.png"></a></p>
<h5 id="3-Bean生命周期的配置"><a href="#3-Bean生命周期的配置" class="headerlink" title="(3)Bean生命周期的配置"></a>(3)Bean生命周期的配置</h5><pre><code>属性  init-method：指定类中的初始化方法名称

属性  destroy-method：指定类中销毁方法名称

这些要指定的方法需要在接口实现类中编写，在使用bean标签加载时指定</code></pre>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;唯一标识&quot; class=&quot;类的全限定名&quot; init-method=&quot;bean初始化要执行的方法名&quot; destroy-method=&quot;bean销毁时要执行的方法名&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<pre><code>bean的创建是在main函数中用Spring的API创建</code></pre>
<h5 id="4-Bean实例化三种方法"><a href="#4-Bean实例化三种方法" class="headerlink" title="(4)Bean实例化三种方法"></a>(4)Bean实例化三种方法</h5><ul>
<li><p><strong>无参构造方法实例化</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;给接口类起的唯一标识名&quot; class=&quot;该接口实现类的全限定名&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>工厂静态方法实例化</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;给接口起的唯一标识名&quot; class=&quot;工厂类的全限定名&quot; factory-method=&quot;工厂类中返回该接口实现类的静态方法的名字&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>工厂实例方法实例化</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;给工厂类起的唯一标识名&quot; class=&quot;工厂类的全限定名&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;给接口起的唯一标识名&quot; factory-bean=&quot;给工厂类起的唯一标识名&quot; factory-method=&quot;工厂类中返回该接口实现类的动态方法的名字&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<pre><code>工厂方式实例化在JDBC获取时会使用到，但重点还是应该深入了解无参构造方法实例化</code></pre>
<h4 id="7-Bean的依赖注入"><a href="#7-Bean的依赖注入" class="headerlink" title="7. Bean的依赖注入"></a>7. Bean的依赖注入</h4><h5 id="1-从spring容器外部获取"><a href="#1-从spring容器外部获取" class="headerlink" title="1.从spring容器外部获取"></a>1.从spring容器外部获取</h5><p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppql3kT"><img src="https://s1.ax1x.com/2023/04/10/ppql3kT.png" alt="ppql3kT.png"></a></p>
<pre><code>在项目中会写service层调用dao层的实例，可以在编写service方法时，用spring获取dao类的实例，通过实例调用dao层的方法。

这个操作相当于在Spring容器外将Dao组装到service内部完成操作</code></pre>
<h5 id="2-从spring容器内部注入-依赖注入"><a href="#2-从spring容器内部注入-依赖注入" class="headerlink" title="2. 从spring容器内部注入(依赖注入)"></a>2. 从spring容器内部注入(依赖注入)</h5><p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppqln6s"><img src="https://s1.ax1x.com/2023/04/10/ppqln6s.png" alt="ppqln6s.png"></a></p>
<p><strong>两种注入方法</strong></p>
<p><strong>(1)使用set方法注入：</strong></p>
<pre><code>需要设置service层获得spring的对象，设置spring.xml文件将dao层对象注入，核心是编写xml文件完成注入

service层的实现中需要编写一个私有的dao的对象，并且编写setXxxx方法将私有dao对象赋值</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppq1MgH"><img src="https://s1.ax1x.com/2023/04/10/ppq1MgH.png" alt="ppq1MgH.png"></a></p>
<pre><code>spring的xml文件中的注入代码`property`的`name`属性写之前service层中setXxxx方法的xxxx(注意大小写)，ref属性写要注入的类的id</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppq3VMj"><img src="https://s1.ax1x.com/2023/04/10/ppq3VMj.png" alt="ppq3VMj.png"></a></p>
<pre><code>番外：`property`可以用p命名空间注入简化，引入命名空间是在`beans`标签引入</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppq89X9"><img src="https://s1.ax1x.com/2023/04/10/ppq89X9.png" alt="ppq89X9.png"></a></p>
<pre><code>所以上面spring的xml文件的代码也可以改为</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppq83AP"><img src="https://s1.ax1x.com/2023/04/10/ppq83AP.png" alt="ppq83AP.png"></a></p>
<p><strong>(2)使用有参构造方法注入：</strong></p>
<pre><code>service层的实现中需要编写一个私有的dao的对象，并且编写有参构造方法在构造时对私有dao对象赋值，同时为了编码规范应该在声明无参构造方法</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppqHEUH"><img src="https://s1.ax1x.com/2023/04/10/ppqHEUH.png" alt="ppqHEUH.png"></a></p>
<pre><code>在spring的xml文件中完成注入，其中`constructor-arg`中的`name`属性值为上面构造方法的参数名，ref属性写要注入的类的id</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppqH8aQ"><img src="https://s1.ax1x.com/2023/04/10/ppqH8aQ.png" alt="ppqH8aQ.png"></a></p>
<h5 id="3-补充：依赖注入的概念"><a href="#3-补充：依赖注入的概念" class="headerlink" title="3.补充：依赖注入的概念"></a>3.补充：依赖注入的概念</h5><p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppqlc1H"><img src="https://s1.ax1x.com/2023/04/10/ppqlc1H.png" alt="ppqlc1H.png"></a></p>
<h4 id="8-Bean的依赖注入的数据类型"><a href="#8-Bean的依赖注入的数据类型" class="headerlink" title="8. Bean的依赖注入的数据类型"></a>8. Bean的依赖注入的数据类型</h4><pre><code>除对象的引用可以注入，普通数据类型，集合都可以在容器中进行注入(用set或者构造方法)</code></pre>
<h5 id="1-普通数据类型的注入"><a href="#1-普通数据类型的注入" class="headerlink" title="1.普通数据类型的注入"></a>1.普通数据类型的注入</h5><pre><code>在dao的实现类中，建立成员变量，编写set方法</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppqHqzt"><img src="https://s1.ax1x.com/2023/04/10/ppqHqzt.png" alt="ppqHqzt.png"></a></p>
<pre><code>在spring的xml文件完成注入，name属性值为set后面一串首字母小写，因为是普通数据类型用value赋值</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppqHjL8"><img src="https://s1.ax1x.com/2023/04/10/ppqHjL8.png" alt="ppqHjL8.png"></a></p>
<h5 id="2-集合的注入"><a href="#2-集合的注入" class="headerlink" title="2.集合的注入"></a>2.集合的注入</h5><pre><code>在dao的实现类中，建立成员变量，编写set方法</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppqqC7D"><img src="https://s1.ax1x.com/2023/04/10/ppqqC7D.png" alt="ppqqC7D.png"></a></p>
<pre><code>在spring的xml文件完成注入，name属性值为set后面一串首字母小写，因为值比较特殊需要在`property`内部设置值，在其内部有子标签</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppqqaHU"><img src="https://s1.ax1x.com/2023/04/10/ppqqaHU.png" alt="ppqqaHU.png"></a></p>
<pre><code>而后通过子标签配置值，如list标签设置为下图所示，其余两个略</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppqq2DK"><img src="https://s1.ax1x.com/2023/04/10/ppqq2DK.png" alt="ppqq2DK.png"></a></p>
<h4 id="9-Spring配置文件的import标签"><a href="#9-Spring配置文件的import标签" class="headerlink" title="9.Spring配置文件的import标签"></a>9.Spring配置文件的import标签</h4><pre><code>项目中的不同模块需要拆分，此时要在主配置文件引入这些模块需要使用import标签进行加载

语法：resource属性值为要引入的Spring配置文件的位置</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">import</span> resource=<span class="string">&quot;applicationContext-xxx.xml&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<pre><code>当主文件加载时，分文件也会被加载

[![ppLLaXq.png](https://s1.ax1x.com/2023/04/11/ppLLaXq.png)](https://imgse.com/i/ppLLaXq)</code></pre>
<h4 id="10-小结"><a href="#10-小结" class="headerlink" title="10. 小结"></a>10. 小结</h4><p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppLOigs"><img src="https://s1.ax1x.com/2023/04/11/ppLOigs.png" alt="ppLOigs.png"></a></p>
<h4 id="11-Spring相关API"><a href="#11-Spring相关API" class="headerlink" title="11. Spring相关API"></a>11. Spring相关API</h4><p><strong>1. ApplicationContext继承体系</strong></p>
<pre><code>applicationContext：接口类型，可以通过其实例获得Spring容器的Bean对象</code></pre>
<p>​    </p>
<p><strong>2. ApplicationContext的实现类</strong></p>
<pre><code>(1).ClassPathXmlApplicationContext(&quot;参数为resource文件夹的xml文件路径&quot;)

    它是从类的根路径下加载配置文件(推荐使用)

(2).FileSystemXmlApplicationContext(&quot;参数为xml文件在电脑中的磁盘路径&quot;)

    它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置

(3).AnnotationConfigApplicationContext

    当使用注解配置容器对象时，需要使用此类来创建spring容器，它用来读取注解(之后再学)</code></pre>
<p><strong>3. getBean()方法使用</strong></p>
<pre><code>getBean()的API文档</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppLjplj"><img src="https://s1.ax1x.com/2023/04/11/ppLjplj.png" alt="ppLjplj.png"></a></p>
<pre><code>第一个是上面使用过的，传递的是xml文件中设置的id值

第二个是传字节码对象类型(xxxx.class)

第一个允许出现相同类型的bean因为可以用id进行区分，第二个只能由一种类型的bean



相同效果的两种方式的代码编写</code></pre>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/ppLjXuR"><img src="https://s1.ax1x.com/2023/04/11/ppLjXuR.png" alt="ppLjXuR.png"></a></p>
<pre><code>这个UserService是接口类，等于是获得接口类的反射</code></pre>

      
    </div>
</article>

    </li>
  
</ul>



            <footer>
    <div>© 2023 - nature </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>